/*
 Navicat Premium Data Transfer

 Source Server         : 121.36.104.226
 Source Server Type    : MySQL
 Source Server Version : 80024
 Source Host           : 121.36.104.226:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80024
 File Encoding         : 65001

 Date: 31/05/2023 22:39:20
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for blog
-- ----------------------------
DROP TABLE IF EXISTS `blog`;
CREATE TABLE `blog`  (
  `id` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `title` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '博客标题',
  `cover` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '封面',
  `description` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '描述',
  `content` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '博客内容',
  `author` varchar(5) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '博客作者',
  `userId` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '用户id',
  `collectNumber` int(0) NOT NULL DEFAULT 0 COMMENT '收藏数',
  `likeNumber` int(0) UNSIGNED NOT NULL DEFAULT 0 COMMENT '点赞数',
  `isdelete` tinyint(1) NOT NULL DEFAULT 1 COMMENT '删除标识符号',
  `createTime` datetime(3) NOT NULL,
  `updateTime` datetime(3) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_user_blog`(`userId`) USING BTREE COMMENT '用户id查询索引'
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog
-- ----------------------------
INSERT INTO `blog` VALUES ('06186ebc4076e1cdec8496471ce3a30a', 'MongDB', 'http://rusndkp3v.bkt.clouddn.com/blogFile/1629495477589856258/mongodb.webp', 'mongDB', '<h1>MongoDB</h1><h3>概念</h3><table style=\"width: auto;\"><tbody><tr><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">SQL术语</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">MongoDB术语</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">解释</th></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">database</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">database</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">数据库</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">table</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">collection</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">数据库表/集合</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">row</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">document</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">数据记录行/文档</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">column</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">field</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">数据字段/域</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">index</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">index</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">索引</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">table joins</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\"></td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">表连接</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">primary</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">primary</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">主键</td></tr></tbody></table><h5>数据类型</h5><table style=\"width: auto;\"><tbody><tr><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">数据类型</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">描述</th></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">String</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">字符串.存储数据常用的数据类型,UTF-8在mongodb中才是合法的</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Integer</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">整型数值.用于存储数值.根据服务器,分为32和64位.</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Boolean</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">布尔值</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Double</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">双精度浮点值</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Min/Max keys</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">将一个值与BSON(二进制的JSON)元素的最低值和最高值相对比</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Array</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">用于将数组或列表或多个值存储为一个键</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Timestamp</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">时间戳</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Object</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">用于内嵌文档</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Symbol</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">符号.该数据类型基本上等同于字符串类型.</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Date</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">日期时间</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Object ID</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">对象ID</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Binary Data</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">二进制数据</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Code</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">代码类型</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Regular expression</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">正则表达式类型</td></tr></tbody></table><ol><li>ObjectId 类似唯一主键,一共12个字节 前4个字节表示创建unix时间戳 3个字节是机器标识码 两个字节由进程id组成PID 最后三个字节是随机数</li><li>时间戳 64位的值 前32位是一个time_t值 后32秒是在某秒钟操作的一个递增的序数</li><li>日期 表示当前距离Unix新纪元的毫秒值.日期类型是有符号的,负数表示1970年之前的日期.</li></ol><h5>MongDB连接</h5><p>连接语法:</p><pre><code class=\"language-MongoDB\">mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]\n</code></pre><ul><li>mongodb:// 固定格式</li><li>username:password@ 可选项,如果设置,在连接这个数据库服务器之后,驱动都会尝试登录这个数据库</li><li>host1 必须指定一个host</li><li>portX 可选的指定端口,默认27017</li><li>/database 默认test库</li><li>?option 连接选项</li></ul><h3>数据库</h3><h5>创建数据库</h5><pre><code class=\"language-javascript\">use blog //如果数据库不存在则创建数据库,存在则切换\nshow dbs //展示所有数据库\n</code></pre><h5>删除数据库</h5><pre><code class=\"language-js\">db.dropDatabase() //删除数据库\ndb.collection.drop()//删除集合 collection代表集合名\n</code></pre><h3>集合</h3><h5>创建集合</h5><pre><code class=\"language-js\">db.createCollection(name, options)//创建集合\ndb.blog.insert({\"name\" : \"博客\"})//直接插入文档不需要创建集合\nshow collections//查看集合\n</code></pre><h5>删除集合</h5><pre><code class=\"language-js\">db.blog.drop()//删除blog集合\n</code></pre><h3>文档</h3><h5>插入文档</h5><pre><code class=\"language-js\">db.blog.insert({\"name\":\"博客\",\"author\":\"作者\"})//插入博客文档\ndb.blog.save({\"name\":\"博客\",\"author\":\"作者\"})//已弃用 用db.collection.insertOne() 或 db.collection.replaceOne() 代替\ndocument=({title: \'博客\', \n    description: \'博客\',\n    by: \'plumoon\'\n});//保存为变量再插入集合中\n</code></pre><h5>更新文档</h5><pre><code class=\"language-js\">db.blog.update({\"name\":\"博客\"},{$set:{\"name\":\"MongoDB\"}})//更新文档\ndb.blog.update({\"author\":\"作者\"},{$set:{\"name\":\"Mongo\"}},{multi:true})//批量更新\n</code></pre><h5>删除文档</h5><pre><code class=\"language-js\">db.blog.remove({\"name\":\"博客\"})//删除文档\ndb.blog.remove({\"name\":\"博客\"},1)//只删除第一条\ndb.blog.remove({})//删除所有数据\n</code></pre><h5>查询文档</h5><pre><code class=\"language-js\">db.blog.find({key1:value1, key2:value2}).pretty()//and查询\ndb.col.find({$or: [{key1: value1}, {key2:value2}]}).pretty()//OR查询\n</code></pre><h3>操作符</h3><ul><li>(&gt;) 大于 - $gt</li><li>(&lt;) 小于 - $lt</li><li>(&gt;=) 大于等于 - $gte</li><li>(&lt;= ) 小于等于 - $lte</li></ul><pre><code >db.blog.find({\"name\" : {$type : 2}})\n或\ndb.blog.find({\"name\" : {$type : \'string\'}})//根据字段类型查询\n</code></pre><table style=\"width: auto;\"><tbody><tr><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">类型</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">数字</th></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Double</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">1</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">String</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">2</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Object</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">3</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Array</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">4</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Binary data</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">5</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Undefined</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">6</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Object id</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">7</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Boolean</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">8</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Date</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">9</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Null</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">10</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Regular Expression</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">11</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">JavaScript</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">15</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">32-bit integer</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">16</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Timestamp</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">17</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">64-bit integer</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">18</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Min key</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">255</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Max key</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">127</td></tr></tbody></table><h3>Limit与Skip方法</h3><pre><code class=\"language-js\">db.blog.find().limit(2)//查找两条数据\ndb.blog.find().limit(2).skip(1)//跳过一条数据查找两条数据\n</code></pre><h3>排序</h3><pre><code class=\"language-js\">db.blog.find().sort({KEY:1})//sort()方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。\n</code></pre><h3>索引</h3><pre><code >db.blog.createIndex(keys, options)//\n</code></pre><table style=\"width: auto;\"><tbody><tr><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Parameter</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">type</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Description</th></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">background</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Boolean</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 \"background\" 可选参数。 \"background\" 默认值为<strong>false</strong>。</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">unique</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Boolean</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">建立的索引是否唯一.指定为true创建唯一索引.默认值为false</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">name</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">String</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">索引的名称.如果未指定,MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">sparse</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Boolean</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">对文档中不存在的字段数据不启用索引;这个参数需要特别注意,如果设置为true的话,在索引字段中不会查询包含对应字段的文档.默认值为false.</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">expireAfterSeconds</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">integer</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">指定一个以秒为单位的数值,完成TTl设定,设定集合的生存时间</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">V</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">index version</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">索引的版本号.默认的索引版本取决于mongod创建索引时运行的版本.</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">weights</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">document</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">索引权重值,数值1到99999之间,表示索引相对于其他索引字段的得分权重</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">default_language</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">String</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">对于文本索引,该参数决定了停用词及词干和词器的规则的列表.默认为英语</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">language_override</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">string</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">对于文本索引,该参数指定了包含在文档中的字段名,语言覆盖默认的language,默认值为language</td></tr></tbody></table><h3>聚合</h3><p>aggregate()</p><pre><code class=\"language-js\">db.blog.aggregate(AGGREGATE_OPERATION)\n</code></pre><p>likes代表对应值</p><table style=\"width: auto;\"><tbody><tr><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">表达式</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">描述</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">实例</th></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">$sum</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">计算总和</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">db.blog.aggregate([{$group:{_id:\"$name\",num_tutorial:{$sum:\"$likes\"}}}])</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">$avg</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">计算平均值</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">db.blog.aggregate([{$group : {_id : \"$name\", num_tutorial :{$avg:\"$likes\"}}}])</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">$min</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">获取集合中所有文档对应值得最小值.</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">db.blog.aggregate([{$group : {_id : \"$name\", num_tutorial :{$min : \"$likes\"}}}])</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">$max</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">获取集合中所有文档对应值得最大值.</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">db.blog.aggregate([{$group : {_id : \"$name\", num_tutorial : {$max : \"$likes\"}}}])</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">$push</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">将值加入一个数组中，不会判断是否有重复的值。</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">db.blog.aggregate([{$group : {_id : \"$name\", url : {$push: \"$url\"}}}])</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">$addToSet</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">将值加入一个数组中，会判断是否有重复的值，若相同的值在数组中已经存在了，则不加入。</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">db.blog.aggregate([{$group : {_id : \"$name\", url : {$addToSet : \"$url\"}}}])</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">$first</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">根据资源文档的排序获取第一个文档数据。</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">db.blog.aggregate([{$group : {_id : \"$name\", first_url : {$first : \"$url\"}}}])</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">$last</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">根据资源文档的排序获取最后一个文档数据</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">db.blog.aggregate([{$group : {_id : \"$name\", last_url : {$last : \"$url\"}}}])</td></tr></tbody></table><h5>管道</h5><ul><li>$project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 db.blog.aggregate({ $project : {name : 1 ,author : 1}});</li><li>$match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。 db.blog.aggregate([{$match:{x:{$gt:11,$lte:13}}}]);</li><li>$limit：用来限制MongoDB聚合管道返回的文档数。 db.blog.aggregate({$limit:2});</li><li>$skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。 db.blog.aggregate({$skip:2});</li><li>$unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</li><li>$group：将集合中的文档分组，可用于统计结果。</li><li>$sort：将输入文档排序后输出。</li><li>$geoNear：输出接近某一地理位置的有序文档。</li></ul><h3>用户管理</h3><pre><code >db.createUser({ user: \"plumoon\", pwd: \"lzj439949\", roles: [{ role: \"userAdminAnyDatabase\", db: \"admin\" }] })//创建管理员账号\ndb.createUser({user: \"root\",pwd: \"lzj439949\", roles: [ { role: \"root\", db: \"admin\" } ]})//创建root账号\ndb.createUser({user: \"blog\",pwd: \"lzj439949\",roles: [ { role: \"dbOwner\", db: \"blog\" } ]})//创建自己数据库的账号\nshow users//查看用户\ndb.auth(\"admin\",\"password\")//删除用户\ndb.system.users.remove({user:\"XXXXXX\"})//删除单个用户\ndb.system.users.remove({})//\n</code></pre><p><br></p>', '澹台子中', '241fcbc1b24522d73c8e593de8315917', 1, 2, 1, '2023-05-17 19:39:31.942', '2023-05-31 00:00:00.049');
INSERT INTO `blog` VALUES ('10abd77c4739fd0a04e9ec435c044e0f', 'vue', '223.104.247.6', '“博客”当然是个大家都陌生的名词,博客的英文名词就是“Blog或Weblog”(指人时对应于Blogger),是一个典型的网络新事物,查阅最新的英文词典也不可能查到', '今天闲来无今天闲来无事，写了一个下载网上文件的小工具，但当把网上的mp3文件和mp4文件下载下来之后发现打不开，这就郁闷啦！既然能把文件下载下来就证明  URLConnection是没有问题的。查看文件属性也是可以看到文件大小的，这证明数据是有的。很显然是文件读取或写入的时候出现了问题。事，写了一个下载网上文件的小工具，但当把网上的mp3文件和mp4文件下载下来之后发现打不开，这就郁闷啦！既然能把文件下载下来就证明  URLConnection是没有问题的。查看文件属性也是可以看到文件大小的，这证明数据是有的。很显然是文件读取或写入的时候出现了问题。今天闲来无今天闲来无事，写了一个下载网上文件的小工具，但当把网上的mp3文件和mp4文件下载下来之后发现打不开，这就郁闷啦！既然能把文件下载下来就证明  URLConnection是没有问题的。查看文件属性也是可以看到文件大小的，这证明数据是有的。很显然是文件读取或写入的时候出现了问题。事，写了一个下载网上文件的小工具，但当把网上的mp3文件和mp4文件下载下来之后发现打不开，这就郁闷啦！既然能把文件下载下来就证明  URLConnection是没有问题的。查看文件属性也是可以看到文件大小的，这证明数据是有的。很显然是文件读取或写入的时候出现了问题。', '林志杰', '1626518508932235265', 0, 0, 0, '2023-03-20 05:30:24.469', '2023-05-15 00:00:00.098');
INSERT INTO `blog` VALUES ('1178d4c34865d3ae373af9288a892cc2', 'springboot', '223.104.247.6', '“博客”当然是个大家都陌生的名词,博客的英文名词就是“Blog或Weblog”(指人时对应于Blogger),是一个典型的网络新事物,查阅最新的英文词典也不可能查到', '啥计划的大啊啊所多', '林志杰', '1626518508932235265', 0, 0, 0, '2023-03-20 05:30:36.495', '2023-05-17 00:00:00.175');
INSERT INTO `blog` VALUES ('172462afc42420e547c5ec81a2d905fc', 'JVM虚拟机', 'http://rt6vvz8xh.bkt.clouddn.com/blogFile/1629495477589856258/b219ebc4b74543a9e3e0ca386c1dac8eb8011464.webp', '“博客”当然是个大家都陌生的名词,博客的英文名词就是“Blog或Weblog”(指人时对应于Blogger),是一个典型的网络新事物,查阅最新的英文词典也不可能查到', '啥计划的大 啊啊所多', '林志杰', '1626518508932235265', 0, 0, 0, '2023-03-20 03:41:05.263', '2023-03-20 03:41:05.263');
INSERT INTO `blog` VALUES ('19a29b22ce8cd7f933c97ca6e1f834c0', '11_Java程序员要掌握的前端-rea', 'http://rusndkp3v.bkt.clouddn.com/blogFile/1629495477589856258/recat.webp', 'recat', '<h1>五. React</h1><h2>1. React 基础</h2><p>react 是前端三大框架之一</p><ul><li>没有 vue 的基础更好，因为两者思想不太一样，不能用 vue 的习惯学习 react</li><li>需要有 js 基础，视频 19-58</li><li>需要有 ts 基础，视频 110-116</li><li>本教程采用更流行的【函数式组件 + hooks】方式进行讲解</li></ul><h3>1) 环境准备</h3><h4>创建项目</h4><p>首先，通过 react 脚手架创建项目</p><pre><code class=\"language-cmd\">npx create-react-app client --template typescript\n</code></pre><ul><li>client 是项目名</li><li>目前 react 版本是 18.x</li></ul><p>运行项目</p><pre><code class=\"language-cmd\">cd client\nnpm start\n</code></pre><ul><li>会自动打开浏览器，默认监听 3000 端口</li></ul><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20221001110328233.png\" alt=\"image-20221001110328233\" data-href=\"\" style=\"\"/></p><h4>修改端口</h4><p>在项目根目录下新建文件 .env.development，它可以定义开发环境下的环境变量</p><pre><code class=\"language-properties\">PORT=7070\n</code></pre><p>重启项目，端口就变成了 7070</p><ul><li>参考文档：<a href=\"https://create-react-app.dev/docs/advanced-configuration/\" target=\"\">Advanced Configuration | Create React App (create-react-app.dev)</a></li></ul><h4>浏览器插件</h4><p>插件地址 <a href=\"https://reactjs.org/blog/2015/09/02/new-react-developer-tools.html#installation\" target=\"\">New React Developer Tools – React Blog (reactjs.org)</a></p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20221004105110150.png\" alt=\"image-20221004105110150\" data-href=\"\" style=\"\"/></p><h4>VSCode</h4><p>推荐安装 Prettier 代码格式化插件</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20221004090816142.png\" alt=\"image-20221004090816142\" data-href=\"\" style=\"\"/></p><h3>2) 入门案例</h3><h4>Hello</h4><p>编写一个 src/pages/Hello.tsx 组件</p><pre><code class=\"language-tsx\">export default function Hello()  {\n  return &lt;h3&gt;Hello, World!&lt;/h3&gt;\n}\n</code></pre><ul><li>组件中使用了 jsx 语法，即在 js 中直接使用 html 标签或组件标签</li><li>函数式组件必须返回标签片段</li></ul><p>在 index.js 引入组件</p><pre><code class=\"language-jsx\">import React from \'react\'\nimport ReactDOM from \'react-dom/client\'\nimport \'./index.css\'\nimport reportWebVitals from \'./reportWebVitals\'\n// 1. 引入组件\nimport Hello from \'./pages/Hello\'\n\nconst root = ReactDOM.createRoot(document.getElementById(\'root\') as HTMLElement)\nroot.render(\n  &lt;React.StrictMode&gt;\n    {/* 2. 将原来的 &lt;App/&gt; 改为 &lt;Hello&gt;&lt;/Hello&gt; */}\n    &lt;Hello&gt;&lt;/Hello&gt;\n  &lt;/React.StrictMode&gt;\n)\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals()\n</code></pre><p>将欢迎词作为属性传递给组件</p><pre><code class=\"language-jsx\">&lt;Hello msg=\'你好\'&gt;&lt;/Hello&gt;\n</code></pre><ul><li>字符串值，可以直接使用双引号赋值</li><li>其它类型的值，用 <code>{值}</code></li></ul><p>而组件修改为</p><pre><code class=\"language-tsx\">export default function Hello(props: { msg: string }) {\n  return &lt;h3&gt;{props.msg}&lt;/h3&gt;\n}\n</code></pre><h4>jsx 原理</h4><pre><code class=\"language-tsx\">export default function Hello(props: { msg: string }) {\n  return &lt;h3&gt;{props.msg}&lt;/h3&gt;\n}\n</code></pre><p>在 v17 之前，其实相当于</p><pre><code class=\"language-tsx\">import { createElement } from \"react\";\nexport default function Hello(props: {msg: string}) {\n  return createElement(\'h3\', null, `${props.msg}`)\n}\n</code></pre><h3>3) 人物卡片案例</h3><p>样式已经准备好 /src/css/P1.css</p><pre><code class=\"language-css\">#root {\n  display: flex;\n  width: 100vw;\n  height: 100vh;\n  justify-content: center;\n  align-items: center;\n}\n\ndiv.student {\n  flex-shrink: 0;\n  flex-grow: 0;\n  position: relative;\n  width: 128px;\n  height: 330px;\n  /* font-family: \'华文行楷\'; */\n  font-size: 14px;\n  text-align: center;\n  margin: 20px;\n  display: flex;\n  justify-content: flex-start;\n  background-color: #7591AD;\n  align-items: center;\n  flex-direction: column;\n  border-radius: 5px;\n  box-shadow: 0 0 8px #2c2c2c;\n  color: #e8f6fd;\n}\n\n.photo {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  border-radius: 0%;\n  overflow: hidden;\n  transition: 0.3s;\n  border-radius: 5px;\n}\n\n.photo img {\n  width: 100%;\n  height: 100%;\n  /* object-fit: scale-down; */\n  object-fit: cover;\n}\n\n.photo::before {\n  position: absolute;\n  content: \'\';\n  width: 100%;\n  height: 100%;\n  background-image: linear-gradient(to top, #333, transparent);\n}\n\ndiv.student h2 {\n  position: absolute;\n  font-size: 20px;\n  width: 100%;\n  height: 68px;\n  font-weight: normal;\n  text-align: center;\n  margin: 0;\n  line-height: 68px;\n  visibility: hidden;\n}\n\nh2::before {\n  position: absolute;\n  top: 0;\n  left: 0;\n  content: \'\';\n  width: 100%;\n  height: 68px;\n  background-color: rgba(0, 0, 0, 0.3);\n  border-top-left-radius: 5px;\n  border-top-right-radius: 5px;  \n}\n\ndiv.student h1 {\n  position: absolute;\n  top: 250px;\n  font-size: 22px;\n  margin: 0;\n  transition: 0.3s;\n  font-weight: normal;\n}\n\ndiv.student p {\n  margin-top: 300px;\n  width: 80%;\n  font-weight: normal;\n  text-align: center;\n  padding-bottom: 5px;\n  border-bottom: 1px solid #8ea2b8;\n}\n\n.student:hover .photo::before {\n  display: none;\n}\n\n.student:hover .photo {\n  width: 90px;\n  height: 90px;\n  top: 90px;\n  border-radius: 50%;\n  box-shadow: 0 0 15px #111;\n}\n\n.student:hover img {\n  object-position: 50% 0%;\n}\n\n.student:hover h1 {\n  position: absolute;\n  top: 190px;\n  width: 40px;\n}\n\ndiv.student:hover h2 {\n  visibility: visible;\n}\n</code></pre><p>类型 /src/model/Student.ts</p><pre><code class=\"language-typescript\">export interface Student {\n  id: number,\n  name: string,\n  sex: string,\n  age: number,\n  photo: string\n}\n</code></pre><p>组件 /src/pages/P1.tsx</p><pre><code class=\"language-tsx\">import { Student } from \'../model/Student\'\nimport \'../css/P1.css\'\nexport default function P1(props: { student: Student }) {\n  return (\n    &lt;div className=\'student\'&gt;\n      &lt;div className=\'photo\'&gt;\n        &lt;img src={props.student.photo}/&gt;\n      &lt;/div&gt;\n      &lt;h1&gt;{props.student.name}&lt;/h1&gt;\n      &lt;h2&gt;{props.student.id}&lt;/h2&gt;      \n      &lt;p&gt;性别 {props.student.sex} 年龄 {props.student.age}&lt;/p&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre><p>使用组件</p><pre><code class=\"language-tsx\">const stu1 = { id: 1, name: \'风清扬\', sex: \'男\', age: 99, photo: \'/imgs/1.png\' }\nconst stu2 = { id: 2, name: \'玮哥\', sex: \'男\', age: 20, photo: \'/imgs/2.png\' }\nconst stu3 = { id: 3, name: \'长宏\', sex: \'男\', age: 30, photo: \'/imgs/3.png\'}\n\n&lt;P1 student={stu1}&gt;&lt;/P1&gt;\n&lt;P1 student={stu2}&gt;&lt;/P1&gt;\n&lt;P1 student={stu3}&gt;&lt;/P1&gt;\n</code></pre><h4>路径</h4><ul><li>src 下的资源，要用相对路径引入</li><li>public 下的资源，记得 / 代表路径的起点</li></ul><h4>标签命名</h4><ul><li>组件标签必须用大驼峰命名</li><li>普通 html 标签必须用小写命名</li></ul><h4>事件处理</h4><pre><code class=\"language-tsx\">import { Student } from \'../model/Student\'\nimport \'../css/P1.css\'\nexport default function P1(props: { student: Student }) {\n    \n  function handleClick(e : React.MouseEvent){\n    console.log(student)\n    console.log(e)\n  }\n  \n  return (\n    &lt;div className=\'student\'&gt;\n      &lt;div className=\'photo\' onClick={handleClick}&gt;\n        &lt;img src={props.student.photo}/&gt;\n      &lt;/div&gt;\n      &lt;h1&gt;{props.student.name}&lt;/h1&gt;\n      &lt;h2&gt;{props.student.id}&lt;/h2&gt;\n      &lt;p&gt;性别 {props.student.sex} 年龄 {props.student.age}&lt;/p&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre><ul><li>事件以小驼峰命名</li><li>事件处理函数可以有一个事件对象参数，可以获取事件相关信息</li></ul><h4>列表 & Key</h4><pre><code class=\"language-tsx\">import { Student } from \'../model/Student\'\nimport P1 from \'./P1\'\n\nexport default function P2(props: { students: Student[] }) {\n  return (\n    &lt;&gt;\n      {props.students.map((s) =&gt; ( &lt;P1 student={s} key={s.id}&gt;&lt;/P1&gt; ))}\n    &lt;/&gt;\n  )\n}\n</code></pre><ul><li>key 在循环时是必须的，否则会有 warning</li></ul><p>也可以这么做</p><pre><code class=\"language-tsx\">import { Student } from \'../model/Student\'\nimport P1 from \'./P1\'\n\nexport default function P2(props: { students: Student[] }) {\n  const list = props.students.map((s) =&gt; &lt;P1 student={s} key={s.id}&gt;&lt;/P1&gt;)\n  return &lt;&gt;{list}&lt;/&gt;\n}\n</code></pre><p>使用组件</p><pre><code class=\"language-tsx\">const stu1 = { id: 1, name: \'风清扬\', sex: \'男\', age: 99, photo: \'/1.png\' }\nconst stu2 = { id: 2, name: \'玮哥\', sex: \'男\', age: 45, photo: \'/2.png\' }\nconst stu3 = { id: 3, name: \'长宏\', sex: \'男\', age: 45, photo: \'/3.png\'}\n\n&lt;P2 students={[stu1,stu2,stu3]}&gt;&lt;/P2&gt;\n</code></pre><h4>条件渲染</h4><p>P1 修改为</p><pre><code class=\"language-tsx\">import { Student } from \'../model/Student\'\nimport \'../css/P1.css\'\nexport default function P1(props: { student: Student; hideAge?: boolean }) {\n  function handleClick() {\n    console.log(props.student)\n  }\n\n  const ageFragment = !props.hideAge && &lt;span&gt;年龄 {props.student.age}&lt;/span&gt;\n\n  return (\n    &lt;div className=\'student\'&gt;\n      &lt;div className=\'photo\' onClick={handleClick}&gt;\n        &lt;img src={props.student.photo} /&gt;\n      &lt;/div&gt;\n      &lt;h1&gt;{props.student.name}&lt;/h1&gt;\n      &lt;h2&gt;{props.student.id}&lt;/h2&gt;\n      &lt;p&gt;\n        性别 {props.student.sex} {ageFragment}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre><ul><li>子元素如果是布尔值，nullish，不会渲染</li></ul><p>P2 修改为</p><pre><code class=\"language-tsx\">import { Student } from \'../model/Student\'\nimport P1 from \'./P1\'\n\nexport default function P2(props: { students: Student[]; hideAge?: boolean }) {\n  const list = props.students.map((s) =&gt; (\n    &lt;P1 student={s} hideAge={props.hideAge} key={s.id}&gt;&lt;/P1&gt;\n  ))\n  return &lt;&gt;{list}&lt;/&gt;\n}\n</code></pre><p>使用组件</p><pre><code class=\"language-tsx\">const stu1 = { id: 1, name: \'风清扬\', sex: \'男\', age: 99, photo: \'/1.png\' }\nconst stu2 = { id: 2, name: \'玮哥\', sex: \'男\', age: 45, photo: \'/2.png\' }\nconst stu3 = { id: 3, name: \'长宏\', sex: \'男\', age: 45, photo: \'/3.png\'}\n\n&lt;P2 students={[stu1,stu2,stu3]} hideAge={true}&gt;&lt;/P2&gt;\n</code></pre><h4>参数解构</h4><p>以 P1 组件为例</p><pre><code class=\"language-tsx\">import { Student } from \'../model/Student\'\nimport \'../css/P1.css\'\nexport default function P1\n({ student, hideAge = false }: { student: Student, hideAge?: boolean }) {\n  \n  function handleClick() {\n    console.log(student)\n  }\n\n  const ageFragment = !hideAge && &lt;span&gt;年龄 {student.age}&lt;/span&gt;\n\n  return (\n    &lt;div className=\'student\'&gt;\n      &lt;div className=\'photo\' onClick={handleClick}&gt;\n        &lt;img src={student.photo} /&gt;\n      &lt;/div&gt;\n      &lt;h1&gt;{student.name}&lt;/h1&gt;\n      &lt;h2&gt;{student.id}&lt;/h2&gt;\n      &lt;p&gt;\n        性别 {student.sex} {ageFragment}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre><ul><li>可以利用解构赋值语句，让 props 的使用更为简单</li><li>对象解构赋值还有一个额外的好处，给属性赋默认值</li></ul><p>使用组件</p><pre><code class=\"language-tsx\">const stu1 = { id: 1, name: \'风清扬\', sex: \'男\', age: 99, photo: \'/1.png\' }\n\n&lt;P1 student={stu1}&gt;&lt;/P1&gt;\n</code></pre><h3>4) 处理变化的数据</h3><p>入门案例侧重的是数据展示，并未涉及到数据的变动，接下来我们开始学习 react 如何处理数据变化</p><h4>axios</h4><p>首先来学习 axios，作用是发送请求、接收响应，从服务器获取真实数据</p><p>安装</p><pre><code class=\"language-cmd\">npm install axios\n</code></pre><p>定义组件</p><pre><code class=\"language-tsx\">import axios from \'axios\'\nexport default function P4({ id }: { id: number }) {\n  async function updateStudent() {\n    const resp = await axios.get(`http://localhost:8080/api/students/${id}`)\n    console.log(resp.data.data)\n  }\n\n  updateStudent()\n\n  return &lt;&gt;&lt;/&gt;\n}\n</code></pre><ul><li>其中 /api/students/${id} 是提前准备好的后端服务 api，会延迟 2s 返回结果</li></ul><p>使用组件</p><pre><code class=\"language-tsx\">&lt;P4 id={1}&gt;&lt;/P4&gt;\n</code></pre><p>在控制台上打印</p><pre><code >{\n    \"id\": 1,\n    \"name\": \"宋远桥\",\n    \"sex\": \"男\",\n    \"age\": 40\n}\n</code></pre><p>当属性变化时，会重新触发 P4 组件执行，例如将 id 从 1 修改为 2</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20221005160308705.png\" alt=\"image-20221005160308705\" data-href=\"\" style=\"\"/></p><p>执行流程</p><ul><li>首次调用函数组件，返回的 jsx 代码会被渲染成【虚拟 dom 节点】（也称 Fiber 节点）</li><li>当函数组件的 props 或 state 发生变化时，才会<strong>重新</strong>调用函数组件，返回 jsx</li><li>由于严格模式会触发两次渲染，为了避免干扰，请先注释掉 index.tsx 中的 <code>&lt;React.StrictMode&gt;</code></li></ul><h4>状态</h4><p>先来看一个例子，能否把服务器返回的数据显示在页面上</p><pre><code class=\"language-tsx\">import axios from \'axios\'\nlet count = 0\nexport default function P5(props: { id: number }) {\n  \n  function getTime() {\n    const d = new Date()\n    return d.getHours() + \':\' + d.getMinutes() + \':\' + d.getSeconds()\n  }\n  \n  async function updateStudent() {\n    const resp = await axios.get(\n      `http://localhost:8080/api/students/${props.id}`\n    )\n    Object.assign(student, resp.data.data)\n    console.log(current, student, getTime())\n  }\n\n  const current = count++\n  let student = { name: \'xx\' }\n  console.log(current, student, getTime())\n  updateStudent()\n  \n  return &lt;h3&gt;姓名是：{student.name}&lt;/h3&gt;\n}\n</code></pre><ul><li>count 是一个全局变量，记录 P5 函数第几次被调用</li></ul><p>执行效果，控制台上</p><pre><code >0 {name: \'xx\'} \'16:22:16\'\n0 {id: 1, name: \'宋远桥\', sex: \'男\', age: 40} \'16:22:18\'\n</code></pre><p>此时页面仍显示 <code>姓名是：xx</code></p><p>那么修改一下 props 的 id 呢？进入开发工具把 id 从 1 修改为 2，控制台上</p><pre><code class=\"language-tsx\">1 {name: \'xx\'} \'16:24:0\'\n1 {id: 2, name: \'俞莲舟\', sex: \'男\', age: 38} \'16:24:2\'\n</code></pre><p>此时页面仍显示 <code>姓名是：xx</code></p><p>为什么页面没有显示两秒后更新的值？</p><ul><li>第一次，页面显示的是 P5 函数的返回结果，这时 student.name 还未被更新成宋远桥，页面显示 xx</li><li>第二次，虽然 props 修改触发了函数重新执行，但既然函数重新执行，函数内的 student 又被赋值为 <code>{ name: \'xx\' }</code>，页面还是显示 xx</li></ul><p>结论：</p><ul><li>函数是无状态的，执行完毕后，它内部用的数据都不会保存下来</li><li>要想让函数有状态，就需要使用 useState 把数据保存在函数之外的地方，这些数据，称之为状态</li></ul><h4>useState</h4><pre><code class=\"language-tsx\">import axios from \'axios\'\nimport { useReducer, useState } from \'react\'\nimport { Student } from \'../model/Student\'\nlet count = 0\nexport default function P5(props: { id: number }) {\n\n  // ...\n\n  async function updateStudent() {\n    const resp = await axios.get(\n      `http://localhost:8080/api/students/${props.id}`\n    )\n    Object.assign(student, resp.data.data)\n    console.log(current, student, getTime())\n  }\n\n  const current = count++\n  let [student] = useState&lt;Student&gt;({ name: \'xx\' })\n  console.log(current, student, getTime())\n  updateStudent()\n\n  return &lt;h3&gt;姓名是：{student.name}&lt;/h3&gt;\n}\n</code></pre><p>接下来使用 setXXX 方法更新 State</p><pre><code class=\"language-tsx\">import axios from \'axios\'\nimport { useState } from \'react\'\nimport { Student } from \'../model/Student\'\nexport default \n\nfunction P5(props: { id: number }) {\n  async function updateStudent() {\n    const resp = await axios.get(`/api/students/${props.id}`)\n    setStudent(resp.data.data)\n  }\n\n  let [student, setStudent] = useState&lt;Student&gt;({ name: \'xx\' })\n  updateStudent()\n\n  return &lt;h3&gt;姓名是：{student.name}&lt;/h3&gt;\n}\n</code></pre><p>工作流程如下</p><p>首次使用 useState，用它的参数初始化 State</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20221005173958351.png\" alt=\"image-20221005173958351\" data-href=\"\" style=\"\"/></p><p>2s 后数据更新，setStudent 函数会更新 State 数据，并会触发下一次渲染（P5 的调用）</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20221005174347981.png\" alt=\"image-20221005174347981\" data-href=\"\" style=\"\"/></p><p>再次调用 useState，这时返回更新后的数据</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20221005174739593.png\" alt=\"image-20221005174739593\" data-href=\"\" style=\"\"/></p><p>这时再返回 jsx，内容就是 <code>姓名是：宋远桥</code> 了</p><blockquote>P.S. 使用了 useState 之后，会执行两次 xhr 请求，后一次请求是 react 开发工具发送的，不用理会</blockquote><p>问题还未结束，第二次 P5 调用时，updateStudent 还会执行，结果会导致 2s 后响应返回继续调用 setStudent，这会导致每隔 2s 调用一次 P5 函数（渲染一次）</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20221005175440228.png\" alt=\"image-20221005175440228\" data-href=\"\" style=\"\"/></p><p>如何让 updateStudent 只执行一次呢？一种土办法是再设置一个布尔 State </p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20221005181042078.png\" alt=\"image-20221005181042078\" data-href=\"\" style=\"\"/></p><p>接下来数据更新</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20221005181428984.png\" alt=\"image-20221005181428984\" data-href=\"\" style=\"\"/></p><p>第二次进入 P5 函数时，由于 fetch 条件不成立，因此不会再执行两个 setXXX 方法</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20221005182505908.png\" alt=\"image-20221005182505908\" data-href=\"\" style=\"\"/></p><p>函数式组件的工作流程</p><ul><li>首次调用函数组件，返回的 jsx 代码会被渲染成【虚拟 dom 节点】（也称 Fiber 节点）</li><li>当函数组件的 props 或 state 发生变化时，才会重新调用函数组件，返回 jsx</li></ul><h4>useEffect</h4><p>Effect 称之为副作用（没有贬义），函数组件的主要目的，是为了渲染生成 html 元素，除了这个主要功能以外，管理状态，fetch 数据 ... 等等之外的功能，都可以称之为副作用。</p><p>useXXX 打头的一系列方法，都是为副作用而生的，在 react 中把它们称为 Hooks</p><p>useEffect 三种用法</p><pre><code class=\"language-tsx\">import axios from \"axios\"\nimport { useEffect, useState } from \"react\"\n\n/*\nuseEffect\n  参数1：箭头函数, 在真正渲染 html 之前会执行它\n  参数2：\n    情况1：没有, 代表每次执行组件函数时, 都会执行副作用函数\n    情况2：[], 代表副作用函数只会执行一次\n    情况3：[依赖项], 依赖项变化时，副作用函数会执行\n*/\nexport default function P6({ id, age }: { id: number, age: number }) {\n\n  console.log(\'1.主要功能\')\n    \n  // useEffect(() =&gt; console.log(\'3.副作用功能\')) \n  // useEffect(() =&gt; console.log(\'3.副作用功能\'), []) \n  useEffect(() =&gt; console.log(\'3.副作用功能\'), [id]) \n\n  console.log(\'2.主要功能\')\n\n  return &lt;h3&gt;{id}&lt;/h3&gt;\n}\n</code></pre><p>用它改写 P5 案例</p><pre><code class=\"language-tsx\">import axios from \"axios\"\nimport { useEffect, useState } from \"react\"\n\nexport default function P6({ id, age }: { id: number, age: number }) {\n\n  const [student, setStudent] = useState({name:\'xx\'})\n\n  useEffect(()=&gt;{\n    async function updateStudent() {\n      const resp = await axios.get(`http://localhost:8080/api/students/${id}`)    \n      setStudent(resp.data.data)\n    }\n    updateStudent()\n  }, [id])\n\n  return &lt;h3&gt;{student.name}&lt;/h3&gt;\n}\n</code></pre><h4>useContext</h4><pre><code class=\"language-tsx\">import axios from \'axios\'\nimport { createContext, useContext, useEffect, useState } from \'react\'\nimport { R, Student } from \'../model/Student\'\n\n/*\n  createContext         创建上下文对象\n  useContext            读取上下文对象的值\n  &lt;上下文对象.Provider&gt;  修改上下文对象的值\n*/\nconst HiddenContext = createContext(false)\n\n// 给以下组件提供数据，控制年龄隐藏、显示\nexport default function P7() {\n  const [students, setStudents] = useState&lt;Student[]&gt;([])\n  const [hidden, setHidden] = useState(false)\n  useEffect(()=&gt;{\n    async function updateStudents() {\n      const resp = await axios.get&lt;R&lt;Student[]&gt;&gt;(\"http://localhost:8080/api/students\")\n      setStudents(resp.data.data)\n    }\n    updateStudents()\n  }, [])\n\n  function hideOrShow() {\n    // 参数：上一次状态值，旧值\n    // 返回值：要更新的新值\n    setHidden((old)=&gt;{\n      return !old\n    })\n  }\n  return &lt;HiddenContext.Provider value={hidden}&gt;\n    &lt;input type=\"button\" value={hidden?\'显示\':\'隐藏\'} onClick={hideOrShow}/&gt;\n    &lt;P71 students={students}&gt;&lt;/P71&gt;\n  &lt;/HiddenContext.Provider&gt;  \n}\n\n// 负责处理学生集合\nfunction P71({ students }: { students: Student[] }) {\n  const list = students.map(s=&gt;&lt;P72 student={s} key={s.id}&gt;&lt;/P72&gt;)\n  return &lt;&gt;{list}&lt;/&gt;\n}\n\n// 负责显示单个学生\nfunction P72({ student }: { student: Student }) {\n  const hidden = useContext(HiddenContext)\n  const jsx = !hidden && &lt;span&gt;{student.age}&lt;/span&gt;\n  return &lt;div&gt;{student.name} {jsx}&lt;/div&gt;\n}\n</code></pre><ul><li>如果组件分散在多个文件中，HiddenContext 应该 export 导出，用到它的组件 import 导入</li><li>React 中因修改触发的组件重新渲染，都应当是自上而下的</li><li>setHidden 方法如果更新的是对象，那么要返回一个新对象，而不是在旧对象上做修改</li></ul><h4>表单</h4><pre><code class=\"language-tsx\">import axios from \'axios\'\nimport React, { useState } from \'react\'\nimport \'../css/P8.css\'\n\nexport default function P8() {\n\n  const [student, setStudent] = useState({name:\'\', sex:\'男\', age:18})\n  const [message, setMessage] = useState(\'\')\n\n  const options = [\'男\', \'女\']\n  const jsx = options.map(e =&gt; &lt;option key={e}&gt;{e}&lt;/option&gt;)\n\n  // e 事件对象, e.target 事件源\n  function onChange(e : React.ChangeEvent&lt;HTMLInputElement|HTMLSelectElement&gt;) {\n    setStudent((old)=&gt;{\n      // 返回的新值，不能与旧值是同一个对象\n      return {...old, [e.target.name]:e.target.value}\n    })\n  }\n\n  async function onClick() {\n    const resp = await axios.post(\'http://localhost:8080/api/students\', student)\n    setMessage(resp.data.data)\n  }\n  \n  const messageJsx = message && &lt;div className=\'success\'&gt;{message}&lt;/div&gt;\n\n  return (\n    &lt;form&gt;\n      &lt;div&gt;\n        &lt;label&gt;姓名&lt;/label&gt;\n        &lt;input type=\"text\" value={student.name} onChange={onChange} name=\'name\'/&gt;\n      &lt;/div&gt;\n      &lt;div&gt;\n        &lt;label&gt;性别&lt;/label&gt;\n        &lt;select value={student.sex} onChange={onChange} name=\'sex\'&gt;\n          {jsx}\n        &lt;/select&gt;\n      &lt;/div&gt;\n      &lt;div&gt;\n        &lt;label&gt;年龄&lt;/label&gt;\n        &lt;input type=\"text\" value={student.age} onChange={onChange} name=\'age\' /&gt;\n      &lt;/div&gt;\n      &lt;div&gt;\n        &lt;input type=\'button\' value=\'新增\' onClick={onClick}/&gt;\n      &lt;/div&gt;\n      {messageJsx}\n    &lt;/form&gt;\n  )\n}\n</code></pre><h2>2. React 进阶</h2><h3>1) Ant Design</h3><p>react 组件库</p><ul><li>官网地址：https://ant.design/</li><li>镜像地址1：https://ant-design.gitee.io/</li><li>镜像地址2：https://ant-design.antgroup.com/</li></ul><h4>入门</h4><p>安装</p><pre><code class=\"language-cmd\">npm install antd\n</code></pre><ul><li>目前版本是 4.x</li></ul><p>引入样式，在 css 文件中加入</p><pre><code class=\"language-tsx\">@import \'~antd/dist/antd.css\';\n</code></pre><p>引入 antd 组件</p><pre><code class=\"language-tsx\">import { Button } from \"antd\";\n\nexport default function A1() {\n  return &lt;Button type=\'primary\'&gt;按钮&lt;/Button&gt;\n}\n</code></pre><h4>国际化</h4><p>试试其它组件</p><pre><code class=\"language-tsx\">import { Button, Modal } from \"antd\";\n\nexport default function A1() {\n  return &lt;Modal open={true} title=\'对话框\'&gt;内容&lt;/Modal&gt;\n}\n</code></pre><p>发现确定和取消按钮是英文的，这是因为 antd 支持多种语言，而默认语言是英文</p><p>要想改为中文，建议修改最外层的组件 index.tsx</p><pre><code class=\"language-tsx\">// ...\nimport { ConfigProvider } from \'antd\'\nimport zhCN from \'antd/es/locale/zh_CN\'\n\nroot.render(\n  &lt;ConfigProvider locale={zhCN}&gt;\n    &lt;A1&gt;&lt;/A1&gt;\n  &lt;/ConfigProvider&gt;\n)\n</code></pre><h4>表格</h4><pre><code class=\"language-tsx\">import { Table } from \'antd\'\nimport { ColumnsType } from \'antd/lib/table\'\nimport axios from \'axios\'\nimport { useEffect, useState } from \'react\'\nimport { R, Student } from \'../model/Student\'\n\nexport default function A3() {\n  const [students, setStudents] = useState&lt;Student[]&gt;([])\n  const [loading, setLoading] = useState(true)\n\n  useEffect(() =&gt; {\n    async function getStudents() {\n      const resp = await axios.get&lt;R&lt;Student[]&gt;&gt;(\n        \'http://localhost:8080/api/students\'\n      )\n      setStudents(resp.data.data)\n      setLoading(false)\n    }\n\n    getStudents()\n  }, [])\n\n  // title: 列标题  dataIndex: 要关联的属性名\n  const columns: ColumnsType&lt;Student&gt; = [\n    {\n      title: \'编号\',\n      dataIndex: \'id\',\n    },\n    {\n      title: \'姓名\',\n      dataIndex: \'name\',\n    },\n    {\n      title: \'性别\',\n      dataIndex: \'sex\',\n    },\n    {\n      title: \'年龄\',\n      dataIndex: \'age\',\n    },\n  ]\n\n  // columns: 列定义\n  // dataSource: 数据源，一般是数组包对象\n  // rowKey: 作为唯一标识的属性名\n  // loading: 显示加载图片\n  return (\n    &lt;Table\n      columns={columns}\n      dataSource={students}\n      rowKey=\'id\'\n      loading={loading}&gt;&lt;/Table&gt;\n  )\n}\n</code></pre><h4>客户端分页</h4><pre><code class=\"language-tsx\">import { Table } from \'antd\'\nimport { ColumnsType, TablePaginationConfig } from \'antd/lib/table\'\nimport axios from \'axios\'\nimport { useEffect, useState } from \'react\'\nimport { R, Student } from \'../model/Student\'\n\nexport default function A3() {\n  const [students, setStudents] = useState&lt;Student[]&gt;([])\n  const [loading, setLoading] = useState(true)\n  const [pagination, setPagination] = useState&lt;TablePaginationConfig&gt;(\n    {current:1, pageSize:5}\n  )\n\n  // 参数: 新的分页数据\n  function onTableChange(newPagination: TablePaginationConfig) {\n    setPagination(newPagination)\n  }\n\n  useEffect(() =&gt; {\n    async function getStudents() {\n      const resp = await axios.get&lt;R&lt;Student[]&gt;&gt;(\n        \'http://localhost:8080/api/students\'\n      )\n      setStudents(resp.data.data)\n      setLoading(false)\n    }\n\n    getStudents()\n  }, [])\n\n  // ... 省略\n\n  // pagination: 分页数据\n  // onChange: 当页号，页大小改变时触发\n  return (\n    &lt;Table\n      columns={columns}\n      dataSource={students}\n      rowKey=\'id\'\n      loading={loading}\n      pagination={pagination}\n      onChange={onTableChange}&gt;&lt;/Table&gt;\n  )\n}\n</code></pre><ul><li>本例还是查询所有数据，分页是客户端 Table 组件自己实现的</li></ul><h4>服务端分页</h4><pre><code class=\"language-tsx\">import { Table } from \'antd\'\nimport { ColumnsType, TablePaginationConfig } from \'antd/lib/table\'\nimport axios from \'axios\'\nimport { useEffect, useState } from \'react\'\nimport { PageResp, R, Student } from \'../model/Student\'\n\nexport default function A4() {\n  const [students, setStudents] = useState&lt;Student[]&gt;([])\n  const [loading, setLoading] = useState(true)\n  const [pagination, setPagination] = useState&lt;TablePaginationConfig&gt;({\n    current: 1,\n    pageSize: 5,\n  })\n\n  function onTableChange(newPagination: TablePaginationConfig) {\n    setPagination(newPagination)\n  }\n\n  useEffect(() =&gt; {\n    async function getStudents() {\n      // params 用来给请求添加 url 后的 ? 参数\n      const resp = await axios.get&lt;R&lt;PageResp&lt;Student&gt;&gt;&gt;(\n        \'http://localhost:8080/api/students/q\',\n        {\n          params: {\n            page: pagination.current,\n            size: pagination.pageSize,\n          },\n        }\n      )\n      // 返回结果中：list 代表当前页集合, total 代表总记录数\n      setStudents(resp.data.data.list)\n      setPagination((old) =&gt; {\n        return { ...old, total: resp.data.data.total }\n      })\n      setLoading(false)\n    }\n\n    getStudents()\n  }, [pagination.current, pagination.pageSize])\n  // useEffect 需要在依赖项( current 和 pageSize ) 改变时重新执行\n\n  const columns: ColumnsType&lt;Student&gt; = [\n    {\n      title: \'编号\',\n      dataIndex: \'id\',\n    },\n    {\n      title: \'姓名\',\n      dataIndex: \'name\',\n    },\n    {\n      title: \'性别\',\n      dataIndex: \'sex\',\n    },\n    {\n      title: \'年龄\',\n      dataIndex: \'age\',\n    },\n  ]\n\n  return (\n    &lt;Table\n      columns={columns}\n      dataSource={students}\n      rowKey=\'id\'\n      loading={loading}\n      pagination={pagination}\n      onChange={onTableChange}&gt;&lt;/Table&gt;\n  )\n}\n</code></pre><ul><li>本例需要服务端配合来实现分页，参见代码中新加的注释</li></ul><p>其中 PageResp 类型定义为</p><pre><code class=\"language-tsx\">export interface PageResp&lt;T&gt; {\n  list: T[],\n  total: number\n}\n</code></pre><h4>条件查询</h4><pre><code class=\"language-tsx\">import { Input, Select, Table } from \'antd\'\nimport { ColumnsType, TablePaginationConfig } from \'antd/lib/table\'\nimport axios from \'axios\'\nimport React, { useEffect, useState } from \'react\'\nimport { PageResp, R, Student, StudentQueryForm } from \'../model/Student\'\n\nconst { Option } = Select\n\nexport default function A5() {\n  const [students, setStudents] = useState&lt;Student[]&gt;([])\n  const [loading, setLoading] = useState(true)\n  const [pagination, setPagination] = useState&lt;TablePaginationConfig&gt;({\n    current: 1,\n    pageSize: 5,\n  })\n  // 代表查询条件的状态数据\n  const [form, setForm] = useState&lt;StudentQueryForm&gt;({})\n\n  function onTableChange(newPagination: TablePaginationConfig) {\n    setPagination(newPagination)\n  }\n\n  useEffect(() =&gt; {\n    async function getStudents() {\n      const resp = await axios.get&lt;R&lt;PageResp&lt;Student&gt;&gt;&gt;(\n        \'http://localhost:8080/api/students/q\',\n        {\n          params: {\n            page: pagination.current,\n            size: pagination.pageSize,\n            ...form // 补充查询参数\n          },\n        }\n      )\n      setStudents(resp.data.data.list)\n      setPagination((old) =&gt; {\n        return { ...old, total: resp.data.data.total }\n      })\n      setLoading(false)\n    }\n\n    getStudents()\n  }, [pagination.current, pagination.pageSize, form.name, form.sex, form.age])\n  // 依赖项除了分页条件外，新加了查询条件依赖\n    \n  const columns: ColumnsType&lt;Student&gt; = [\n    {\n      title: \'编号\',\n      dataIndex: \'id\',\n    },\n    {\n      title: \'姓名\',\n      dataIndex: \'name\',\n    },\n    {\n      title: \'性别\',\n      dataIndex: \'sex\',\n    },\n    {\n      title: \'年龄\',\n      dataIndex: \'age\',\n    },\n  ]\n\n  // name 条件改变时处理函数\n  function onNameChange(e: React.ChangeEvent&lt;HTMLInputElement&gt;) {\n    setForm((old)=&gt;{\n      return {...old, name: e.target.value}\n    })\n  }\n\n  // sex 条件改变时处理函数\n  function onSexChange(value: string) {\n    setForm((old)=&gt;{\n      return {...old, sex: value}\n    })\n  }\n\n  // age 条件改变时处理函数\n  function onAgeChange(value: string) {\n    setForm((old)=&gt;{\n      return {...old, age: value}\n    })\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;div&gt;\n        &lt;Input\n          style={{ width: 120 }}\n          placeholder=\'请输入姓名\'\n          value={form.name}\n          onChange={onNameChange}&gt;&lt;/Input&gt;\n        &lt;Select\n          style={{ width: 120 }}\n          placeholder=\'请选择性别\'\n          allowClear={true}\n          value={form.sex}\n          onChange={onSexChange}&gt;\n          &lt;Option value=\'男\'&gt;男&lt;/Option&gt;\n          &lt;Option value=\'女\'&gt;女&lt;/Option&gt;\n        &lt;/Select&gt;\n        &lt;Select\n          style={{ width: 120 }}\n          placeholder=\'请选择年龄\'\n          allowClear={true}\n          value={form.age}\n          onChange={onAgeChange}&gt;\n          &lt;Option value=\'1,19\'&gt;20以下&lt;/Option&gt;\n          &lt;Option value=\'20,29\'&gt;20左右&lt;/Option&gt;\n          &lt;Option value=\'30,39\'&gt;30左右&lt;/Option&gt;\n          &lt;Option value=\'40,120\'&gt;40以上&lt;/Option&gt;\n        &lt;/Select&gt;\n      &lt;/div&gt;\n      &lt;Table\n        columns={columns}\n        dataSource={students}\n        rowKey=\'id\'\n        loading={loading}\n        pagination={pagination}\n        onChange={onTableChange}&gt;&lt;/Table&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre><ul><li>建议 axios 发请求是用 params 而不要自己拼字符串，因为自己拼串需要去掉值为 undefined 的属性</li></ul><p>其中 StudentQueryForm 为</p><pre><code class=\"language-tsx\">export interface StudentQueryForm {\n  name?: string,\n  sex?: string,\n  age?: string,\n  [key: string]: any\n}\n</code></pre><h4>删除</h4><pre><code class=\"language-tsx\">import { Button, message, Popconfirm } from \'antd\'\nimport axios from \'axios\'\nimport { R } from \'../model/Student\'\n\nexport default function A6Delete({ id, onSuccess }: { id: number, onSuccess:()=&gt;void }) {\n  async function onConfirm() {\n    const resp = await axios.delete&lt;R&lt;string&gt;&gt;(\n      `http://localhost:8080/api/students/${id}`\n    )\n    message.success(resp.data.data)\n    // 改变 form 依赖项\n    onSuccess()\n  }\n  return (\n    &lt;Popconfirm title=\'确定要删除学生吗?\' onConfirm={onConfirm}&gt;\n      &lt;Button danger size=\'small\'&gt;\n        删除\n      &lt;/Button&gt;\n    &lt;/Popconfirm&gt;\n  )\n}\n</code></pre><p>使用删除组件</p><pre><code class=\"language-tsx\">import { Button, Input, Select, Space, Table } from \'antd\'\nimport { ColumnsType, TablePaginationConfig } from \'antd/lib/table\'\nimport axios from \'axios\'\nimport React, { useEffect, useState } from \'react\'\nimport { PageResp, R, Student, StudentQueryForm } from \'../model/Student\'\nimport A6Delete from \'./A6Delete\'\n\nconst { Option } = Select\n\nexport default function A6() {\n  // ... 省略\n\n  function onDeleteSuccess() {\n    setForm((old)=&gt;{\n      return {...old}\n    })\n  }\n    \n  const columns: ColumnsType&lt;Student&gt; = [\n    // ... 省略\n    {\n      title: \'操作\',\n      dataIndex: \'operation\',\n      // value: 属性值, student\n      render: (_, student)=&gt;{\n        return &lt;&gt;\n          &lt;Space&gt;\n            &lt;A6Delete id={student.id} onSuccess={onDeleteSuccess}&gt;&lt;/A6Delete&gt;\n            &lt;Button type=\'default\' size=\'small\'&gt;修改&lt;/Button&gt;\n          &lt;/Space&gt;\n        &lt;/&gt;\n      }\n    }\n  ]\n\n  // ... 省略\n}\n</code></pre><h4>修改</h4><pre><code class=\"language-tsx\">import { Form, Input, InputNumber, message, Modal, Radio } from \'antd\'\nimport { Rule } from \'antd/lib/form\'\nimport axios from \'axios\'\nimport { useEffect } from \'react\'\nimport { R, Student } from \'../model/Student\'\n\nexport default function A6Update({\n  open,\n  student,\n  onSuccess,\n  onCancel,\n}: {\n  open: boolean\n  student: Student\n  onSuccess?: () =&gt; void\n  onCancel?: () =&gt; void\n}) {\n  const { Item } = Form\n  const { Group } = Radio\n  const options = [\n    { label: \'男\', value: \'男\' },\n    { label: \'女\', value: \'女\' },\n  ]\n\n  const [form] = Form.useForm() // 代表了表单对象\n\n  const nameRules: Rule[] = [\n    { required: true, message: \'姓名必须\' },\n    { min: 2, type: \'string\', message: \'至少两个字符\' },\n  ]\n\n  const ageRules: Rule[] = [\n    { required: true, message: \'年龄必须\' },\n    { min: 1, type: \'number\', message: \'最小1岁\' },\n    { max: 120, type: \'number\', message: \'最大120岁\' },\n  ]\n\n  async function onOk() {\n    // 验证并获取表单数据\n    try {\n      const values = await form.validateFields()\n      console.log(values)\n      const resp = await axios.put&lt;R&lt;string&gt;&gt;(\n        `http://localhost:8080/api/students/${values.id}`,\n        values\n      )\n      message.success(resp.data.data)\n      onSuccess && onSuccess()\n    } catch (e) {\n      console.error(e)\n    }\n  }\n\n  useEffect(() =&gt; {\n    // 修改表单数据\n    form.setFieldsValue(student) // id, name, sex, age\n  }, [student])\n\n  return (\n    &lt;Modal\n      open={open}\n      title=\'修改学生\'\n      onOk={onOk}\n      onCancel={onCancel}\n      forceRender={true}&gt;\n      &lt;Form form={form}&gt;\n        &lt;Item label=\'编号\' name=\'id\'&gt;\n          &lt;Input readOnly&gt;&lt;/Input&gt;\n        &lt;/Item&gt;\n        &lt;Item label=\'姓名\' name=\'name\' rules={nameRules}&gt;\n          &lt;Input&gt;&lt;/Input&gt;\n        &lt;/Item&gt;\n        &lt;Item label=\'性别\' name=\'sex\'&gt;\n          &lt;Group\n            options={options}\n            optionType=\'button\'\n            buttonStyle=\'solid\'&gt;&lt;/Group&gt;\n        &lt;/Item&gt;\n        &lt;Item label=\'年龄\' name=\'age\' rules={ageRules}&gt;\n          &lt;InputNumber&gt;&lt;/InputNumber&gt;\n        &lt;/Item&gt;\n      &lt;/Form&gt;\n    &lt;/Modal&gt;\n  )\n}\n</code></pre><ul><li>forceRender 是避免因为使用 useForm 后，表单套在 Modal 中会出现的警告错误</li></ul><p>使用组件</p><pre><code class=\"language-tsx\">import { Button, Input, Select, Space, Table } from \'antd\'\nimport { ColumnsType, TablePaginationConfig } from \'antd/lib/table\'\nimport axios from \'axios\'\nimport React, { useEffect, useState } from \'react\'\nimport { PageResp, R, Student, StudentQueryForm } from \'../model/Student\'\nimport A6Delete from \'./A6Delete\'\nimport A6Update from \'./A6Update\'\n\nconst { Option } = Select\n\nexport default function A6() {\n  // ... 省略\n  const columns: ColumnsType&lt;Student&gt; = [\n    // ... 省略\n    {\n      title: \'操作\',\n      dataIndex: \'operation\',\n      // value: 属性值, student\n      render: (_, student) =&gt; {\n        return (\n          &lt;&gt;\n            &lt;Space&gt;\n              &lt;A6Delete id={student.id} onSuccess={onDeleteSuccess}&gt;&lt;/A6Delete&gt;\n              &lt;Button\n                type=\'default\'\n                size=\'small\'\n                onClick={() =&gt; {\n                  onUpdateClick(student)\n                }}&gt;\n                修改\n              &lt;/Button&gt;\n            &lt;/Space&gt;\n          &lt;/&gt;\n        )\n      },\n    },\n  ]\n\n  // -------------- 修改功能开始 -------------\n  function onUpdateClick(student: Student) {\n    setUpdateOpen(true)\n    setUpdateForm(student)\n  }\n\n  function onUpdateCancel() {\n    setUpdateOpen(false)\n  }\n\n  function onUpdateSuccess() {\n    setUpdateOpen(false)\n    setForm((old) =&gt; {\n      return { ...old }\n    })\n  }\n\n  const [updateOpen, setUpdateOpen] = useState(false)\n  const [updateForm, setUpdateForm] = useState&lt;Student&gt;({\n    id: 0,\n    name: \'\',\n    sex: \'男\',\n    age: 18,\n  })\n  // -------------- 修改功能结束 -------------\n\n  return (\n    &lt;div&gt;\n      &lt;A6Update\n        open={updateOpen}\n        student={updateForm}\n        onSuccess={onUpdateSuccess}\n        onCancel={onUpdateCancel}&gt;&lt;/A6Update&gt;\n      &lt;!-- ... 省略 --&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre><h4>新增</h4><pre><code class=\"language-tsx\">import { Form, Input, InputNumber, message, Modal, Radio } from \'antd\'\nimport { Rule } from \'antd/lib/form\'\nimport axios from \'axios\'\nimport { useEffect } from \'react\'\nimport { R, Student } from \'../model/Student\'\n\nexport default function A6Insert({\n  open,\n  student,\n  onSuccess,\n  onCancel,\n}: {\n  open: boolean\n  student: Student\n  onSuccess?: () =&gt; void\n  onCancel?: () =&gt; void\n}) {\n  const { Item } = Form\n  const { Group } = Radio\n  const options = [\n    { label: \'男\', value: \'男\' },\n    { label: \'女\', value: \'女\' },\n  ]\n\n  const [form] = Form.useForm() // 代表了表单对象\n\n  const nameRules: Rule[] = [\n    { required: true, message: \'姓名必须\' },\n    { min: 2, type: \'string\', message: \'至少两个字符\' },\n  ]\n\n  const ageRules: Rule[] = [\n    { required: true, message: \'年龄必须\' },\n    { min: 1, type: \'number\', message: \'最小1岁\' },\n    { max: 120, type: \'number\', message: \'最大120岁\' },\n  ]\n\n  async function onOk() {\n    // 验证并获取表单数据\n    try {\n      const values = await form.validateFields()\n      console.log(values)\n      const resp = await axios.post&lt;R&lt;string&gt;&gt;(\n        `http://localhost:8080/api/students`,\n        values\n      )\n      message.success(resp.data.data)\n      onSuccess && onSuccess()\n      form.resetFields() // 重置表单\n    } catch (e) {\n      console.error(e)\n    }\n  }\n\n  return (\n    &lt;Modal\n      open={open}\n      title=\'新增学生\'\n      onOk={onOk}\n      onCancel={onCancel}\n      forceRender={true}&gt;\n      &lt;Form form={form} initialValues={student}&gt;\n        &lt;Item label=\'姓名\' name=\'name\' rules={nameRules}&gt;\n          &lt;Input&gt;&lt;/Input&gt;\n        &lt;/Item&gt;\n        &lt;Item label=\'性别\' name=\'sex\'&gt;\n          &lt;Group\n            options={options}\n            optionType=\'button\'\n            buttonStyle=\'solid\'&gt;&lt;/Group&gt;\n        &lt;/Item&gt;\n        &lt;Item label=\'年龄\' name=\'age\' rules={ageRules}&gt;\n          &lt;InputNumber&gt;&lt;/InputNumber&gt;\n        &lt;/Item&gt;\n      &lt;/Form&gt;\n    &lt;/Modal&gt;\n  )\n}\n</code></pre><ul><li>initialValues 只会触发一次表单赋初值</li><li>form.resetFields() 会将表单重置为 initialValues 时的状态</li></ul><p>使用组件</p><pre><code class=\"language-tsx\">import { Button, Input, Select, Space, Table } from \'antd\'\nimport { ColumnsType, TablePaginationConfig } from \'antd/lib/table\'\nimport axios from \'axios\'\nimport React, { useEffect, useState } from \'react\'\nimport { PageResp, R, Student, StudentQueryForm } from \'../model/Student\'\nimport A6Delete from \'./A6Delete\'\nimport A6Insert from \'./A6Insert\'\nimport A6SelectedDelete from \'./A6SelectedDelete\'\nimport A6Update from \'./A6Update\'\n\nconst { Option } = Select\n\nexport default function A6() {\n  // ... 省略\n\n  // -------------- 新增功能开始 -------------\n  function onInsertClick() {\n    setInsertOpen(true)\n  }\n\n  function onInsertCancel() {\n    setInsertOpen(false)\n  }\n\n  function onInsertSuccess() {\n    setInsertOpen(false)\n    setForm((old) =&gt; {\n      return { ...old }\n    })\n  }\n\n  const [insertOpen, setInsertOpen] = useState(false)\n  const [insertForm, setInsertForm] = useState&lt;Student&gt;({\n    id: 0,\n    name: \'\',\n    sex: \'男\',\n    age: 18,\n  })\n  // -------------- 新增功能结束 -------------\n\n  \n  return (\n    &lt;div&gt;\n      &lt;A6Insert\n        open={insertOpen}\n        student={insertForm}\n        onSuccess={onInsertSuccess}\n        onCancel={onInsertCancel}&gt;&lt;/A6Insert&gt;\n      &lt;A6Update\n        open={updateOpen}\n        student={updateForm}\n        onSuccess={onUpdateSuccess}\n        onCancel={onUpdateCancel}&gt;&lt;/A6Update&gt;\n      &lt;div&gt;\n        &lt;Space&gt;\n          &lt;Input\n            style={{ width: 120 }}\n            placeholder=\'请输入姓名\'\n            value={form.name}\n            onChange={onNameChange}&gt;&lt;/Input&gt;\n          &lt;Select\n            style={{ width: 120 }}\n            placeholder=\'请选择性别\'\n            allowClear={true}\n            value={form.sex}\n            onChange={onSexChange}&gt;\n            &lt;Option value=\'男\'&gt;男&lt;/Option&gt;\n            &lt;Option value=\'女\'&gt;女&lt;/Option&gt;\n          &lt;/Select&gt;\n          &lt;Select\n            style={{ width: 120 }}\n            placeholder=\'请选择年龄\'\n            allowClear={true}\n            value={form.age}\n            onChange={onAgeChange}&gt;\n            &lt;Option value=\'1,19\'&gt;20以下&lt;/Option&gt;\n            &lt;Option value=\'20,29\'&gt;20左右&lt;/Option&gt;\n            &lt;Option value=\'30,39\'&gt;30左右&lt;/Option&gt;\n            &lt;Option value=\'40,120\'&gt;40以上&lt;/Option&gt;\n          &lt;/Select&gt;\n\n          &lt;Button type=\'primary\' onClick={onInsertClick}&gt;新增&lt;/Button&gt;\n        &lt;/Space&gt;\n      &lt;/div&gt;\n      &lt;Table\n        columns={columns}\n        dataSource={students}\n        rowKey=\'id\'\n        loading={loading}\n        pagination={pagination}\n        onChange={onTableChange}&gt;&lt;/Table&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre><h4>删除选中</h4><pre><code class=\"language-tsx\">import { Button, message, Popconfirm } from \"antd\";\nimport axios from \"axios\";\nimport React from \"react\";\nimport { R } from \"../model/Student\";\n\nexport default function A6DeleteSelected(\n  {ids, onSuccess}: {ids:React.Key[], onSuccess?:()=&gt;void} // Key[] 是 number 或 string 的数组\n){\n  const disabled = ids.length === 0\n  async function onConfirm() {\n    const resp = await axios.delete&lt;R&lt;string&gt;&gt;(\'http://localhost:8080/api/students\', {\n      data: ids\n    })\n    message.success(resp.data.data)\n    onSuccess && onSuccess()\n  }\n  return (\n    &lt;Popconfirm title=\'真的要删除选中的学生吗?\' onConfirm={onConfirm} disabled={disabled}&gt;\n      &lt;Button danger type=\'primary\' disabled={disabled}&gt;\n        删除选中\n      &lt;/Button&gt;\n    &lt;/Popconfirm&gt;\n  )\n}\n</code></pre><p>与 A6 结合</p><pre><code class=\"language-tsx\">import { Button, Input, Select, Space, Table } from \'antd\'\nimport { ColumnsType, TablePaginationConfig } from \'antd/lib/table\'\nimport axios from \'axios\'\nimport React, { useEffect, useState } from \'react\'\nimport { PageResp, R, Student, StudentQueryForm } from \'../model/Student\'\nimport A6Delete from \'./A6Delete\'\nimport A6Insert from \'./A6Insert\'\nimport A6SelectedDelete from \'./A6SelectedDelete\'\nimport A6Update from \'./A6Update\'\n\nconst { Option } = Select\n\nexport default function A6() {\n  // ... 省略\n\n  // -------------- 删除选中功能开始 -------------\n  const [ids, setIds] = useState&lt;React.Key[]&gt;([])\n  function onIdsChange(ids:React.Key[]) {\n    // console.log(ids)\n    setIds(ids)\n  }\n  function onDeleteSelectedSuccess() {\n    setForm((old)=&gt;{\n      return {...old}\n    })\n    setIds([])\n  }\n  // -------------- 删除选中功能结束 -------------\n  return (\n    &lt;div&gt;\n      &lt;A6Insert\n        open={insertOpen}\n        student={insertForm}\n        onSuccess={onInsertSuccess}\n        onCancel={onInsertCancel}&gt;&lt;/A6Insert&gt;\n      &lt;A6Update\n        open={updateOpen}\n        student={updateForm}\n        onSuccess={onUpdateSuccess}\n        onCancel={onUpdateCancel}&gt;&lt;/A6Update&gt;\n      &lt;div&gt;\n        &lt;Space&gt;\n          &lt;!-- ... 省略 --&gt;\n          &lt;A6SelectedDelete ids={ids} onSuccess={onDeleteSelectedSuccess}&gt;&lt;/A6SelectedDelete&gt;\n        &lt;/Space&gt;\n      &lt;/div&gt;\n      &lt;Table\n        rowSelection={{\n          selectedRowKeys: selectedKeys,\n          onChange: onSelectChange,\n        }}\n        columns={columns}\n        dataSource={students}\n        rowKey=\'id\'\n        loading={loading}\n        pagination={pagination}\n        onChange={onTableChange}&gt;&lt;/Table&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre><h4>useRequest</h4><p>安装</p><pre><code class=\"language-cmd\">npm install ahooks\n</code></pre><p>使用</p><pre><code class=\"language-tsx\">import { useRequest } from \'ahooks\'\nimport { Table } from \'antd\'\nimport { ColumnsType } from \'antd/lib/table\'\nimport axios from \'axios\'\nimport { Student, R } from \'../model/Student\'\n\nexport default function A3() {\n  function getStudents() {\n    return axios.get&lt;R&lt;Student[]&gt;&gt;(\'http://localhost:8080/api/students\')\n  }\n\n  const { loading, data } = useRequest(getStudents)  \n\n  const columns: ColumnsType&lt;Student&gt; = [\n    {\n      title: \'编号\',\n      dataIndex: \'id\',\n    },\n    {\n      title: \'姓名\',\n      dataIndex: \'name\',\n    },\n    {\n      title: \'性别\',\n      dataIndex: \'sex\',\n    },\n    {\n      title: \'年龄\',\n      dataIndex: \'age\',\n    },\n  ]\n\n  return (\n    &lt;Table\n      dataSource={data?.data.data}\n      columns={columns}\n      rowKey=\'id\'\n      loading={loading}\n      pagination={{ hideOnSinglePage: true }}&gt;&lt;/Table&gt;\n  )\n}\n</code></pre><h4>useAndtTable</h4><pre><code class=\"language-tsx\">import { useAntdTable } from \'ahooks\'\nimport { Table } from \'antd\'\nimport { ColumnsType } from \'antd/lib/table\'\nimport axios from \'axios\'\nimport { Student, R } from \'../model/Student\'\n\ninterface PageResp&lt;T&gt; {\n  total: number\n  list: T[]\n}\n\ninterface PageReq {\n  current: number\n  pageSize: number\n  sorter?: any\n  filter?: any\n}\n\nexport default function A3() {\n  async function getStudents({ current, pageSize }: PageReq) {\n    const resp = await axios.get&lt;R&lt;PageResp&lt;Student&gt;&gt;&gt;(\n      `http://localhost:8080/api/students/q?page=${current}&size=${pageSize}`\n    )\n    return resp.data.data\n  }\n\n  const { tableProps } = useAntdTable(getStudents, {\n    defaultParams: [{ current: 1, pageSize: 5 }],\n  })\n  console.log(tableProps)\n\n  const columns: ColumnsType&lt;Student&gt; = [\n    {\n      title: \'编号\',\n      dataIndex: \'id\',\n    },\n    {\n      title: \'姓名\',\n      dataIndex: \'name\',\n    },\n    {\n      title: \'性别\',\n      dataIndex: \'sex\',\n    },\n    {\n      title: \'年龄\',\n      dataIndex: \'age\',\n    },\n  ]\n\n  return &lt;Table {...tableProps} columns={columns} rowKey=\'id\'&gt;&lt;/Table&gt;\n}\n</code></pre><h3>2) MobX</h3><h4>介绍</h4><p>需求，组件0 改变了数据，其它组件也想获得改变后的数据，如图所示</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20221025104453534.png\" alt=\"image-20221025104453534\" data-href=\"\" style=\"\"/></p><p>这种多个组件之间要共享状态数据，useState 就不够用了，useContext 也不好用了</p><p>能够和 react 配合使用的状态管理库有</p><ul><li>MobX</li><li>Redux</li></ul><p>其中 Redux API <strong>非常</strong>难以使用，这里选择了更加符合<strong>人类习惯</strong>的 MobX，它虽然采用了面向对象的语法，但也能和函数式的代码很好地结合</p><h4>文档</h4><ul><li><a href=\"https://cn.mobx.js.org/\" target=\"\">MobX 中文文档</a></li><li><a href=\"https://mobx.js.org/README.html\" target=\"\">MobX 官方文档</a></li></ul><h4>安装</h4><pre><code >npm install mobx mobx-react-lite\n</code></pre><ul><li>mobx 目前版本是 6.x</li><li>mobx-react-lite 目前版本是 3.x</li></ul><h4>名词</h4><p><img src=\"https://mobx.js.org/assets/action-state-view.png\" alt=\"Action, State, View\" data-href=\"\" style=\"\"/></p><ul><li>Actions 用来修改状态数据的方法</li><li>Observable state 状态数据，可观察</li><li>Derived values 派生值，也叫 Computed values 计算值，会根据状态数据的改变而改变，具有缓存功能</li><li>Reactions 状态数据发生变化后要执行的操作，如 react 函数组件被重新渲染</li></ul><h4>使用</h4><p>首先，定义一个在函数之外存储状态数据的 store，它与 useState 不同：</p><ul><li>useState 里的状态数据是存储在每个组件节点上，不同组件之间没法共享</li><li>而 MobX 的 store 就是一个普通 js 对象，只要保证多个组件都访问此对象即可</li></ul><pre><code class=\"language-tsx\">import axios from \'axios\'\nimport { makeAutoObservable } from \'mobx\'\nimport { R, Student } from \'../model/Student\'\n\nclass StudentStore {\n  student: Student = { name: \'\' }\n\n  constructor() {\n    makeAutoObservable(this)\n  }\n\n  async fetch(id: number) {\n    const resp = await axios.get&lt;R&lt;Student&gt;&gt;(\n      `http://localhost:8080/api/students/${id}`\n    )\n    runInAction(() =&gt; {\n      this.student = resp.data.data\n    })\n  }\n    \n  get print() {\n    const first = this.student.name.charAt(0)\n    if (this.student.sex === \'男\') {\n      return first.concat(\'大侠\')\n    } else if (this.student.sex === \'女\') {\n      return first.concat(\'女侠\')\n    } else {\n      return \'\'\n    }\n  } \n}\n\nexport default new StudentStore()\n</code></pre><p>其中 makeAutoObservable 会</p><ul><li>将对象的属性 student 变成 Observable state，即状态数据</li><li>将对象的方法 fetch 变成 Action，即修改数据的方法</li><li>将 get 方法变成 Computed values</li></ul><p>在异步操作里为状态属性赋值，需要放在 runInAction 里，否则会有警告错误</p><p>使用 store，所有使用 store 的组件，为了感知状态数据的变化，需要用 observer 包装，对应着图中 reactions</p><pre><code class=\"language-tsx\">import Search from \'antd/lib/input/Search\'\nimport { observer } from \'mobx-react-lite\'\nimport studentStore from \'../store/StudentStore\'\nimport A71 from \'./A71\'\nimport Test2 from \'./Test2\'\n\nconst A7 = () =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;Search\n        placeholder=\'input search text\'\n        onSearch={(v) =&gt; studentStore.fetch(Number(v))}\n        style={{ width: 100 }}\n      /&gt;\n      &lt;h3&gt;组件0 {studentStore.student.name}&lt;/h3&gt;\n      &lt;A71&gt;&lt;/A71&gt;\n      &lt;A72&gt;&lt;/A72&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default observer(A7)\n</code></pre><p>其它组件</p><pre><code class=\"language-tsx\">import { observer } from \'mobx-react-lite\'\nimport studentStore from \'../store/StudentStore\'\n\nconst A71 = () =&gt;{\n  return &lt;h3 style={{color:\'red\'}}&gt;组件1 {studentStore.student.name}&lt;/h3&gt;\n}\n\nexport default observer(A71)\n</code></pre><pre><code class=\"language-tsx\">import { observer } from \'mobx-react-lite\'\nimport studentStore from \'../store/StudentStore\'\n\nconst A72 = () =&gt;{\n  return &lt;h3 style={{color:\'red\'}}&gt;组件1 {studentStore.student.name}&lt;/h3&gt;\n}\n\nexport default observer(A72)\n</code></pre><h4>注解方式</h4><pre><code class=\"language-java\">import { R, Student } from \"../model/Student\";\nimport { action, computed, makeAutoObservable, makeObservable, observable, runInAction } from \'mobx\'\nimport axios from \"axios\";\n\nclass StudentStore {\n  // 属性 - 对应状态数据 observable state\n  @observable student: Student = { id: 0, name: \'\' }\n  // 方法 - 对应 action 方法\n  @action setName(name: string) {\n    this.student.name = name\n  }\n  @action async fetch(id: number) {\n    const resp = await axios.get&lt;R&lt;Student&gt;&gt;(`http://localhost:8080/api/students/${id}`)\n    runInAction(() =&gt; {\n      this.student = resp.data.data\n    })\n  }\n  // get 方法 - 对应 derived value\n  @computed get displayName() {\n    const first = this.student.name.charAt(0)\n    if (this.student.sex === \'男\') {\n      return first + \'大侠\'\n    } else if (this.student.sex === \'女\') {\n      return first + \'女侠\'\n    } else {\n      return \'\'\n    }\n  }\n  // 构造器\n  constructor() {\n    makeObservable(this)\n  }\n}\n\nexport default new StudentStore()\n</code></pre><p>需要在 tsconifg.json 中加入配置</p><pre><code class=\"language-json\">{\n  \"compilerOptions\": {\n    // ...\n    \"experimentalDecorators\": true\n  }\n}\n</code></pre><h3>3) React Router</h3><h4>安装</h4><pre><code class=\"language-cmd\">npm install react-router-dom\n</code></pre><ul><li>目前版本是 6.x</li></ul><h4>使用</h4><p>新建文件 src/router/router.tsx</p><pre><code class=\"language-tsx\">import { lazy } from \'react\'\nimport { Navigate, RouteObject, useRoutes } from \'react-router-dom\'\n\nexport function load(name: string) {\n  const Page = lazy(() =&gt; import(`../pages/${name}`))\n  return &lt;Page&gt;&lt;/Page&gt;\n}\n\nconst staticRoutes: RouteObject[] = [\n  { path: \'/login\', element: load(\'A8Login\') },\n  {\n    path: \'/\',\n    element: load(\'A8Main\'),\n    children: [\n      { path: \'student\', element: load(\'A8MainStudent\') },\n      { path: \'teacher\', element: load(\'A8MainTeacher\') },\n      { path: \'user\', element: load(\'A8MainUser\') }\n    ],\n  },\n  { path: \'/404\', element: load(\'A8Notfound\') },\n  { path: \'/*\', element: &lt;Navigate to={\'/404\'}&gt;&lt;/Navigate&gt; },\n]\n\nexport default function Router() {\n  return useRoutes(staticRoutes)\n}\n</code></pre><p>index.tsx 修改为</p><pre><code class=\"language-tsx\">import ReactDOM from \'react-dom/client\';\nimport \'./index.css\';\nimport { ConfigProvider } from \'antd\';\nimport zhCN from \'antd/es/locale/zh_CN\'\n\nimport { BrowserRouter } from \'react-router-dom\';\nimport Router from \'./router/router\';\n\nconst root = ReactDOM.createRoot(\n  document.getElementById(\'root\') as HTMLElement\n);\n\nroot.render(\n  &lt;ConfigProvider locale={zhCN}&gt;\n    &lt;BrowserRouter&gt;\n      &lt;Router&gt;&lt;/Router&gt;\n    &lt;/BrowserRouter&gt;\n  &lt;/ConfigProvider&gt;  \n)\n</code></pre><p>A8Main 的代码</p><pre><code class=\"language-tsx\">import { Layout } from \"antd\";\nimport { Link, Outlet } from \"react-router-dom\";\n\nexport default function A8Main () {  \n  return &lt;Layout&gt;\n    &lt;Layout.Header&gt;头部导航&lt;/Layout.Header&gt;\n    &lt;Layout&gt;\n      &lt;Layout.Sider&gt;侧边导航\n        &lt;Link to=\'/student\'&gt;学生管理&lt;/Link&gt;\n        &lt;Link to=\'/teacher\'&gt;教师管理&lt;/Link&gt;\n        &lt;Link to=\'/user\'&gt;用户管理&lt;/Link&gt;\n      &lt;/Layout.Sider&gt;\n      &lt;Layout.Content&gt;\n        &lt;Outlet&gt;&lt;/Outlet&gt;\n      &lt;/Layout.Content&gt;\n    &lt;/Layout&gt;\n  &lt;/Layout&gt;\n}\n</code></pre><ol><li>Navigate 的作用是重定向</li><li>load 方法的作用是懒加载组件，更重要的是根据字符串找到真正的组件，这是动态路由所需要的</li><li>children 来进行嵌套路由映射，嵌套路由在跳转后，并不是替换整个页面，而是用新页面替换父页面的 Outlet 部分</li></ol><h4>动态路由</h4><p>路由分成两部分：</p><ul><li>静态路由，固定的部分，如主页、404、login 这几个页面</li><li>动态路由，变化的部分，经常是主页内的嵌套路由，比如 Student、Teacher 这些</li></ul><p>动态路由应该是根据用户登录后，根据角色的不同，从后端服务获取，因为这些数据是变化的，所以用 mobx 来管理</p><pre><code class=\"language-tsx\">import axios from \'axios\'\nimport { makeAutoObservable, runInAction } from \'mobx\'\nimport { Navigate, RouteObject } from \'react-router-dom\'\nimport { MenuAndRoute, R, Route } from \'../model/Student\'\nimport { load } from \'../router/MyRouter\'\n\nclass RoutesStore {\n  dynamicRoutes: Route[]\n\n  async fetch(username: string) {\n    const resp = await axios.get&lt;R&lt;MenuAndRoute&gt;&gt;(\n      `http://localhost:8080/api/menu/${username}`\n    )\n    runInAction(() =&gt; {\n      this.dynamicRoutes = resp.data.data.routeList\n      localStorage.setItem(\'dynamicRoutes\', JSON.stringify(this.dynamicRoutes))\n    })\n  }\n\n  constructor() {\n    makeAutoObservable(this)\n    const r = localStorage.getItem(\'dynamicRoutes\')\n    this.dynamicRoutes = r ? JSON.parse(r) : []\n  }\n\n  reset() {\n    this.dynamicRoutes = []\n    localStorage.removeItem(\'dynamicRoutes\')\n  }\n\n  get routes() {\n    const staticRoutes: RouteObject[] = [\n      { path: \'/login\', element: load(\'A8Login\') },\n      { path: \'/\', element: load(\'A8Main\') },\n      { path: \'/404\', element: load(\'A8Notfound\') },\n      { path: \'/*\', element: &lt;Navigate to={\'/404\'}&gt;&lt;/Navigate&gt; },\n    ]\n    const main = staticRoutes[1]\n\n    main.children = this.dynamicRoutes.map((r) =&gt; {\n      console.log(r.path, r.element)\n      return {\n        path: r.path,\n        element: load(r.element),\n      }\n    })\n    return staticRoutes\n  }\n}\n\nexport default new RoutesStore()\n</code></pre><ul><li>其中用 localStorage 进行了数据的持久化，避免刷新后丢失数据</li></ul><p>MyRouter 文件修改为</p><pre><code class=\"language-tsx\">import { observer } from \'mobx-react-lite\'\nimport { lazy } from \'react\'\nimport { Navigate, RouteObject, useRoutes } from \'react-router-dom\'\nimport RoutesStore from \'../store/RoutesStore\'\n\n// 把字符串组件 =&gt; 组件标签\nexport function load(name: string) {\n  // A8Login\n  const Page = lazy(() =&gt; import(`../pages/${name}`))\n  return &lt;Page&gt;&lt;/Page&gt;\n}\n\n// 路由对象\nfunction MyRouter() {  \n  const router = useRoutes(RoutesStore.routes)\n  return router\n}\n\nexport default observer(MyRouter)\n</code></pre><p>注意导入 router 对象时，用 observer 做了包装，这样能够在 store 发生变化时重建 router 对象</p><h4>动态菜单</h4><p>图标要独立安装依赖</p><pre><code >npm install @ant-design/icons\n</code></pre><p>图标组件，用来将<strong>字符串图标</strong>转换为<strong>标签图标</strong></p><pre><code class=\"language-tsx\">import * as icons from \'@ant-design/icons\'\n\ninterface Module {\n  [p: string]: any\n}\n\nconst all: Module = icons\n\nexport default function Icon({ name }: { name: string }) {\n  const Icon = all[name]\n  return &lt;Icon&gt;&lt;/Icon&gt;\n}\n</code></pre><p>修改 RoutesStore.tsx</p><pre><code class=\"language-tsx\">import axios from \'axios\'\nimport { makeAutoObservable, runInAction } from \'mobx\'\nimport { Link, Navigate, RouteObject } from \'react-router-dom\'\nimport { Menu, MenuAndRoute, R, Route } from \'../model/Student\'\nimport { load } from \'../router/MyRouter\'\nimport Icon from \'./Icon\'\n\nfunction convertMenu(m: Menu): any {\n  const Label = m.routePath ? &lt;Link to={m.routePath}&gt;{m.label}&lt;/Link&gt; : m.label\n  return {\n    label: Label,\n    key: m.key,\n    icon: &lt;Icon name={m.icon}&gt;&lt;/Icon&gt;,\n    children: m.children && m.children.map(convertMenu)\n  }\n}\n\nclass RoutesStore {\n  // 动态部分\n  dynamicRoutes: Route[] = []\n  dynamicMenus: Menu[] = []\n\n  async fetch(username: string) {\n    const resp = await axios.get&lt;R&lt;MenuAndRoute&gt;&gt;(\n      `http://localhost:8080/api/menu/${username}`\n    )\n    runInAction(() =&gt; {\n      this.dynamicRoutes = resp.data.data.routeList\n      localStorage.setItem(\'dynamicRoutes\', JSON.stringify(this.dynamicRoutes))\n\n      this.dynamicMenus = resp.data.data.menuTree\n      localStorage.setItem(\'dynamicMenus\', JSON.stringify(this.dynamicMenus))\n    })\n  }\n\n  get menus() {\n    return this.dynamicMenus.map(convertMenu)\n  }\n\n  get routes() {\n    const staticRoutes: RouteObject[] = [\n      { path: \'/login\', element: load(\'A8Login\') },\n      { path: \'/\', element: load(\'A8Main\'), children: [] },\n      { path: \'/404\', element: load(\'A8Notfound\') },\n      { path: \'/*\', element: &lt;Navigate to={\'/404\'}&gt;&lt;/Navigate&gt; },\n    ]\n    staticRoutes[1].children = this.dynamicRoutes.map((r) =&gt; {\n      return {\n        path: r.path,\n        element: load(r.element),\n      }\n    })\n    return staticRoutes\n  }\n\n  constructor() {\n    makeAutoObservable(this)\n    const json = localStorage.getItem(\'dynamicRoutes\')\n    this.dynamicRoutes = json ? JSON.parse(json) : []\n\n    const json2 = localStorage.getItem(\'dynamicMenus\')\n    this.dynamicMenus = json2 ? JSON.parse(json2) : []\n  }\n\n  reset() {\n    localStorage.removeItem(\'dynamicRoutes\')\n    this.dynamicRoutes = []\n    localStorage.removeItem(\'dynamicMenus\')\n    this.dynamicMenus = []\n  }\n}\n\nexport default new RoutesStore()\n</code></pre><p>其中 convertMenu 为核心方法，负责将服务器返回的 Menu 转换成 antd Menu 组件需要的 Menu</p><p>使用</p><pre><code class=\"language-tsx\">&lt;Menu items={RoutesStore.menus} mode=\'inline\' theme=\"dark\"&gt;&lt;/Menu&gt;\n</code></pre><p>跳转若发生错误，可能是因为组件懒加载引起的，需要用 Suspense 解决</p><pre><code class=\"language-tsx\">root.render(\n  &lt;ConfigProvider locale={zhCN}&gt;\n    &lt;BrowserRouter&gt;\n      &lt;Suspense fallback={&lt;h3&gt;加载中...&lt;/h3&gt;}&gt;\n        &lt;MyRouter&gt;&lt;/MyRouter&gt;\n      &lt;/Suspense&gt;\n    &lt;/BrowserRouter&gt;\n  &lt;/ConfigProvider&gt;\n)\n</code></pre><h4>登录</h4><pre><code class=\"language-tsx\">import { ItemType } from \'antd/lib/menu/hooks/useItems\'\nimport axios from \'axios\'\nimport { makeAutoObservable, runInAction } from \'mobx\'\nimport { Link, Navigate, RouteObject } from \'react-router-dom\'\nimport { LoginReq, LoginResp, Menu, MenuAndRoute, R, Route } from \'../model/Student\'\nimport { load } from \'../router/MyRouter\'\nimport Icon from \'./Icon\'\n\nfunction convertMenu(m: Menu): ItemType {\n  const Label = m.routePath? &lt;Link to={m.routePath}&gt;{m.label}&lt;/Link&gt; : m.label\n  return {\n    key: m.key,\n    label: Label,\n    icon: &lt;Icon name={m.icon}&gt;&lt;/Icon&gt;, \n    children: m.children && m.children.map(convertMenu)\n  }\n}\n\nclass RoutesStore {\n  // 动态部分\n  dynamicRoutes: Route[] = []\n  dynamicMenus: Menu[] = []\n\n  token: string = \'\'\n  state: string = \'pending\' // 取值 pending done error\n  message: string = \'\' // 取值: 1. 空串 正常  2. 非空串 错误消息\n\n  async login(loginReq: LoginReq) {\n    this.state = \'pending\'\n    this.message = \'\'\n    const resp1 = await axios.post&lt;R&lt;LoginResp&gt;&gt;(\n      \'http://localhost:8080/api/loginJwt\',\n      loginReq\n    )\n    if(resp1.data.code === 999) {\n      const resp2 = await axios.get&lt;R&lt;MenuAndRoute&gt;&gt;(\n        `http://localhost:8080/api/menu/${loginReq.username}`\n      )\n      runInAction(()=&gt;{\n        this.token = resp1.data.data.token\n        localStorage.setItem(\'token\', this.token)\n\n        this.dynamicRoutes = resp2.data.data.routeList\n        localStorage.setItem(\'dynamicRoutes\', JSON.stringify(this.dynamicRoutes))\n\n        this.dynamicMenus = resp2.data.data.menuTree\n        localStorage.setItem(\'dynamicMenus\', JSON.stringify(this.dynamicMenus))\n\n        this.state = \'done\'\n      })\n    } else {\n      runInAction(()=&gt;{\n        this.message = resp1.data.message || \'未知错误\'\n        this.state = \'error\'\n      })\n    }\n  }\n\n  async fetch(username: string) {\n    const resp = await axios.get&lt;R&lt;MenuAndRoute&gt;&gt;(\n      `http://localhost:8080/api/menu/${username}`\n    )\n    runInAction(() =&gt; {\n      this.dynamicRoutes = resp.data.data.routeList\n      localStorage.setItem(\'dynamicRoutes\', JSON.stringify(this.dynamicRoutes))\n\n      this.dynamicMenus = resp.data.data.menuTree\n      localStorage.setItem(\'dynamicMenus\', JSON.stringify(this.dynamicMenus))\n    })\n  }\n    \n  get routes() {\n    const staticRoutes: RouteObject[] = [\n      { path: \'/login\', element: load(\'A8Login\') },\n      { path: \'/\', element: load(\'A8Main\'), children: [] },\n      { path: \'/404\', element: load(\'A8Notfound\') },\n      { path: \'/*\', element: &lt;Navigate to={\'/404\'}&gt;&lt;/Navigate&gt; },\n    ]\n    staticRoutes[1].children = this.dynamicRoutes.map((r) =&gt; {\n      return {\n        path: r.path,\n        element: load(r.element),\n      }\n    })\n    return staticRoutes\n  }\n\n  get menus() {\n    return this.dynamicMenus.map(convertMenu)\n  }\n\n  constructor() {\n    makeAutoObservable(this)\n    const json = localStorage.getItem(\'dynamicRoutes\')\n    this.dynamicRoutes = json ? JSON.parse(json) : []\n\n    const json1 = localStorage.getItem(\'dynamicMenus\')\n    this.dynamicMenus = json1 ? JSON.parse(json1) : []\n\n    const token = localStorage.getItem(\'token\')\n    this.token = token ?? \'\'\n      \n    this.message = \'\'\n    this.state = \'pending\'  \n  }\n\n  reset() {\n    localStorage.removeItem(\'dynamicRoutes\')\n    this.dynamicRoutes = []\n\n    localStorage.removeItem(\'dynamicMenus\')\n    this.dynamicMenus = []\n\n    localStorage.removeItem(\'token\')\n    this.token = \'\'\n      \n    this.message = \'\'\n    this.state = \'pending\'    \n  }\n}\n\nexport default new RoutesStore()\n</code></pre><p>登录页面</p><pre><code class=\"language-tsx\">function A8Login() {\n  function onFinish(values: { username: string; password: string }) {\n    RoutesStore.login(values)\n  }\n\n  const nav = useNavigate()\n  useEffect(() =&gt; {\n    if (RoutesStore.state === \'done\') {\n      nav(\'/\')\n    } else if (RoutesStore.state === \'error\') {\n      message.error(RoutesStore.message)\n    }\n  }, [RoutesStore.state])\n\n  // ...\n}\n\nexport default observer(A8Login)\n</code></pre><ul><li>用 useNavigate() 返回的函数跳转的代码不能包含在函数式组件的主逻辑中，只能放在</li></ul><h4>注销、欢迎词、登录检查</h4><p>Store 中增加 get username 方法</p><pre><code class=\"language-tsx\">class RoutesStore {\n  // ...\n\n  // eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhZG1pbiJ9.-l-MjMPGJVOf3zoIJgoqpV3LWoqvCCgcaI1ga86ismU\n  get username() {\n    if(this.token.length === 0) {\n      return \'\'\n    }\n    const json = atob(this.token.split(\'.\')[1])\n    return JSON.parse(json).sub\n  }\n    \n  // ...\n}\n</code></pre><ul><li>token 的前两部分都可以解码出来，其中 [1] 就是 token 的内容部分</li></ul><p>主页组件改为</p><pre><code class=\"language-tsx\">import { Button, Layout, Menu } from \'antd\'\nimport { observer } from \'mobx-react-lite\'\nimport { useEffect } from \'react\'\nimport { Navigate, Outlet, useNavigate } from \'react-router-dom\'\nimport RoutesStore from \'../store/RoutesStore\'\n\nfunction A8Main() {\n  const nav = useNavigate()\n\n  function onClick() {\n    RoutesStore.reset()\n    nav(\'/login\')\n  }\n\n  /* useEffect(()=&gt;{\n    if(RoutesStore.username === \'\') {\n      nav(\'/login\')\n    }\n  }, []) */\n\n  if(RoutesStore.username === \'\') {\n    return &lt;Navigate to=\'/login\'&gt;&lt;/Navigate&gt;\n  }\n\n  return (\n    &lt;Layout&gt;\n      &lt;Layout.Header&gt;\n        &lt;span&gt;欢迎您【{RoutesStore.username}】&lt;/span&gt;\n        &lt;Button size=\'small\' onClick={onClick}&gt;注销&lt;/Button&gt;\n      &lt;/Layout.Header&gt;\n      &lt;Layout&gt;\n        &lt;Layout.Sider&gt;\n          &lt;Menu items={RoutesStore.menus} theme=\'dark\' mode=\'inline\'&gt;&lt;/Menu&gt;\n        &lt;/Layout.Sider&gt;\n        &lt;Layout.Content&gt;\n          &lt;Outlet&gt;&lt;/Outlet&gt;\n        &lt;/Layout.Content&gt;\n      &lt;/Layout&gt;\n    &lt;/Layout&gt;\n  )\n}\n\nexport default observer(A8Main)\n</code></pre><ul><li>这个例子中推荐用 Navigate 来完成跳转</li><li>/student，/teacher 等路由不需要检查，因为登录成功后才有</li></ul><h2>附录</h2><h3>代码片段</h3><p>ctrl+shift+p 输入关键词<strong>代码</strong></p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20221026102533928.png\" alt=\"image-20221026102533928\" data-href=\"\" style=\"\"/></p><p>定义 fun.code-snippets</p><pre><code class=\"language-json\">{\n    \"函数组件\": {\n        \"scope\": \"javascript,typescript,typescriptreact\",\n        \"prefix\": \"fun\",\n        \"body\": [\n            \"export default function ${1:函数名} () {\",\n      \"  $0\",      \n      \"  return &lt;&gt;&lt;/&gt;\",\n            \"}\"\n        ],\n        \"description\": \"快速生成react函数式组件\"\n    }\n}\n</code></pre><p>定义 ofun.code-snippets</p><pre><code class=\"language-json\">{\n    \"mobx函数组件\": {\n        \"scope\": \"javascript,typescript,typescriptreact\",\n        \"prefix\": \"ofun\",\n        \"body\": [\n      \"import { observer } from \\\"mobx-react-lite\\\"\",\n      \"\",\n            \"function ${1:函数名} () {\",\n      \"  $0\",      \n      \"  return &lt;&gt;&lt;/&gt;\",\n            \"}\",\n      \"export default observer($1)\",\n        ],\n        \"description\": \"快速生成mobx react函数式组件\"\n    }\n}\n</code></pre><p>这样可以在 tsx 中用快捷键 <code>fun</code> 以及 <code>ofun</code> 创建相应的代码片段</p>', '林志杰', '1626518508932235265', 1, 2, 1, '2023-05-17 19:31:34.541', '2023-05-31 00:00:00.049');
INSERT INTO `blog` VALUES ('24fdc59b4935820aa0e453876db37ed0', 'mybatis', 'http://rt6vvz8xh.bkt.clouddn.com/blogFile/1629495477589856258/b219ebc4b74543a9e3e0ca386c1dac8eb8011464.webp', '“博客”当然是个大家都陌生的名词,博客的英文名词就是“Blog或Weblog”(指人时对应于Blogger),是一个典型的网络新事物,查阅最新的英文词典也不可能查到', '啥计划的大啊啊所多', '林志杰', '1626518508932235265', 1, 1, 0, '2023-03-20 05:30:54.485', '2023-05-17 00:00:00.176');
INSERT INTO `blog` VALUES ('2b32321b0ad1cb9c34690de699c74ea8', 'mysql', 'http://rt6vvz8xh.bkt.clouddn.com/blogFile/1629495477589856258/b219ebc4b74543a9e3e0ca386c1dac8eb8011464.webp', '“博客”当然是个大家都陌生的名词,博客的英文名词就是“Blog或Weblog”(指人时对应于Blogger),是一个典型的网络新事物,查阅最新的英文词典也不可能查到', '啥计划的大啊啊所多', '林志杰', '1626518508932235265', 0, 1, 0, '2023-03-20 05:30:47.446', '2023-05-12 00:00:00.815');
INSERT INTO `blog` VALUES ('3bcebd0999e60a429322b025b8ced6db', '博客测试', 'http://rt6vvz8xh.bkt.clouddn.com/blogFile/1629495477589856258/faf6f013-ee0a-4246-8632-e5258a3da957.png', '功能测试', '<table style=\"width: auto;\"><tbody><tr><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">功能名称</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">测试目的</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">测试步骤</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">预期结果</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">实际结果</th></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">登录功能</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">测试登录流程是否正常</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">1. 打开登录页面；2. 输入正确的用户名和密码；3. 点击登录按钮；</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">成功登录，跳转到后台管理首页</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">登录成功</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">文章管理</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">测试文章管理功能</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">1. 进入文章管理页面；2. 点击新增文章按钮；3. 输入文章标题和内容；4. 点击保存按钮；</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">成功新增一篇文章，文章列表中显示新增文章</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">新增文章成功</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">文章编辑</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">测试文章编辑功能</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">1. 进入文章列表；2. 点击某篇文章的编辑按钮；3. 修改文章标题和内容；4. 点击保存按钮；</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">修改成功，文章列表显示修改后的内容</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">修改成功</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">文章删除</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">测试文章删除功能</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">1. 进入文章列表；2. 点击某篇文章的删除按钮；3. 确认删除提示框；4. 点击确定按钮；</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">文章删除成功，文章列表中删除该文章</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">删除成功</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">标签管理</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">测试标签管理功能</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">1. 进入标签管理页面；2. 点击新增标签按钮；3. 输入标签名称；4. 点击保存按钮；</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">成功新增一个标签，标签列表中显示该标签</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">新增标签成功</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">标签编辑</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">测试标签编辑功能</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">1. 进入标签列表；2. 点击某个标签的编辑按钮；3. 修改标签名称；4. 点击保存按钮；</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">修改成功，标签列表中显示修改后的标签名称</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">修改成功</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">标签删除</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">测试标签删除功能</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">1. 进入标签列表；2. 点击某个标签的删除按钮；3. 确认删除提示框；4. 点击确定按钮；</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">标签删除成功，标签列表中删除该标签</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">删除成功</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">用户管理</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">测试用户管理功能</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">1. 进入用户管理页面；2. 点击新增用户按钮；3. 输入用户信息；4. 点击保存按钮；</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">成功新增一个用户，用户列表中显示该用户</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">新增用户成功</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">用户编辑</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">测试用户编辑功能</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">1. 进入用户列表；2. 点击某个用户的编辑按钮；3. 修改用户信息；4. 点击保存按钮；</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">修改成功，用户列表中显示修改后的用户信息</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">修改成功</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">用户删除</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">测试用户删除功能</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">1. 进入用户列表；2. 点击某个用户的删除按钮；3. 确认删除提示框；4. 点击确定按钮；</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">用户删除成功，用户列表中删除该用户</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">删除成功</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">登出功能</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">测试登出流程是否正常</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">1. 点击登出按钮；</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">成功退出登录，跳转到登录页面</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">登出成功</td></tr></tbody></table><p><br></p>', '林志杰', '1626518508932235265', 0, 0, 0, '2023-05-12 10:10:55.891', '2023-05-15 00:00:00.100');
INSERT INTO `blog` VALUES ('56be174ccab2e2f71a83993698a57914', 'linux', 'http://rusndkp3v.bkt.clouddn.com/blogFile/1629495477589856258/linux.webp', 'linux', '<h1>linux</h1><h3>防火墙</h3><pre><code class=\"language-shell\">firewall-cmd --list-ports //防火墙打开端口\nfirewall-cmd --zone=public --add-port=6379/tcp --permanent //放开端口号\nsystemctl restart firewalld.service //重启防火墙\nfirewall-cmd --reload //加载\n</code></pre><p><br></p>', '阎涵瑶', '14c33282d85c983b6cfb02e78f62493c', 0, 1, 1, '2023-05-17 19:37:56.475', '2023-05-31 00:00:00.050');
INSERT INTO `blog` VALUES ('618bbc10d9f5cdede78fb2d1944cd8ff', 'spring', 'http://rt6vvz8xh.bkt.clouddn.com/blogFile/1629495477589856258/b219ebc4b74543a9e3e0ca386c1dac8eb8011464.webp', '“博客”当然是个大家都陌生的名词,博客的英文名词就是“Blog或Weblog”(指人时对应于Blogger),是一个典型的网络新事物,查阅最新的英文词典也不可能查到', '啥计划的大啊啊所多', '林志杰', '1626518508932235265', 0, 0, 0, '2023-03-20 05:30:28.545', '2023-05-15 00:00:00.101');
INSERT INTO `blog` VALUES ('7ac64a96381c3d9538a19cfde4e62574', 'JVM虚拟机', 'http://rt6vvz8xh.bkt.clouddn.com/blogFile/1629495477589856258/b219ebc4b74543a9e3e0ca386c1dac8eb8011464.webp', '“博客”当然是个大家都陌生的名词,博客的英文名词就是“Blog或Weblog”(指人时对应于Blogger),是一个典型的网络新事物,查阅最新的英文词典也不可能查到', '啥计划的大', '林志杰', '1626518508932235265', 0, 0, 0, '2023-03-20 03:38:40.554', '2023-05-12 00:00:00.815');
INSERT INTO `blog` VALUES ('80bff26214030b450a48f4251032f6fa', 'HTTP', 'http://rusndkp3v.bkt.clouddn.com/blogFile/1629495477589856258/http.webp', 'HTTP是一种能够获取网络资源的通信协议，在web 上进行数据交换的基础，是一种client-server协议，浏览器接收方发送请求。完整的web文档由不同子文档拼接而成的，像是文本，布局描述，图片等。', '<h1>HTTP</h1><p>为web浏览器与web服务器之间的通信而设计</p><h3>概述</h3><h5>HTTP是一种能够获取网络资源的通信协议，在web 上进行数据交换的基础，是一种client-server协议，浏览器接收方发送请求。完整的web文档由不同子文档拼接而成的，像是文本，布局描述，图片等。</h5><p>浏览器发送的消息叫request，被服务器响应的消息叫response。</p><p><img src=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/http_request.png\" alt=\"A basic HTTP request\" data-href=\"\" style=\"\"/></p><ul><li>一个 HTTP 的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods\" target=\"\">method</a>，经常是由一个动词像<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET\" target=\"\"><code>GET</code></a>, <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST\" target=\"\"><code>POST</code></a> 或者一个名词像<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS\" target=\"\"><code>OPTIONS</code></a>，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD\" target=\"\"><code>HEAD</code></a>来定义客户端的动作行为。通常客户端的操作都是获取资源（GET 方法）或者发送<a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/Forms\" target=\"\">HTML form</a>表单（POST 方法），虽然在一些情况下也会有其他操作。</li><li>要获取的资源的路径，通常是上下文中就很明显的元素资源的 URL，它没有<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol\" target=\"\">protocol</a>（<code>http://</code>），<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Domain\" target=\"\">domain</a>（<code>developer.mozilla.org</code>），或是 TCP 的<a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Port\" target=\"\">port (en-US)</a>（HTTP 一般在 80 端口）。</li><li>HTTP 协议版本号。</li><li>为服务端表达其他信息的可选头部<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers\" target=\"\">headers</a>。</li><li>对于一些像 POST 这样的方法，报文的 body 就包含了发送的资源，这与响应报文的 body 类似。</li></ul><p><img src=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/http_response.png\" alt=\"img\" data-href=\"\" style=\"\"/></p><ul><li>HTTP 协议版本号。</li><li>一个状态码（<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status\" target=\"\">status code</a>），来告知对应请求执行成功或失败，以及失败的原因。</li><li>一个状态信息，这个信息是非权威的状态码描述信息，可以由服务端自行设定。</li><li>HTTP <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers\" target=\"\">headers</a>，与请求头部类似。</li><li>可选项，比起请求报文，响应报文中更常见地包含获取的资源 body。</li></ul><h3>HTTP缓存</h3><p>响应可复用时，服务器不用处理请求，不需要解析和路由请求、根据cookie恢复会话、查询数据库以获取结果或渲染模板引擎。减少服务器上的负载。</p><ol><li>私有缓存 绑定到特定客户端的缓存（浏览器缓存） 主要存储用户的个性化响应 防止信息泄露 个性化需要指令——Cache-Control: private 通常由cookie控制，单独的cookie不会使响应成为私有。 响应具有Authorization标头，不能将其存储在私有缓存中</li><li>共享缓存 共享缓存位于客户端和服务器之间，存储共享的响应 代理缓存 访问控制 减少网络流量 由HTTP标头等控制 如今普遍只能传输响应 托管缓存 服务开发人员部署（降低源服务器负载并有效地交付内容） 因部署的产品而异（通过Cache-Control 标头和你自己的配置文件或仪表板来控制缓存的行为） 指定（Cache-Control: no-store）选择退出私有缓存或代理缓存，使用自己的策略仅在托管缓存中缓存。</li><li>启发式缓存 尽可能多的缓存，即没有给出Cache-Control，如果满足某些条件，响应也会被存储和重用。规范建议是存储后的10%的时间。</li><li>基于age的缓存策略 http响应两种状态：fresh（表示响应仍然有效）和stale（缓存响应已经过期） 确定的标准是age（max-age）</li><li>Expires或max-age http1.0版本新鲜度过去由Expires标头指定（表示的是明确的时间，而不是经过的时间） Expires: Tue, 28 Feb 2022 22:22:22 GMT http1.1可以通过故意偏移系统时钟诱发问题，在HTTP/1.1中采用max-age max-age的优先度大于Expires。目前expires无需特地提供。</li><li>Vary响应 根据URL区分响应，还会根据Accept、Accept-Language 和 Accept-Encoding 请求标头的值产生变化。 Vary: Accept-Language代表已经缓存过得语言，不同语言不能请求重用。 User-Agent请求头具有非常多的变体，降低了重用的机会，考虑一种基于特征检测而不是基于User-Agent请求标头来改变行为的方法。 防止其他人重复使用缓存的个性化内容的应用程序，应该指定Cache-Control: private 而不是为 Vary 指定 cookie。</li><li>验证响应 过时的响应不会被丢弃 询问服务器进行重新验证，将旧响应转换为新的响应 使用包含 If-Modified-Since 或 If-None-Match 请求标头的条件请求完成 If-Modified-Since：收到响应后，会恢复为新鲜的。 ETag响应头的值是服务器生成的任意值。请求头和响应头的值相等则是旧的返回304 Not Modified，相同则改为200ok。</li><li>强制重新验证 不希望重复使用响应，而是始终最新的内容，可以使用no-cache指令强制验证。 通过在响应中添加Cache-Control: no-cache 以及Last-Modified和 ETag如果请求资源已更新则收到200OK，否则会收到304 NOT MOdified。 max-age=0（缓存立刻过期） 和 must-revalidate（一旦过时就不得在没有重新验证的情况下重用它） 的组合与 no-cache （取消缓存）具有相同的含义。 现在一般直接使用no-cach。</li><li>不使用缓存 no-store代表不使用缓存 no-cach代表不会阻止响应的存储，而是阻止在没有重新验证的情况下重用响应。 不与其他用户共享：设置no-store再设置private。 每次都提供最新的内容：no-store指令阻止存储响应，但不会删除相同URL的任何已存储响应。no-cache强制客户端在重用任何存储的响应之前发送验证请求。 兼容过时的实现：使用no-cache处理这种过时的实现的替代方案，添加private来防止意外缓存。 no-store丢失了什么：最好将no-cach与private结合使用，因为no-store会失去浏览器和http的所有优势。</li><li>重新加载和**强制重新加载**</li></ol><p> &nbsp; 为了从页面错误中恢复或更新到最新版本的资源，浏览器为用户提供了重新加载功能。</p><p> &nbsp; 请求中的max-age=0指令指定重用为0或更少的响应。</p><p> &nbsp; 请求通过<code>If-None-Match</code> 和 <code>If-Modified-Since</code> 进行验证。</p><ol><li>避免重新验证 永远不会改变的内容应该赋予一个较长的max-age，方法是使用缓存破坏就是在URL中包含版本号和哈希值。 但是服务器依然会发送重新验证请求。增加指令immutable来明确指示不需要重新验证。</li><li>删除存储的响应 没有办法删除很长的max-age存储的响应。 加上no-cache可以使服务器始终接收请求并发送预期的响应。</li><li>请求折叠 多个请求同时到达共享缓存，中间缓存将代表自己将单个请求转发到源，然后源可以将结果重用于所有客户端。即使响应中给出了max-age=0或no-cache，它也会被重用。 不希望响应在折叠中共享加上private指令。</li><li>常见的缓存模式 默认设置 没有Cache-Control的响应，根据启发式缓存进行隐式缓存。可以加上标头避免这种缓存。加上no-cache始终传输最新版本的资源。如果服务实现了cookie或其他登录方式，也必须提供private。 缓存破坏 最适合缓存的资源是静态不可变文件，其内容永远不会改变。对于会变化的资源，最佳实践是每次内容变化时都改变URL。 36 cache-control max-age=0 37 cache-control max-age=604800 38 cache-control max-age=2592000 39 cache-control no-cache 40 cache-control no-store 41 cache-control public, max-age=31536000 缓存会在保存新条目时删除旧条目。 是一种通过内容更改时更改URL来使响应在很长一段时间内可缓存的技术，主要应用于所有子资源。 验证响应 设置Last-Modified和ETag标头，以便在重新加载时不必重新传输资源。 添加immutable防止重新加载时验证。 主要资源 主资源与子资源不同，不能使用缓存破坏，他们的URL不能像子资源一样被修饰。 对于HTML资源，不想存储HTML，而只是希望它是最新的。使用no-cache而不是no-store。 添加Last-Modified和ETag将允许客户端发送条件请求，如果HTML没更新，返回304。</li></ol><h3>HTTP Cookie</h3><p>HTTP Cookie是服务器发送到用户服务器并保存在本地的一小块数据。浏览器会存储cookie并在下次向同一服务器再发起请求时携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器——保持登录状态。Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。</p><p>Cookie主要用于以下三个方面：会话状态管理（登录状态，购物车，游戏分数以及其他记录的信息。），个性化设置（如用户自定义设置，主题和其他设置），浏览器行为跟踪（跟踪分析用户行为）。</p><ol><li>创建Cookie 服务器收到HTTP请求后，服务器在响应头里面添加一个或多个Set-Cookie选项。浏览器收到响应后通常会保存下Cookie，并将其放在HTTPcookie标头内，向同一服务器发送请求时一起发送。你可以指定一个过期日期或者时间段之后，不能发送cookie。</li><li>Set-Cookie和Cookie标头 服务器使用set-Cookie响应头部向用户代理（一般是浏览器）发送Cookie信息。 Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;</li><li>定义Cookie的生命周期 会话期Cookie会在当前的会话结束之后删除。浏览器定义了“当前会话”结束的时间，一些浏览器重启时会使用会话恢复。这可能导致会话Cookie无限延长。 持久性Cookie在过期时间（Expires）指定的日期或有效期（Max-Age）指定的一段时间后被删除。</li><li>限制访问Cookie Secure和HttpOnly属性可以确保Cookie安全发送 Secure的Cookie只应通过被HTTPS协议加密过得请求发送给服务端。 JavaScript API无法访问带有HttpOnly属性cookie；此类Cookie作用于服务器。</li><li>定义Cookie发送的位置 Domain和Path标识定义了Cookie的作用域，即允许Cookie应该发送哪些URL。</li><li>Domain属性 Domain指定哪些主机可以接受Cookie。如果不指定，默认属性为同一host，不包含子域名。指定则包含子域名。 如果设置Domain=mozilla.org，则Cookie也包含在子域名中。</li><li>Path属性 path属性指定URL路径，必须存在于请求的URL中，以便发送cookie标头。子路径也会被匹配。</li><li>SameSite属性 SameSite属性允许服务器指定是否/何时通过跨站点请求发送。 CSRF的保护，采用三个可能的值：Strict、Lax和None。 Strict：cookie仅发送到它来源的站点。 Lax：在用户导航到cookie的源站点时发送cookie。 None：指定浏览器会在同站请求和跨站请求下继续发送cookie。</li><li>Cookie前缀 cookie的机制无法让服务器确认cookie最初是在哪里设置的。 _Host-：如果cookie名称具有此前缀，则仅当它也用secure属性标记、从安全来源发送、不包括Domain属性，并将Path属性设置为/时，它才在Set-Cookie标头中接受。 _Secure-：如果cookie名称具有此前缀，则仅当它也用Secure属性标记，是从安全来源发送的，它才在Set-Cookie标头中接受。</li></ol><h3>跨源资源共享（CORS）</h3><p>跨源资源共享（CORS）是一种基于HTTP头的机制，该机制通过允许服务器标示除了它自己以外的其它源，使得浏览器允许这些origin访问加载自己的资源。跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的“预检”请求。预检中，浏览器发送的头中标示有HTTP方法和真实请求中会用到的头。</p><h5>什么情况下需要CORS</h5><ol><li>发起跨源HTTP请求</li><li>Web字体（只有授权网站可以跨站调用）</li><li>WebGL贴图</li><li>使用drawImage（）</li><li>来自图像的CSS图形</li></ol><h5>功能概述</h5><p>跨源资源共享新增了一组HTTP标头字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。</p><h5>若干访问控制场景</h5><ul><li>简单请求 某些请求不会触发CORS预检请求。 使用下列方法：GET，HEAD，POST 允许认为设置的字段为Fetch规范定义的对CORS安全的首部字段集合： Accept， Accept-Language, Content-Language, Content-Type(仅text/plain，multipart/form-data，application/x-www-form-urlencoded), Range。 如果请求是使用XMLHttpRequest对象发出的，在返回的XMLHttpRequest.upload对象属性上没有注册任何事件监听器； 请求中没有使用ReadableStream对象 请求首部字段Origin表明请求来源。 Access-Control-Allow-Origin的值为*代表该资源可以被任意外源访问。</li><li>预检请求 需预检的请求要求必须首先使用OPTIONS方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。 预检请求中的OPTIONS需要携带的两个首部字段 Access-Control-Request-Method: POST Access-Control-Request-Headers: X-PINGOTHER, Content-Type 服务器接受后续的请求方法 Access-Control-Allow-Origin: https://foo.example Access-Control-Allow-Methods: POST, GET, OPTIONS Access-Control-Allow-Headers: X-PINGOTHER, Content-Type Access-Control-Max-Age: 86400</li><li>预检请求与重定向 如果一个预检请求发生了重定向，一部分浏览器将报告错误。 两种方法规避上述报错行为 在服务器端去掉预检请求的重定向 将实际请求变成一个简单请求 发出一个简单请求以判断真正的预检请求会返回什么地址 发出另一个请求，使用在上一步获得的URL</li><li>附带身份凭证的请求 可以基于HTTP cookie和HTTP认证信息发送身份凭证， 发送请求withCredentials标志设置为true，从而发送cookie。 Access-Control-Allow-Credentials: true未携带，不会发送响应给请求的发送者。</li><li>预检请求和凭证 CORS预检请求不能包含凭证。必须指定Access-Control-Allow-Credentials: true来表明可以携带凭证。</li><li>附带身份凭证的请求与通配符 在响应附带身份凭证的请求时： 不能将Access-Control-Allow-Origin的值设置为*，应该指定特定的域 不能将Access-Control-Allow-Headers的值设置为*，应该设置为X-PINGOTHER, Content-Type等 不能将Access-Control-Allow-Methods的值设置为*，应该设置为POST, GET 原因时携带cookie，这样设置会请求失败。</li><li>第三方cookie 设置浏览器拒绝第三方cookie，将不会保存，Cookie策略受SameSite属性控制。</li></ul><h5>HTTP响应首部字段</h5><pre><code class=\"language-http\">Access-Control-Allow-Origin: &lt;origin&gt; | *\n</code></pre><p>指定了单一的源，告诉浏览器允许改源访问资源，对于不携带身份凭证的请求，服务器可以指定该字段的值为*。</p><p>如果服务端指定了具体的单个源而非通配符“*”，那么响应首部中Vary字段必须包含Origin。</p><pre><code class=\"language-http\">Access-Control-Expose-Headers: &lt;header-name&gt;[, &lt;header-name&gt;]*\n</code></pre><p>浏览器可通过getResponseHeader获取响应头中的内容</p><pre><code class=\"language-http\">Access-Control-Max-Age: &lt;delta-seconds&gt;\n</code></pre><p>delta-seconds参数表示preflight预检请求的结果在多少秒内生效</p><pre><code class=\"language-http\">Access-Control-Allow-Credentials: true\n</code></pre><p>指定了当浏览器的credentials设置为true时是否允许浏览器读取response的内容</p><pre><code class=\"language-http\">Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*\n</code></pre><p>指定了访问资源时允许使用的请求方法</p><pre><code class=\"language-http\">Access-Control-Allow-Headers: &lt;header-name&gt;[, &lt;header-name&gt;]*\n</code></pre><p>首部字段用于预检请求的响应。指明了实际请求中允许携带的首部字段。</p><h5>HTTP请求首部字段</h5><pre><code class=\"language-http\">Origin: &lt;origin&gt;\n</code></pre><p>首部字段表明预检请求或实际跨源请求的源站。</p><pre><code class=\"language-http\">Access-Control-Request-Method: &lt;method&gt;\n</code></pre><p>将实际请求所使用的HTTP方法告诉服务器</p><pre><code class=\"language-http\">Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*\n</code></pre><p>用于预检请求</p>', '浦俊康', '13ecc552b1ba41666ff8b79c26d88153', 0, 1, 1, '2023-05-17 19:35:53.272', '2023-05-31 00:00:00.050');
INSERT INTO `blog` VALUES ('8420202ade0571b79348c01b59bfe501', 'JVM', 'http://rt6vvz8xh.bkt.clouddn.com/blogFile/1629495477589856258/b219ebc4b74543a9e3e0ca386c1dac8eb8011464.webp', '“博客”当然是个大家都陌生的名词,博客的英文名词就是“Blog或Weblog”(指人时对应于Blogger),是一个典型的网络新事物,查阅最新的英文词典也不可能查到', '啥计划的大啊啊所多', '林志杰', '1626518508932235265', 0, 0, 0, '2023-03-20 05:30:16.266', '2023-05-12 00:00:00.815');
INSERT INTO `blog` VALUES ('85aca60001ac4e8268498beff132a56e', 'redis缓存', 'http://rt6vvz8xh.bkt.clouddn.com/blogFile/1629495477589856258/b219ebc4b74543a9e3e0ca386c1dac8eb8011464.webp', '“博客”当然是个大家都陌生的名词,博客的英文名词就是“Blog或Weblog”(指人时对应于Blogger),是一个典型的网络新事物,查阅最新的英文词典也不可能查到', '啥计划的大啊啊所多', '林志杰', '1626518508932235265', 1, 1, 0, '2023-03-20 05:31:01.934', '2023-05-17 00:00:00.177');
INSERT INTO `blog` VALUES ('8c221b32667b824cbd5c4e25ca263e6b', '08_Java程序员要掌握的前端-js', 'http://rusndkp3v.bkt.clouddn.com/blogFile/1629495477589856258/javascript.jpg', '它是一种脚本语言，可以用来更改页面内容，控制多媒体，制作图像、动画等等', '<h1>第二章. Javascript</h1><p>它是一种脚本语言，可以用来更改页面内容，控制多媒体，制作图像、动画等等</p><p>例子</p><ul><li>修改页面内容</li></ul><p>js 代码位置</p><pre><code class=\"language-html\">&lt;script&gt;\n    // js 代码\n&lt;/script&gt;\n</code></pre><p>引入 js 脚本</p><pre><code class=\"language-html\">&lt;script src=\"js脚本路径\"&gt;&lt;/script&gt;\n</code></pre><ul><li>注意，到了框架之后，引入方式会有不同</li></ul><h2>1. 变量与数据类型</h2><h3>声明变量</h3><h4>1) let :star:</h4><pre><code class=\"language-js\">let 变量名 = 值;\n</code></pre><ul><li>let 声明的变量可以被多次赋值，例如</li></ul><pre><code class=\"language-js\">let a = 100;  // 初始值是 100\na = 200;	  // ok, 被重新赋值为 200\n</code></pre><h4>2) const :star:</h4><ul><li>const 修饰的叫常量，只能赋值一次</li></ul><pre><code class=\"language-js\">const b = 300; // 初始值是 300\nb = 400;	   // error, 不能再次赋值\n</code></pre><ul><li>const 并不意味着它引用的内容不可修改，例如</li></ul><pre><code class=\"language-js\">const c = [1,2,3];\nc[2] = 4; 	        // ok, 数组内容被修改成 [1,2,4]\nc = [5,6];			// error, 不能再次赋值\n</code></pre><h4>3) var</h4><p>var 声明的变量可以被多次赋值，例如</p><pre><code class=\"language-js\">var f = 100;\nf = 200;\n</code></pre><h3>基本类型</h3><h4>1,2) undefined 和 null</h4><ul><li>执行表达式或函数，没有返回结果，出现 undefined</li><li>访问数组不存在的元素，访问对象不存在的属性，出现 undefined</li><li>定义变量，没有初始化，出现 undefined</li></ul><p>例</p><pre><code class=\"language-js\">console.log(1);  	// 函数没有返回值, 结果是  undefined\nlet a = 10;		 	// 表达式没有返回值, 结果是 undefined\nlet b = [1,2,3];\nconsole.log(b[10]); // 数组未定义元素是 undefined\nlet c = {\"name\":\"张三\"};\nconsole.log(c.age); // 对象未定义属性是 undefined\nlet d;\nconsole.log(d);		// 变量未初始化是 undefined\n</code></pre><p>二者共同点</p><ul><li>都没有属性、方法</li><li>二者合称 Nullish</li></ul><p>二者区别</p><ul><li>undefined 由 js 产生</li><li>null 由程序员提供</li></ul><h4>3) string :star:</h4><p>js 字符串三种写法</p><pre><code class=\"language-js\">let a = \"hello\";  // 双引号\nlet b = \"world\";  // 单引号\nlet c = `hello`;  // 反引号\n</code></pre><p>html 代码如下，用 java 和 js 中的字符串如何表示？</p><pre><code class=\"language-html\">&lt;a href=\"1.html\"&gt;超链接&lt;/a&gt;\n</code></pre><p>java 显得比较繁琐</p><pre><code class=\"language-java\">String s1 = \"&lt;a href=\\\"1.html\\\"&gt;超链接&lt;/a&gt;\";\n\nString s2 = \"\"\"\n    &lt;a href=\"1.html\"&gt;超链接&lt;/a&gt;\"\"\";\n</code></pre><p>js 就比较灵活</p><pre><code class=\"language-js\">let s1 = \'&lt;a href=\"1.html\"&gt;超链接&lt;/a&gt;\';\n\nlet s2 = `&lt;a href=\"1.html\"&gt;超链接&lt;/a&gt;`;\n</code></pre><p>模板字符串（Template strings）</p><p>需求：拼接 URI 的请求参数，如</p><pre><code >/test?name=zhang&age=18\n/test?name=li&age=20\n</code></pre><p>传统方法拼接</p><pre><code class=\"language-js\">let name = ; // zhang li ...\nlet age = ; // 18 20 ...\n\nlet uri = \"/test?name=\" + name + \"&age=\" + age;\n</code></pre><p>模板字符串方式</p><pre><code class=\"language-js\">let name = ; // zhang li ...\nlet age = ; // 18 20 ...\n\nlet uri = `/test?name=${name}&age=${age}`;\n</code></pre><h4>4,5) number 和 bigint:star:</h4><p>number 类型标识的是双精度浮动小数，例如</p><pre><code class=\"language-js\">10 / 3;   // 结果 3.3333333333333335\n</code></pre><p>既然是浮点小数，那么可以除零</p><pre><code class=\"language-js\">10 / 0;	  // 结果 Infinity 正无穷大\n-10 / 0;  // 结果 -Infinity 负无穷大\n</code></pre><p>浮点小数都有运算精度问题，例如</p><pre><code class=\"language-js\">2.0 - 1.1; // 结果 0.8999999999999999\n</code></pre><p>字符串转数字</p><pre><code class=\"language-js\">parseInt(\"10\"); 	// 结果是数字 10 \nparseInt(\"10.5\");	// 结果是数字 10, 去除了小数部分\nparseInt(\"10\") / 3; // 结果仍视为 number 浮点数, 因此结果为 3.3333333333333335\n\nparseInt(\"abc\");	// 转换失败，结果是特殊值 NaN (Not a Number)\n</code></pre><p>要表示真正的整数，需要用 bigint，数字的结尾用 n 表示它是一个 bigint 类型</p><pre><code class=\"language-js\">10n / 3n;			// 结果 3n, 按整数除法处理\n</code></pre><h4>6) boolean :star:</h4><ul><li>Truthy</li><li>Falsy</li></ul><p>在 js 中，并不是 boolean 才能用于条件判断，你可以在 if 语句中使用【数字】、【字符串】... 作为判断条件</p><pre><code class=\"language-js\">let b = 1;\n\nif(b) { // true\n    console.log(\"进入了\");\n}\n</code></pre><p>这时就有一个规则，当需要条件判断时，这个值被当作 true 还是 false，当作 true 的值归类为 truthy，当作 false 的值归类为 falsy</p><p>下面值都是 falsy</p><ul><li><code>false</code></li><li><code>Nullish (null, undefined)</code></li><li><code>0, 0n, NaN</code></li><li><code>\"\" \'\' ``</code> &nbsp;即长度为零的字符串</li></ul><p>剩余的值绝大部分都是 truthy</p><p>有几个容易被当作 falsy 实际是 truthy 的</p><ul><li><code>\"false\", \"0\"</code> 即字符串的 false 和 字符串的零</li><li><code>[]</code> 空数组</li><li><code>{}</code> 空对象</li></ul><h4>7) symbol</h4><ul><li>很少使用</li></ul><h3>对象类型</h3><h4>1) Function :star::star:</h4><h5>定义函数</h5><pre><code class=\"language-js\">function 函数名(参数) {\n    // 函数体\n    return 结果;\n}\n</code></pre><p>例</p><pre><code class=\"language-js\">function add(a, b) {\n    return a + b;\n}\n</code></pre><h5>调用函数</h5><pre><code class=\"language-js\">函数名(实参);\n</code></pre><p>例</p><pre><code class=\"language-js\">add(1, 2);     // 返回 3\n</code></pre><p>js 中的函数调用特点：对参数的<strong>类型</strong>和<strong>个数</strong>都没有限制，例如</p><pre><code class=\"language-js\">add(\'a\', \'b\');  // 返回 ab\nadd(4, 5, 6);   // 返回 9, 第三个参数没有被用到, 不会报错\nadd(1);			// 返回 NaN, 这时 b 没有定义是 undefined, undefined 做数学运算结果就是 NaN\n</code></pre><h5>默认参数</h5><p>java 中（spring）要实现默认参数的效果得这么做：</p><pre><code class=\"language-java\">@RestController \npublic class MyController {\n    \n    @RequestMapping(\"/page\")\n    @ResponseBody\n    public void page(\n        @RequestParam(defaultValue=\"1\") int page, \n        @RequestParam(defaultValue=\"10\") int size\n    ){\n        // ...\n    }\n}\n</code></pre><p>js</p><pre><code class=\"language-js\">function pagination(page = 1, size = 10) {\n    console.log(page, size);\n}\n</code></pre><h5>匿名函数</h5><p>语法</p><pre><code class=\"language-js\">(function (参数) {\n    // 函数体\n    return 结果;\n})\n</code></pre><p>例</p><pre><code class=\"language-js\">(function(a,b){\n    return a + b;\n})\n</code></pre><p>第一种场景：定义完毕后立刻调用</p><pre><code class=\"language-js\">(function(a,b){\n    return a + b;\n})(1,2)\n</code></pre><p>第二种场景：作为其它对象的方法，例如</p><p>页面有元素</p><pre><code class=\"language-html\">&lt;p id=\"p1\"&gt;点我啊&lt;/p&gt;\n</code></pre><p>此元素有一个 onclick 方法，会在鼠标单击这个元素后被执行，onclick 方法刚开始是 null，需要赋值后才能使用</p><pre><code class=\"language-js\">document.getElementById(\"p1\").onclick = (function(){\n    console.log(\"鼠标单击了...\");\n});\n</code></pre><h5>箭头函数</h5><pre><code class=\"language-js\">(参数) =&gt; {\n    // 函数体\n    return 结果;\n}\n</code></pre><ul><li>如果没有参数，() 还是要保留</li><li>如果只有一个参数，() 可以省略</li><li>如果函数体内只有一行代码，{} 可以省略</li><li>如果这一行代码就是结果，return 可以省略</li></ul><p>例</p><pre><code class=\"language-js\">document.getElementById(\"p1\").onclick = () =&gt;  console.log(\"aa\");\n</code></pre><h5>函数是对象</h5><p>以下形式在 js 中非常常见！</p><ol><li>可以参与赋值，例，具名函数也能参与赋值</li></ol><pre><code class=\"language-js\">function abc() {\n    console.log(\"bb\");\n}\n\ndocument.getElementById(\"p1\").onclick = abc;\n</code></pre><ol><li>有属性、有方法，执行 <code>console.dir(abc)</code>，输出结果如下</li></ol><pre><code >ƒ abc()\n    arguments: null\n    caller: null\n    length: 0\n    name: \"abc\"\n    ➡prototype: {constructor: ƒ}\n    [[FunctionLocation]]: VM1962:1\n    ➡[[Prototype]]: ƒ ()\n    ➡[[Scopes]]: Scopes[1]\n</code></pre><ul><li>其中带有 f 标记的是方法，不带的是属性</li><li>带有 ➡ 符号的可以继续展开，限于篇幅省略了</li><li>带有 [[ ]] 的是内置属性，不能访问，只能查看</li><li>相对重要的是 [[Prototype]] 和 [[Scopes]] 会在后面继承和作用域时讲到</li></ul><ol><li>可以作为方法参数</li></ol><pre><code class=\"language-js\">function a() {\n    console.log(\'a\')\n}\n\nfunction b(fn) {          // fn 将来可以是一个函数对象\n    console.log(\'b\')\n    fn();                 // 调用函数对象\n}\n\nb(a)\n</code></pre><ol><li>可以作为方法返回值</li></ol><pre><code class=\"language-js\">function c() {\n    console.log(\"c\");\n    function d() {\n        console.log(\"d\");\n    }\n    return d;\n}\n\nc()()\n</code></pre><h5>函数作用域</h5><p>函数可以嵌套（js 代码中很常见，只是嵌套的形式更多是匿名函数，箭头函数）</p><pre><code class=\"language-js\">function a() {\n    function b() {        \n    }\n}\n</code></pre><p>看下面的例子</p><pre><code class=\"language-js\">function c() {\n    var z = 30;\n}\n\nvar x = 10;\nfunction a() {\n    var y = 20;\n    function b() {\n        // 看这里\n        console.log(x, y);\n    }\n    b();\n}\na();\n</code></pre><ul><li>以函数为分界线划定作用域，所有函数之外是全局作用域</li><li>查找变量时，由内向外查找</li><li>作用域本质上是函数对象的属性，可以通过 console.dir 来查看调试</li></ul><h5>闭包</h5><pre><code class=\"language-js\">var x = 10;\nfunction a() {\n    var y = 20;\n    function b() {\n        console.log(x,y);\n    }\n    return b;\n}\na()();  // 在外面执行了 b\n</code></pre><ul><li>函数定义时，它的作用域已经确定好了，因此无论函数将来去了哪，都能从它的作用域中找到当时那些变量</li><li>别被概念忽悠了，闭包就是指<strong>函数能够访问自己的作用域中变量</strong></li></ul><h5>let、var 与作用域</h5><p>如果函数外层引用的是 let 变量，那么外层普通的 {} 也会作为作用域边界，最外层的 let 也占一个 script 作用域</p><pre><code class=\"language-js\">let x = 10; \nif(true) {\n    let y = 20;\n    function b() {\n        console.log(x,y);\n    }\n    console.dir(b);\n}\n</code></pre><p>如果函数外层引用的是 var 变量，外层普通的 {} 不会视为边界</p><pre><code class=\"language-js\">var x = 10; \nif(true) {\n    var y = 20;\n    function b() {\n        console.log(x,y);\n    }\n    console.dir(b);\n}\n</code></pre><p>如果 var 变量出现了重名，则他俩会被视为同一作用域中的同一个变量</p><pre><code class=\"language-js\">var e = 10; \nif(true) {\n    var e = 20;\n    console.log(e);	// 打印 20\n}\nconsole.log(e);		// 因为是同一个变量，还是打印 20\n</code></pre><p>如果是 let，则视为两个作用域中的两个变量</p><pre><code class=\"language-js\">let e = 10; \nif(true) {\n    let e = 20;	\n    console.log(e);	// 打印 20\n}\nconsole.log(e);		// 打印 10\n</code></pre><p>要想里面的 e 和外面的 e 能区分开来，最简单的办法是改成 let，或者用函数来界定作用域范围</p><pre><code class=\"language-js\">var e = 10; \nif(true) {\n    function b() {\n        var e = 20;\n        console.log(e);\n    }\n    b();\n}\nconsole.log(e);	\n</code></pre><h4>2) Array :star:</h4><p>语法</p><pre><code class=\"language-js\">// 创建数组\nlet arr = [1,2,3]; \n\n// 获取数组元素\nconsole.log(arr[0]); // 输出 1\n\n// 修改数组元素\narray[0] = 5;		 // 数组元素变成了 [5,2,3]\n\n// 遍历数组元素，其中 length 是数组属性，代表数组长度\nfor(let i = 0; i &lt; arr.length; i++) {\n    console.log(arr[i]);\n}\n</code></pre><p>API</p><ul><li>push、shift、splice</li></ul><pre><code class=\"language-js\">let arr = [1,2,3]; \n\narr.push(4);    	// 向数组尾部(右侧)添加元素, 结果 [1,2,3,4]\narr.shift();		// 从数组头部(左侧)移除元素, 结果 [2,3,4]\narr.splice(1,1);	// 删除【参数1】索引位置的【参数2】个元素，结果 [2,4]\n</code></pre><ul><li>join</li></ul><pre><code class=\"language-js\">let arr = [\'a\',\'b\',\'c\'];\n\narr.join(); 		// 默认使用【,】作为连接符，结果 \'a,b,c\'\narr.join(\'\');		// 结果 \'abc\'\narr.join(\'-\');		// 结果 \'a-b-c\'\n</code></pre><ul><li>map、filter、forEach</li></ul><pre><code class=\"language-js\">let arr = [1,2,3,6];\n\nfunction a(i) {   // 代表的新旧元素之间的变换规则\n    return i * 10\n}\n\n// arr.map(a) // 具名函数，结果 [10,20,30,60]\n\n// arr.map( (i) =&gt; {return i * 10} ); // 箭头函数\narr.map( i =&gt; i * 10 ); // 箭头函数\n</code></pre><ul><li>传给 map 的函数，参数代表旧元素，返回值代表新元素</li></ul><p>map 的内部实现（伪代码）</p><pre><code class=\"language-js\">function map(a) { // 参数是一个函数\n    let narr = [];\n    for(let i = 0; i &lt; arr.length; i++) {\n        let o = arr[i]; // 旧元素\n        let n = a(o);   // 新元素\n        narr.push(n);\n    }\n    return narr;\n} \n</code></pre><p>filter 例子</p><pre><code class=\"language-js\">let arr = [1,2,3,6];\narr.filter( (i)=&gt; i % 2 == 1 ); // 结果 [1,3]\n</code></pre><ul><li>传给 filter 的函数，参数代表旧元素，返回 true 表示要留下的元素</li></ul><p>forEach 例子</p><pre><code class=\"language-js\">let arr = [1,2,3,6];\n\n/*for(let i = 0; i &lt; arr.length; i++) {\n    console.log(arr[i]);\n}*/\n\narr.forEach( (i) =&gt; console.log(i) );\n</code></pre><p>两个称呼</p><ul><li>高阶函数，map，filter，forEach</li><li>回调函数，例如作为参数传入的函数</li></ul><h4>3) Object :star::star:</h4><h5>语法</h5><pre><code class=\"language-js\">let obj = {\n    属性名: 值,\n    方法名: 函数,\n    get 属性名() {},\n    set 属性名(新值) {}\n}\n</code></pre><p>例1</p><pre><code class=\"language-js\">let stu1 = {\n    name: \"小明\",\n    age: 18,\n    study: function(){\n        console.log(this.name + \"爱学习\");\n    }    \n}\n</code></pre><p>例2</p><pre><code class=\"language-js\">let name = \"小黑\";\nlet age = 20;\nlet study = function(){\n    console.log(this.name + \"爱学习\");\n}\n\nlet stu2 = { name, age, study }\n</code></pre><p>例3（重点）</p><pre><code class=\"language-js\">let stu3 = {\n    name: \"小白\",\n    age: 18,\n    study(){\n        console.log(this.name + \"爱学习\");\n    }    \n}\n</code></pre><ul><li><strong>注意</strong>：对象方法这么写，仅限于对象内部</li></ul><p>例4</p><pre><code class=\"language-js\">let stu4 = {\n    _name: null, /*类似于java中私有成员变量*/\n    get name() {\n        console.log(\"进入了get\");\n        return this._name;\n    },\n    set name(name) {\n        console.log(\"进入了set\");\n        this._name = name;\n    }\n}\n</code></pre><p>调用 get，set</p><pre><code class=\"language-js\">stu4.name = \"小白\"\n\nconsole.log(stu4.name)\n</code></pre><h5>特色：属性增删</h5><p>对比一下 Java 中的 Object</p><ul><li>Java 的 Object 是以类作为模板来创建，对象不能脱离类模板的范围，一个对象的属性、能用的方法都是确定好的</li><li>js 的对象，不需要什么模板，它的属性和方法可以随时加减</li></ul><pre><code class=\"language-js\">let stu = {name:\'张三\'};\nstu.age = 18;					// 添加属性\ndelete stu.age;					// 删除属性\n\nstu.study = function() {		// 添加方法\n    console.log(this.name + \"在学习\");\n}\n</code></pre><p>添加 get，set，需要借助 Object.definePropery</p><pre><code class=\"language-js\">let stu = {_name:null};\n\nObject.defineProperty(stu, \"name\", {\n    get(){\n        return this._name;\n    },\n    set(name){\n        this._name = name;\n    }\n});\n</code></pre><ul><li>参数1：目标对象</li><li>参数2：属性名</li><li>参数3：get，set 的定义</li></ul><h5>特色：this</h5><p>先来对 Java 中的 this 有个理解</p><pre><code class=\"language-java\">public class TestMethod {\n\n    static class Student {\n        private String name;\n\n        public Student(String name) {\n            this.name = name;\n        }\n\n        public void study(Student this, String subject) {\n            System.out.println(this.name + \"在学习 \" + subject);\n        }\n    }\n\n    public static void main(String[] args) {\n        Student stu = new Student(\"小明\");\n        \n        // 下面的代码，本质上是执行 study(stu, \"java\")，因此 this 就是 stu\n        stu.study(\"java\"); \n    }\n}\n</code></pre><ul><li>Java 中的 this 是个隐式参数</li><li>Java 中，我们说 this 代表的就是调用方法的那个对象</li></ul><p>js 中的 this 也是隐式参数，但它与函数运行时上下文相关</p><p>例如，一个“落单”的函数</p><pre><code class=\"language-js\">function study(subject) {\n    console.log(this.name + \"在学习 \" + subject)\n}\n</code></pre><p>测试一下</p><pre><code class=\"language-js\">study(\"js\");  // 输出 在学习 js\n</code></pre><p>这是因为此时函数执行，全局对象 window 被当作了 this，window 对象的 name 属性是空串</p><p>同样的函数，如果作为对象的方法</p><pre><code class=\"language-js\">let stu = {\n    name:\"小白\",\n    study\n}\n</code></pre><p>这种情况下，会将当前对象作为 this</p><pre><code class=\"language-js\">stu.study(\'js\'); 	// 输出 小白在学习 js\n</code></pre><p>还可以动态改变 this</p><pre><code class=\"language-js\">let stu = {name:\"小黑\"};\nstudy.call(stu, \"js\");	// 输出 小黑在学习 js\n</code></pre><p>这回 study 执行时，就把 call 的第一个参数 stu 作为 this</p><p>一个例外是，在<strong>箭头函数</strong>内出现的 this，以外层 this 理解 </p><p>用匿名函数</p><pre><code class=\"language-js\">let stu = {\n    name: \"小花\",\n    friends: [\"小白\",\"小黑\",\"小明\"],\n    play() {\n        this.friends.forEach(function(e){\n            console.log(this.name + \"与\" + e + \"在玩耍\");\n        });\n    }\n}\nstu.play()\n</code></pre><ul><li>this.name 所在的函数是【落单】的函数，因此 this 代表 window</li></ul><p>输出结果为</p><pre><code >与小白在玩耍\n与小黑在玩耍\n与小明在玩耍\n</code></pre><p>用箭头函数</p><pre><code class=\"language-js\">let stu = {\n    name: \"小花\",\n    friends: [\"小白\",\"小黑\",\"小明\"],\n    play() {\n        this.friends.forEach(e =&gt; {\n            console.log(this.name + \"与\" + e + \"在玩耍\");\n        })\n    }    \n}\n</code></pre><ul><li>this.name 所在的函数是箭头函数，因此 this 要看它外层的 play 函数，play 又是属于 stu 的方法，因此 this 代表 stu 对象</li></ul><p>输出结果为</p><pre><code >小花与小白在玩耍\n小花与小黑在玩耍\n小花与小明在玩耍\n</code></pre><p>不用箭头函数的做法</p><pre><code class=\"language-js\">let stu = {\n    name: \"小花\",\n    friends: [\"小白\",\"小黑\",\"小明\"],\n    play() {\n        let me = this;\n        this.friends.forEach(function(e){\n            console.log(me.name + \"与\" + e + \"在玩耍\");\n        });\n    }\n}\n</code></pre><h5>特色：原型继承</h5><pre><code class=\"language-js\">let father = {\n    f1: \'父属性\',\n    m1: function() {\n        console.log(\"父方法\");\n    }\n}\n\nlet son = Object.create(father);\n\nconsole.log(son.f1);  // 打印 父属性\nson.m1();			  // 打印 父方法\n</code></pre><ul><li>father 是父对象，son 去调用 .m1 或 .f1 时，自身对象没有，就到父对象找</li><li>son 自己可以添加自己的属性和方法</li><li>son 里有特殊属性 <code>__proto__</code> 代表它的父对象，js 术语： son 的原型对象</li><li>不同浏览器对打印 son 的 <code>__proto__</code> 属性时显示不同</li></ul><h5>特色：基于函数的原型继承</h5><p>出于方便的原因，js 又提供了一种基于函数的原型继承</p><blockquote>函数职责 负责创建子对象，给子对象提供属性、方法，功能上相当于构造方法 函数有个特殊的属性 prototype，它就是函数创建的子对象的父对象 注意！名字有差异，这个属性的作用就是为新对象提供原型</blockquote><pre><code class=\"language-js\">function cons(f2) {\n    // 创建子对象(this), 给子对象提供属性和方法\n    this.f2 = f2;\n    this.m2 = function () {\n        console.log(\"子方法\");\n    }\n}\n// cons.prototype 就是父对象\ncons.prototype.f1 = \"父属性\";\ncons.prototype.m1 = function() {\n    console.log(\"父方法\");\n}\n</code></pre><p>配合 new 关键字，创建子对象</p><pre><code class=\"language-js\">let son = new cons(\"子属性\")\n</code></pre><p>子对象的 <code>__proto__</code> 就是函数的 <code>prototype</code> 属性</p><h5>JSON</h5><p>之前我们讲 http 请求格式时，讲过 json 这种数据格式，它的语法看起来与 js 对象非常相似，例如：</p><p>一个 json 对象可以长这样：</p><pre><code class=\"language-json\">{\n    \"name\":\"张三\",\n    \"age\":18\n}\n</code></pre><p>一个 js 对象长这样：</p><pre><code class=\"language-js\">{\n    name:\"张三\",\n    age:18\n}\n</code></pre><p>那么他们的区别在哪儿呢？我总结了这么几点</p><ol><li>本质不同</li><li>语法细节不同</li></ol><p>json 字符串与 js 对象的转换</p><pre><code class=\"language-js\">JSON.parse(json字符串);  // 返回js对象\nJSON.stringify(js对象);  // 返回json字符串\n</code></pre><h3>动态类型</h3><p>静态类型语言，如 Java，值有类型，变量也有类型、赋值给变量时，类型要相符</p><pre><code class=\"language-java\">int a = 10;\nString b = \"abc\";\n\nint c = \"abc\";  // 错误\n</code></pre><p>而 js 属于动态类型语言，值有类型，但变量没有类型，赋值给变量时，没要求</p><p>例如</p><pre><code class=\"language-js\">let a = 200;\n\nlet b = 100;\nb = \'abc\';\nb = true;\n</code></pre><p>动态类型看起来比较灵活，但变量没有类型，会给后期维护带来困难，例如</p><pre><code class=\"language-js\">function test(obj) {\n    // obj 的类型未知，必须根据不同类型做出相应的容错处理\n}\n</code></pre><h2>2. 运算符与表达式</h2><ul><li><code>+ - * / % ** </code></li><li><code>+= -= *= /= %= **=</code></li><li><code>++ --</code></li><li>位运算、移位运算</li><li><code>== != &gt; &gt;= &lt; &lt;=</code></li><li><code>=== !==</code> :star:</li><li><code>&& || !</code> :star:</li><li><code>?? ?.</code> :star:</li><li><code>...</code> :star:</li><li>解构赋值 :star:</li></ul><h3>1) ===</h3><p>严格相等运算符，用作逻辑判等</p><pre><code class=\"language-js\">1 == 1    	// 返回 true \n1 == \'1\'	// 返回 true，会先将右侧的字符串转为数字，再做比较\n1 === \'1\'	// 返回 false，类型不等，直接返回 false\n</code></pre><p>typeof 查看某个值的类型</p><pre><code class=\"language-js\">typeof 1	// 返回 \'number\'\ntypeof \'1\'	// 返回 \'string\'\n</code></pre><h3>2) ||</h3><p>需求，如果参数 n 没有传递，给它一个【男】</p><p><strong>推荐</strong>做法</p><pre><code class=\"language-js\">function test(n = \'男\') {\n    console.log(n);\n}\n</code></pre><p>你可能的做法</p><pre><code class=\"language-js\">function test(n) {\n    if(n === undefined) {\n        n = \'男\';\n    }\n    console.log(n);\n}\n</code></pre><p>还可能是这样</p><pre><code class=\"language-js\">function test(n) {\n    n = (n === undefined) ? \'男\' : n;\n    console.log(n);\n}\n</code></pre><p>一些老旧代码中可能的做法（不推荐）</p><pre><code class=\"language-js\">function test(n) {\n    n = n || \'男\';\n    console.log(n);\n}\n</code></pre><p>它的语法是</p><pre><code class=\"language-js\">值1 || 值2\n</code></pre><p>如果值1 是 Truthy，返回值1，如果值1 是 Falsy 返回值 2</p><h3>3) ?? 与 ?.</h3><h4>??</h4><p>需求，如果参数 n 没有传递或是 null，给它一个【男】</p><p>如果用传统办法</p><pre><code class=\"language-js\">function test(n) {\n    if(n === undefined || n === null) {\n        n = \'男\';\n    }\n    console.log(n);\n}\n</code></pre><p>用 ??</p><pre><code class=\"language-js\">function test(n) {\n    n = n ?? \'男\';\n    console.log(n);\n}\n</code></pre><p>语法</p><pre><code >值1 ?? 值2\n</code></pre><ul><li>值1 是 nullish，返回值2</li><li>值1 不是 nullish，返回值1</li></ul><h4>?.</h4><p>需求，函数参数是一个对象，可能包含有子属性</p><p>例如，参数可能是</p><pre><code class=\"language-js\">let stu1 = {\n    name:\"张三\",\n    address: {\n        city: \'北京\'\n    }\n};\n\nlet stu2 = {\n    name:\"李四\"\n}\n\nlet stu3 = {\n    name:\"李四\",\n    address: null\n}\n</code></pre><p>现在要访问子属性（有问题）</p><pre><code class=\"language-js\">function test(stu) {\n    console.log(stu.address.city)\n}\n</code></pre><p>现在希望当某个属性是 nullish 时，短路并返回 undefined，可以用 ?.</p><pre><code class=\"language-js\">function test(stu) {\n    console.log(stu.address?.city)\n}\n</code></pre><p>用传统办法 </p><pre><code class=\"language-js\">function test(stu) {\n    if(stu.address === undefined || stu.address === null) {\n        console.log(undefined);\n        return;\n    }\n    console.log(stu.address.city)\n}\n</code></pre><h3>4) ...</h3><p>展开运算符</p><p>作用1：打散数组，把元素传递给多个参数</p><pre><code class=\"language-js\">let arr = [1,2,3];\n\nfunction test(a,b,c) {\n    console.log(a,b,c);\n}\n</code></pre><p>需求，把数组元素依次传递给函数参数</p><p>传统写法</p><pre><code class=\"language-js\">test(arr[0],arr[1],arr[2]);		// 输出 1,2,3\n</code></pre><p>展开运算符写法</p><pre><code class=\"language-js\">test(...arr);					// 输出 1,2,3\n</code></pre><ul><li>打散可以理解为【去掉了】数组外侧的中括号，只剩下数组元素</li></ul><p>作用2：复制数组或对象</p><p>数组</p><pre><code class=\"language-js\">let arr1 = [1,2,3];\nlet arr2 = [...arr1];		// 复制数组\n</code></pre><p>对象</p><pre><code class=\"language-js\">let obj1 = {name:\'张三\', age: 18};\n\nlet obj2 = {...obj1};		// 复制对象\n</code></pre><p><strong>注意</strong>：展开运算符复制属于浅拷贝，例如</p><pre><code class=\"language-js\">let o1 = {name:\'张三\', address: {city: \'北京\'} }\n\nlet o2 = {...o1};\n</code></pre><p>作用3：合并数组或对象</p><p>合并数组</p><pre><code class=\"language-js\">let a1 = [1,2];\nlet a2 = [3,4];\n\nlet b1 = [...a1,...a2];		// 结果 [1,2,3,4]\nlet b2 = [...a2,5,...a1]	// 结果 [3,4,5,1,2]\n</code></pre><p>合并对象</p><pre><code class=\"language-js\">let o1 = {name:\'张三\'};\nlet o2 = {age:18};\nlet o3 = {name:\'李四\'};\n\nlet n1 = {...o1, ...o2};	// 结果 {name:\'张三\',age:18}\n\nlet n2 = {...o3, ...o2, ...o1}; // 结果{name:\'李四\',age:18}\n</code></pre><ul><li>复制对象时出现同名属性，后面的会覆盖前面的</li></ul><h3>5) [] {}</h3><p>解构赋值</p><h4>[]</h4><p>用在声明变量时</p><pre><code class=\"language-js\">let arr = [1,2,3];\n\nlet [a, b, c] = arr;	// 结果 a=1, b=2, c=3\n</code></pre><p>用在声明参数时</p><pre><code class=\"language-js\">let arr = [1,2,3];\n\nfunction test([a,b,c]) {\n    console.log(a,b,c) 	// 结果 a=1, b=2, c=3\n}\n\ntest(arr);				\n</code></pre><h4>{}</h4><p>用在声明变量时</p><pre><code class=\"language-js\">let obj = {name:\"张三\", age:18};\n\nlet {name,age} = obj;	// 结果 name=张三, age=18\n</code></pre><p>用在声明参数时</p><pre><code class=\"language-js\">let obj = {name:\"张三\", age:18};\n\nfunction test({name, age}) {\n    console.log(name, age); // 结果 name=张三, age=18\n}\n\ntest(obj)\n</code></pre><h2>3. 控制语句</h2><ul><li><code>if ... else</code></li><li><code>switch</code></li><li><code>while</code></li><li><code>do ... while</code></li><li><code>for</code> </li><li><code>for ... in</code> :star:</li><li><code>for ... of</code> :star:</li><li><code>try ... catch</code> :star:</li></ul><h3>1) for in</h3><p>主要用来遍历对象</p><pre><code class=\"language-js\">let father = {name:\'张三\', age:18, study:function(){}};\n\nfor(const n in father) {\n    console.log(n);\n}\n</code></pre><ul><li>其中 const n 代表遍历出来的属性名</li><li>注意1：方法名也能被遍历出来（它其实也算一种特殊属性）</li><li>注意2：遍历子对象时，父对象的属性会跟着遍历出来</li></ul><pre><code class=\"language-js\">let son = Object.create(father);\nson.sex = \"男\";\n\nfor(const n in son) {\n    console.log(n);\n}\n</code></pre><ul><li>注意3：在 for in 内获取属性值，要使用 [] 语法，而不能用 . 语法</li></ul><pre><code class=\"language-js\">for(const n in son) {\n    console.log(n, son[n]);\n}\n</code></pre><h3>2) for of</h3><p>主要用来遍历数组，也可以是其它可迭代对象，如 Map，Set 等</p><pre><code class=\"language-js\">let a1 = [1,2,3];\n\nfor(const i of a1) {\n    console.log(i);\n}\n\nlet a2 = [\n    {name:\'张三\', age:18},\n    {name:\'李四\', age:20},\n    {name:\'王五\', age:22}\n];\n\nfor(const obj of a2) {\n    console.log(obj.name, obj.age);\n}\n\nfor(const {name,age} of a2) {\n    console.log(name, age);\n}\n</code></pre><h3>3) try catch</h3><pre><code class=\"language-js\">let stu1 = {name:\'张三\', age:18, address: {city:\'北京\'}};\nlet stu2 = {name:\'张三\', age:18};\n\nfunction test(stu) {\n    try {\n        console.log(stu.address.city)   \n    } catch(e) {\n        console.log(\'出现了异常\', e.message)\n    } finally {\n        console.log(\'finally\');\n    }\n}\n</code></pre><h2>4. API</h2><h3>环境准备</h3><h4>1) 安装 nvm</h4><p>nvm 即 (node version manager)，好处是方便切换 node.js 版本</p><p>安装注意事项</p><ol><li>要卸载掉现有的 nodejs</li><li>提示选择 nvm 和 nodejs 目录时，一定要避免目录中出现空格</li><li>选用【以管理员身份运行】cmd 程序来执行 nvm 命令</li><li>首次运行前设置好国内镜像地址</li></ol><pre><code >nvm node_mirror http://npm.taobao.org/mirrors/node/\nnvm npm_mirror https://npm.taobao.org/mirrors/npm/\n</code></pre><p>首先查看有哪些可用版本</p><pre><code >nvm list available\n</code></pre><p>输出</p><pre><code >\n|   CURRENT    |     LTS      |  OLD STABLE  | OLD UNSTABLE |\n|--------------|--------------|--------------|--------------|\n|    18.7.0    |   16.16.0    |   0.12.18    |   0.11.16    |\n|    18.6.0    |   16.15.1    |   0.12.17    |   0.11.15    |\n|    18.5.0    |   16.15.0    |   0.12.16    |   0.11.14    |\n|    18.4.0    |   16.14.2    |   0.12.15    |   0.11.13    |\n|    18.3.0    |   16.14.1    |   0.12.14    |   0.11.12    |\n|    18.2.0    |   16.14.0    |   0.12.13    |   0.11.11    |\n|    18.1.0    |   16.13.2    |   0.12.12    |   0.11.10    |\n|    18.0.0    |   16.13.1    |   0.12.11    |    0.11.9    |\n|    17.9.1    |   16.13.0    |   0.12.10    |    0.11.8    |\n|    17.9.0    |   14.20.0    |    0.12.9    |    0.11.7    |\n|    17.8.0    |   14.19.3    |    0.12.8    |    0.11.6    |\n|    17.7.2    |   14.19.2    |    0.12.7    |    0.11.5    |\n|    17.7.1    |   14.19.1    |    0.12.6    |    0.11.4    |\n|    17.7.0    |   14.19.0    |    0.12.5    |    0.11.3    |\n|    17.6.0    |   14.18.3    |    0.12.4    |    0.11.2    |\n|    17.5.0    |   14.18.2    |    0.12.3    |    0.11.1    |\n|    17.4.0    |   14.18.1    |    0.12.2    |    0.11.0    |\n|    17.3.1    |   14.18.0    |    0.12.1    |    0.9.12    |\n|    17.3.0    |   14.17.6    |    0.12.0    |    0.9.11    |\n|    17.2.0    |   14.17.5    |   0.10.48    |    0.9.10    |\n</code></pre><p>建议安装 LTS（长期支持版）</p><pre><code >nvm install 16.16.0\nnvm install 14.20.0\n</code></pre><p>执行 <code>nvm list</code> 会列出已安装版本</p><p>切换到 16.16.0</p><pre><code >nvm use 16.16.0\n</code></pre><p>切换到 14.20.0</p><pre><code >nvm use 14.20.0\n</code></pre><p>安装后 nvm 自己的环境变量会自动添加，但可能需要手工添加 nodejs 的 PATH 环境变量</p><h4>2) 检查 npm</h4><p>npm 是 js 的包管理器，就类似于 java 界的 maven，要确保它使用的是国内镜像</p><p>检查镜像</p><pre><code >npm get registry\n</code></pre><p>如果返回的不是 <code>https://registry.npm.taobao.org/</code>，需要做如下设置</p><pre><code >npm config set registry https://registry.npm.taobao.org/\n</code></pre><h4>3) 搭建前端服务器</h4><p>新建一个保存项目的 client 文件夹，进入文件夹执行</p><pre><code >npm install express --save-dev\n</code></pre><p>修改 package.json 文件</p><pre><code class=\"language-json\">{\n  \"type\": \"module\",\n  \"devDependencies\": {\n    \"express\": \"^4.18.1\"\n  }\n}\n</code></pre><ul><li>其中 devDependencies 是 npm install --save-dev 添加的</li></ul><p>编写 main.js 代码</p><pre><code class=\"language-js\">import express from \'express\'\nconst app = express()\n\napp.use(express.static(\'./\'))\napp.listen(7070)\n</code></pre><p>执行 js 代码（运行前端服务器）</p><pre><code >node main.js\n</code></pre><h3>前端案例</h3><p>初步效果</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220812103323220.png\" alt=\"image-20220812103323220\" data-href=\"\" style=\"\"/></p><p>架构</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220812103219916.png\" alt=\"image-20220812103219916\" data-href=\"\" style=\"\"/></p><ul><li>前端只有静态页面，使用 Express 服务器</li><li>后端使用 Tomcat 服务器，通过 SpringBoot、MyBatis 等框架获取数据库数据</li></ul><h4>1) 查找元素</h4><ul><li>document.getElementById - 根据 id 值查找一个元素</li><li>[document|元素].querySelector - 根据选择器查找第一个匹配元素</li><li>[document|元素].querySelectorAll - 根据选择器查找所有匹配元素</li></ul><p>例如，有下面的 html 代码</p><pre><code class=\"language-html\">&lt;div&gt;\n    &lt;div class=\"title\"&gt;学生列表&lt;/div&gt;\n    &lt;div class=\"thead\"&gt;\n        &lt;div class=\"row bold\"&gt;\n            &lt;div class=\"col\"&gt;编号&lt;/div&gt;\n            &lt;div class=\"col\"&gt;姓名&lt;/div&gt;\n            &lt;div class=\"col\"&gt;性别&lt;/div&gt;\n            &lt;div class=\"col\"&gt;年龄&lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=\"tbody\"&gt;\n        &lt;div class=\"row\"&gt;\n            &lt;div class=\"col\"&gt;1&lt;/div&gt;\n            &lt;div class=\"col\"&gt;张三&lt;/div&gt;\n            &lt;div class=\"col\"&gt;男&lt;/div&gt;\n            &lt;div class=\"col\"&gt;18&lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>执行</p><pre><code class=\"language-js\">document.querySelector(\'.title\'); // 找到 &lt;div class=\"title\"&gt;学生列表&lt;/div&gt;\n</code></pre><p>执行</p><pre><code class=\"language-js\">document.querySelector(\'.col\'); // 找到 &lt;div class=\"col\"&gt;编号&lt;/div&gt;\n</code></pre><p>执行</p><pre><code class=\"language-js\">document.querySelectorAll(\'.col\');\n\n/*\n  找到的是一个集合\n  &lt;div class=\"col\"&gt;编号&lt;/div&gt;\n  &lt;div class=\"col\"&gt;姓名&lt;/div&gt;\n  &lt;div class=\"col\"&gt;性别&lt;/div&gt;\n  &lt;div class=\"col\"&gt;年龄&lt;/div&gt;\n  &lt;div class=\"col\"&gt;1&lt;/div&gt;\n  &lt;div class=\"col\"&gt;张三&lt;/div&gt;\n  &lt;div class=\"col\"&gt;男&lt;/div&gt;\n  &lt;div class=\"col\"&gt;18&lt;/div&gt;\n*/\n</code></pre><p>执行</p><pre><code class=\"language-js\">const thead = document.querySelector(\'.thead\');\n\n// 只在 thead 元素范围内找\nthead.querySelectorAll(\'.col\');\n\n/*\n  找到的是一个集合\n  &lt;div class=\"col\"&gt;编号&lt;/div&gt;\n  &lt;div class=\"col\"&gt;姓名&lt;/div&gt;\n  &lt;div class=\"col\"&gt;性别&lt;/div&gt;\n  &lt;div class=\"col\"&gt;年龄&lt;/div&gt;\n*/\n</code></pre><p>根据 id 属性查找既可以用</p><pre><code class=\"language-js\">document.getElementById(\"id值\")\n</code></pre><p>也可以用 </p><pre><code class=\"language-js\">document.querySelector(\"#id值\")\n</code></pre><h4>2) 修改元素内容</h4><ul><li>元素.innerHTML</li><li>元素.textContent</li></ul><p>例如</p><pre><code class=\"language-js\">document.querySelector(\'.title\').innerHTML = \'侠客列表\'\n</code></pre><p>效果</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220812161003958.png\" alt=\"image-20220812161003958\" data-href=\"\" style=\"\"/></p><p>innerHTML &nbsp;会解析内容中的标签，例如</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220812161137912.png\" alt=\"image-20220812161137912\" data-href=\"\" style=\"\"/></p><p>textContext 不会解析内容中的标签</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220812161341825.png\" alt=\"image-20220812161341825\" data-href=\"\" style=\"\"/></p><p>给 innerHTML 或 textContent 赋值空串，可以实现清空标签内容的效果</p><h4>3) 利用模板</h4><pre><code class=\"language-html\">&lt;div&gt;\n    &lt;div class=\"title\"&gt;学生列表&lt;/div&gt;\n    &lt;div class=\"thead\"&gt;\n        &lt;div class=\"row bold\"&gt;\n            &lt;div class=\"col\"&gt;编号&lt;/div&gt;\n            &lt;div class=\"col\"&gt;姓名&lt;/div&gt;\n            &lt;div class=\"col\"&gt;性别&lt;/div&gt;\n            &lt;div class=\"col\"&gt;年龄&lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=\"tbody\"&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;template id=\"tp\"&gt;\n    &lt;div class=\"row\"&gt;\n        &lt;div class=\"col\"&gt;xx&lt;/div&gt;\n        &lt;div class=\"col\"&gt;xx&lt;/div&gt;\n        &lt;div class=\"col\"&gt;xx&lt;/div&gt;\n        &lt;div class=\"col\"&gt;xx&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n    // 将来这些数据从 java 端返回\n    let array = [\n        { id: 1, name: \'张三\', sex: \'男\', age: 18 },\n        { id: 2, name: \'李四\', sex: \'女\', age: 17 }\n    ];\n\n    const tp = document.getElementById(\"tp\");\n    const row = tp.content;\n    const [c1,c2,c3,c4] = row.querySelectorAll(\".col\");\n    const tbody = document.querySelector(\'.tbody\');\n    for(const {id,name,sex,age} of array) {\n        c1.textContent = id;\n        c2.textContent = name;\n        c3.textContent = sex;\n        c4.textContent = age;\n        // 复制元素\n        const newRow = document.importNode(row, true);\n        // 建立父子关系，左边父，右边子\n        tbody.appendChild(newRow);\n    }\n&lt;/script&gt;\n</code></pre><h4>4) Fetch API</h4><p>Fetch API 可以用来获取远程数据，它有两种方式接收结果，同步方式与异步方式</p><p>格式</p><pre><code class=\"language-js\">fetch(url, options) // 返回 Promise\n</code></pre><p>同步方式</p><pre><code class=\"language-js\">const 结果 = await Promise\n// 后续代码\n</code></pre><ul><li>await 关键字必须在一个标记了 async 的 function 内来使用</li><li>后续代码不会在结果返回前执行</li></ul><p>异步方式</p><pre><code class=\"language-js\">Promise\n    .then(结果 =&gt; { ... })\n// 后续代码                 \n</code></pre><ul><li>后续代码不必等待结果返回就可以执行</li></ul><p>例：</p><p>在 express 服务器上有 students.json 文件</p><pre><code class=\"language-json\">[\n    { \"id\": 1, \"name\": \"张三\", \"sex\": \"男\", \"age\": 18 },\n    { \"id\": 2, \"name\": \"李四\", \"sex\": \"女\", \"age\": 17 }\n]\n</code></pre><p>现在用 fetch api 获取这些数据，并展示</p><p>同步方式</p><pre><code class=\"language-html\">&lt;script&gt;\n    async function findStudents() {\n        try {\n            // 获取响应对象\n            const resp = await fetch(\'students.json\')\n\n            // 获取响应体, 按json格式转换为js数组\n            const array = await resp.json();\n\n            // 显示数据\n            const tp = document.getElementById(\"tp\");\n            const row = tp.content;\n            const [c1,c2,c3,c4] = row.querySelectorAll(\".col\");\n            const tbody = document.querySelector(\'.tbody\');\n            for(const {id,name,sex,age} of array) {\n                c1.textContent = id;\n                c2.textContent = name;\n                c3.textContent = sex;\n                c4.textContent = age;\n                // 复制元素\n                const newRow = document.importNode(row, true);\n                // 建立父子关系\n                tbody.appendChild(newRow);\n            }\n        } catch (e) {\n            console.log(e);\n        }\n\n    }\n    findStudents()\n&lt;/script&gt;\n</code></pre><ul><li>fetch(\'students.json\') 内部会发送请求，但响应结果不能立刻返回，因此 await 就是等待响应结果返回</li><li>其中 resp.json() 也不是立刻能返回结果，它返回的也是 Promise 对象，也要配合 await 取结果</li></ul><p>异步方式</p><pre><code class=\"language-html\">&lt;script&gt;\n    fetch(\'students.json\')\n        .then( resp =&gt; resp.json() )\n        .then( array =&gt; {\n            // 显示数据\n            const tp = document.getElementById(\"tp\");\n            const row = tp.content;\n            const [c1,c2,c3,c4] = row.querySelectorAll(\".col\");\n            const tbody = document.querySelector(\'.tbody\');\n            for(const {id,name,sex,age} of array) {\n                c1.textContent = id;\n                c2.textContent = name;\n                c3.textContent = sex;\n                c4.textContent = age;\n                // 复制元素\n                const newRow = document.importNode(row, true);\n                // 建立父子关系\n                tbody.appendChild(newRow);\n            }\n        })\n        .catch( e =&gt; console.log(e) )\n\n\n&lt;/script&gt;\n</code></pre><ul><li>第一个 then 是在响应返回后，才会调用它里面的箭头函数，箭头函数参数即 resp &nbsp;响应对象</li><li>第二个 then 是在 json 解析完成后，才会调用它里面的箭头函数，箭头函数参数即解析结果（本例是 array 数组）</li><li>上一个 then 返回的是 Promise 对象时，才能链式调用下一个 then</li></ul><h5>跨域问题</h5><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220814105448882.png\" alt=\"image-20220814105448882\" data-href=\"\" style=\"\"/></p><ul><li>只要协议、主机、端口之一不同，就不同源，例如</li><li>同源检查是浏览器的行为，而且只针对 fetch、xhr 请求</li><li>更多相关知识请参考</li></ul><p>请求响应头解决</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220814144040703.png\" alt=\"image-20220814144040703\" data-href=\"\" style=\"\"/></p><ul><li>fetch 请求跨域，会携带一个 Origin 头，代表【发请求的资源源自何处】，目标通过它就能辨别是否发生跨域</li><li>目标资源通过返回 Access-Control-Allow-Origin 头，告诉浏览器【允许哪些源使用此响应】</li></ul><p>代理解决</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220814161532141.png\" alt=\"image-20220814161532141\" data-href=\"\" style=\"\"/></p><pre><code class=\"language-cmd\">npm install http-proxy-middleware --save-dev\n</code></pre><p>在 express 服务器启动代码中加入</p><pre><code class=\"language-js\">import {createProxyMiddleware} from \'http-proxy-middleware\'\n\n// ...\n\napp.use(\'/api\', createProxyMiddleware({ target: \'http://localhost:8080\', changeOrigin: true }));\n</code></pre><p>fetch 代码改为</p><pre><code class=\"language-js\">const resp = await fetch(\'http://localhost:7070/api/students\')\n</code></pre><p>或</p><pre><code class=\"language-js\">const resp = await fetch(\'/api/students\')\n</code></pre><h4>5) 模块化</h4><p>单个导出 const、let、function</p><pre><code class=\"language-js\">export const a = 10;\nexport let b = 20;\nexport function c() {\n    console.log(\'c\');\n}\n</code></pre><p>一齐导出</p><pre><code class=\"language-js\">const a = 10;\nlet b = 20;\nfunction c() {\n    console.log(\'c\')\n}\n\nexport {a,b,c}\n</code></pre><p>导出 default，只能有一个</p><pre><code class=\"language-js\">export const a = 10;\nexport let b = 20;\nexport function c() {\n    console.log(\'c\')\n}\n\nexport default b;\n</code></pre><p>import 语法</p><pre><code class=\"language-html\">&lt;script type=\"module\"&gt;\n    import 语句\n&lt;/script&gt;\n</code></pre><ul><li>import 需要遵循同源策略</li></ul><p>整个导入</p><pre><code class=\"language-js\">import * as module from \'/1.js\'\nconsole.log(module.a)		// 输出10\nconsole.log(module.b)		// 输出20\nmodule.c()					// 输出c\n</code></pre><p>单个导入</p><pre><code class=\"language-js\">import {a,c} from \'/1.js\'\nconsole.log(a)				// 输出10\nc()							// 输出c\n</code></pre><p>导入默认</p><pre><code class=\"language-js\">import x from \'/1.js\'\nconsole.log(x)				// 输出20\n</code></pre><p><br></p>', '林志杰', '1626518508932235265', 1, 2, 1, '2023-05-17 17:38:01.972', '2023-05-31 00:00:00.050');
INSERT INTO `blog` VALUES ('96bfa343e1030661cd9c3ecd7cd31769', 'ssm', 'http://rt6vvz8xh.bkt.clouddn.com/blogFile/1629495477589856258/b219ebc4b74543a9e3e0ca386c1dac8eb8011464.webp', '“博客”当然是个大家都陌生的名词,博客的英文名词就是“Blog或Weblog”(指人时对应于Blogger),是一个典型的网络新事物,查阅最新的英文词典也不可能查到', '啥计划的大啊啊所多', '林志杰', '1626518508932235265', 0, 0, 0, '2023-03-20 05:30:40.215', '2023-05-17 00:00:00.178');
INSERT INTO `blog` VALUES ('9f10cbac98bd7acde9a0f75e05448c91', 'java', 'http://rt6vvz8xh.bkt.clouddn.com/blogFile/1629495477589856258/b219ebc4b74543a9e3e0ca386c1dac8eb8011464.webp', '“博客”当然是个大家都陌生的名词,博客的英文名词就是“Blog或Weblog”(指人时对应于Blogger),是一个典型的网络新事物,查阅最新的英文词典也不可能查到', '啥计划的大啊啊所多', '林志杰', '1626518508932235265', 0, 0, 0, '2023-03-20 05:30:19.887', '2023-05-15 00:00:00.103');
INSERT INTO `blog` VALUES ('a12f4e878af027f9e6e2b6dcaf508762', '可适当', 'http://rusndkp3v.bkt.clouddn.com/blogFile/1629495477589856258/html.jpg', '睡大街拉德斯基', '<h1>MongoDB</h1><h3>概念</h3><table style=\"width: auto;\"><tbody><tr><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">SQL术语</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">MongoDB术语</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">解释</th></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">database</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">database</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">数据库</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">table</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">collection</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">数据库表/集合</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">row</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">document</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">数据记录行/文档</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">column</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">field</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">数据字段/域</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">index</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">index</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">索引</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">table joins</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\"></td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">表连接</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">primary</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">primary</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">主键</td></tr></tbody></table><h5>数据类型</h5><table style=\"width: auto;\"><tbody><tr><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">数据类型</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">描述</th></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">String</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">字符串.存储数据常用的数据类型,UTF-8在mongodb中才是合法的</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Integer</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">整型数值.用于存储数值.根据服务器,分为32和64位.</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Boolean</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">布尔值</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Double</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">双精度浮点值</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Min/Max keys</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">将一个值与BSON(二进制的JSON)元素的最低值和最高值相对比</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Array</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">用于将数组或列表或多个值存储为一个键</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Timestamp</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">时间戳</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Object</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">用于内嵌文档</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Symbol</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">符号.该数据类型基本上等同于字符串类型.</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Date</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">日期时间</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Object ID</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">对象ID</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Binary Data</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">二进制数据</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Code</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">代码类型</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Regular expression</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">正则表达式类型</td></tr></tbody></table><ol><li>ObjectId 类似唯一主键,一共12个字节 前4个字节表示创建unix时间戳 3个字节是机器标识码 两个字节由进程id组成PID 最后三个字节是随机数</li><li>时间戳 64位的值 前32位是一个time_t值 后32秒是在某秒钟操作的一个递增的序数</li><li>日期 表示当前距离Unix新纪元的毫秒值.日期类型是有符号的,负数表示1970年之前的日期.</li></ol><h5>MongDB连接</h5><p>连接语法:</p><pre><code class=\"language-MongoDB\">mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]\n</code></pre><ul><li>mongodb:// 固定格式</li><li>username:password@ 可选项,如果设置,在连接这个数据库服务器之后,驱动都会尝试登录这个数据库</li><li>host1 必须指定一个host</li><li>portX 可选的指定端口,默认27017</li><li>/database 默认test库</li><li>?option 连接选项</li></ul><h3>数据库</h3><h5>创建数据库</h5><pre><code class=\"language-javascript\">use blog //如果数据库不存在则创建数据库,存在则切换\nshow dbs //展示所有数据库\n</code></pre><h5>删除数据库</h5><pre><code class=\"language-js\">db.dropDatabase() //删除数据库\ndb.collection.drop()//删除集合 collection代表集合名\n</code></pre><h3>集合</h3><h5>创建集合</h5><pre><code class=\"language-js\">db.createCollection(name, options)//创建集合\ndb.blog.insert({\"name\" : \"博客\"})//直接插入文档不需要创建集合\nshow collections//查看集合\n</code></pre><h5>删除集合</h5><pre><code class=\"language-js\">db.blog.drop()//删除blog集合\n</code></pre><h3>文档</h3><h5>插入文档</h5><pre><code class=\"language-js\">db.blog.insert({\"name\":\"博客\",\"author\":\"作者\"})//插入博客文档\ndb.blog.save({\"name\":\"博客\",\"author\":\"作者\"})//已弃用 用db.collection.insertOne() 或 db.collection.replaceOne() 代替\ndocument=({title: \'博客\', \n    description: \'博客\',\n    by: \'plumoon\'\n});//保存为变量再插入集合中\n</code></pre><h5>更新文档</h5><pre><code class=\"language-js\">db.blog.update({\"name\":\"博客\"},{$set:{\"name\":\"MongoDB\"}})//更新文档\ndb.blog.update({\"author\":\"作者\"},{$set:{\"name\":\"Mongo\"}},{multi:true})//批量更新\n</code></pre><h5>删除文档</h5><pre><code class=\"language-js\">db.blog.remove({\"name\":\"博客\"})//删除文档\ndb.blog.remove({\"name\":\"博客\"},1)//只删除第一条\ndb.blog.remove({})//删除所有数据\n</code></pre><h5>查询文档</h5><pre><code class=\"language-js\">db.blog.find({key1:value1, key2:value2}).pretty()//and查询\ndb.col.find({$or: [{key1: value1}, {key2:value2}]}).pretty()//OR查询\n</code></pre><h3>操作符</h3><ul><li>(&gt;) 大于 - $gt</li><li>(&lt;) 小于 - $lt</li><li>(&gt;=) 大于等于 - $gte</li><li>(&lt;= ) 小于等于 - $lte</li></ul><pre><code >db.blog.find({\"name\" : {$type : 2}})\n或\ndb.blog.find({\"name\" : {$type : \'string\'}})//根据字段类型查询\n</code></pre><table style=\"width: auto;\"><tbody><tr><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">类型</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">数字</th></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Double</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">1</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">String</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">2</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Object</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">3</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Array</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">4</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Binary data</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">5</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Undefined</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">6</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Object id</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">7</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Boolean</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">8</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Date</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">9</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Null</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">10</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Regular Expression</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">11</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">JavaScript</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">15</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">32-bit integer</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">16</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Timestamp</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">17</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">64-bit integer</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">18</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Min key</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">255</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Max key</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">127</td></tr></tbody></table><h3>Limit与Skip方法</h3><pre><code class=\"language-js\">db.blog.find().limit(2)//查找两条数据\ndb.blog.find().limit(2).skip(1)//跳过一条数据查找两条数据\n</code></pre><h3>排序</h3><pre><code class=\"language-js\">db.blog.find().sort({KEY:1})//sort()方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。\n</code></pre><h3>索引</h3><pre><code >db.blog.createIndex(keys, options)//\n</code></pre><table style=\"width: auto;\"><tbody><tr><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Parameter</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">type</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Description</th></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">background</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Boolean</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 \"background\" 可选参数。 \"background\" 默认值为<strong>false</strong>。</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">unique</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Boolean</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">建立的索引是否唯一.指定为true创建唯一索引.默认值为false</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">name</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">String</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">索引的名称.如果未指定,MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">sparse</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Boolean</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">对文档中不存在的字段数据不启用索引;这个参数需要特别注意,如果设置为true的话,在索引字段中不会查询包含对应字段的文档.默认值为false.</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">expireAfterSeconds</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">integer</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">指定一个以秒为单位的数值,完成TTl设定,设定集合的生存时间</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">V</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">index version</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">索引的版本号.默认的索引版本取决于mongod创建索引时运行的版本.</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">weights</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">document</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">索引权重值,数值1到99999之间,表示索引相对于其他索引字段的得分权重</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">default_language</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">String</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">对于文本索引,该参数决定了停用词及词干和词器的规则的列表.默认为英语</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">language_override</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">string</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">对于文本索引,该参数指定了包含在文档中的字段名,语言覆盖默认的language,默认值为language</td></tr></tbody></table><h3>聚合</h3><p>aggregate()</p><pre><code class=\"language-js\">db.blog.aggregate(AGGREGATE_OPERATION)\n</code></pre><p>likes代表对应值</p><table style=\"width: auto;\"><tbody><tr><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">表达式</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">描述</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">实例</th></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">$sum</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">计算总和</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">db.blog.aggregate([{$group:{_id:\"$name\",num_tutorial:{$sum:\"$likes\"}}}])</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">$avg</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">计算平均值</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">db.blog.aggregate([{$group : {_id : \"$name\", num_tutorial :{$avg:\"$likes\"}}}])</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">$min</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">获取集合中所有文档对应值得最小值.</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">db.blog.aggregate([{$group : {_id : \"$name\", num_tutorial :{$min : \"$likes\"}}}])</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">$max</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">获取集合中所有文档对应值得最大值.</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">db.blog.aggregate([{$group : {_id : \"$name\", num_tutorial : {$max : \"$likes\"}}}])</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">$push</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">将值加入一个数组中，不会判断是否有重复的值。</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">db.blog.aggregate([{$group : {_id : \"$name\", url : {$push: \"$url\"}}}])</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">$addToSet</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">将值加入一个数组中，会判断是否有重复的值，若相同的值在数组中已经存在了，则不加入。</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">db.blog.aggregate([{$group : {_id : \"$name\", url : {$addToSet : \"$url\"}}}])</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">$first</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">根据资源文档的排序获取第一个文档数据。</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">db.blog.aggregate([{$group : {_id : \"$name\", first_url : {$first : \"$url\"}}}])</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">$last</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">根据资源文档的排序获取最后一个文档数据</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">db.blog.aggregate([{$group : {_id : \"$name\", last_url : {$last : \"$url\"}}}])</td></tr></tbody></table><h5>管道</h5><ul><li>$project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 db.blog.aggregate({ $project : {name : 1 ,author : 1}});</li><li>$match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。 db.blog.aggregate([{$match:{x:{$gt:11,$lte:13}}}]);</li><li>$limit：用来限制MongoDB聚合管道返回的文档数。 db.blog.aggregate({$limit:2});</li><li>$skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。 db.blog.aggregate({$skip:2});</li><li>$unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</li><li>$group：将集合中的文档分组，可用于统计结果。</li><li>$sort：将输入文档排序后输出。</li><li>$geoNear：输出接近某一地理位置的有序文档。</li></ul><h3>用户管理</h3><pre><code >db.createUser({ user: \"plumoon\", pwd: \"lzj439949\", roles: [{ role: \"userAdminAnyDatabase\", db: \"admin\" }] })//创建管理员账号\ndb.createUser({user: \"root\",pwd: \"lzj439949\", roles: [ { role: \"root\", db: \"admin\" } ]})//创建root账号\ndb.createUser({user: \"blog\",pwd: \"lzj439949\",roles: [ { role: \"dbOwner\", db: \"blog\" } ]})//创建自己数据库的账号\nshow users//查看用户\ndb.auth(\"admin\",\"password\")//删除用户\ndb.system.users.remove({user:\"XXXXXX\"})//删除单个用户\ndb.system.users.remove({})//\n</code></pre><p><br></p>', '林志杰', '1626518508932235265', 0, 0, 1, '2023-05-24 10:38:51.912', '2023-05-31 00:00:00.051');
INSERT INTO `blog` VALUES ('a7284b4fb1f59b03336bd2cb38eb9a6c', '10_Java程序员要掌握的前端vue3', 'http://rusndkp3v.bkt.clouddn.com/blogFile/1629495477589856258/vue3.webp', 'vue3', '<h1>四. Vue 3</h1><h2>1. TypeScript</h2><h3>1) 动态类型的问题</h3><p>前面我们讲过 js 属于动态类型语言，例如</p><pre><code class=\"language-js\">function test(obj) {    \n}\n</code></pre><p>obj 可能只是个字符串</p><pre><code class=\"language-js\">test(\'hello, world\')\n</code></pre><p>obj 也有可能是个函数</p><pre><code class=\"language-js\">test(()=&gt;console.log(\'hello, world\'))\n</code></pre><p>obj 类型不确定，就给后期使用者带来了麻烦，一旦参数传不对，代码就崩溃了</p><p>动态类型意味着</p><ul><li>运行代码时才知道发生什么 (running the code to see what happens)</li></ul><p>静态类型意味着</p><ul><li>在代码运行前，就对它的行为做出预测 (make predications about what code is expected before it runs)</li></ul><p>下面的 typescript 代码，就在代码运行前对参数加入了约束限制</p><pre><code class=\"language-typescript\">function test(msg : string) {\n}\n</code></pre><ul><li>限制了参数只能做 string 那些事</li></ul><pre><code class=\"language-typescript\">function test(msg : Function) {\n  msg()\n}\n</code></pre><ul><li>限制了参数只能做函数那些事</li></ul><h3>2) 入门</h3><p>安装 typescript 编译器</p><pre><code class=\"language-cmd\">npm install -g typescript\n</code></pre><p>编写 ts 代码</p><pre><code class=\"language-typescript\">function hello(msg: string) {\n  console.log(msg)\n}\n\nhello(\'hello,world\')\n</code></pre><p>执行 tsc 编译命令</p><pre><code class=\"language-cmd\">tsc xxx.ts\n</code></pre><p>编译生成 js 代码，编译后进行了类型擦除</p><pre><code class=\"language-js\">function hello(msg) {\n    console.log(msg);\n}\nhello(\'hello,world\');\n</code></pre><p>再来一个例子，用 interface 定义用户类型</p><pre><code class=\"language-ts\">interface User {\n  name: string,\n  age: number\n}\n\nfunction test(u: User): void {\n  console.log(u.name)\n  console.log(u.age)\n}\n\ntest({ name: \'zhangs\', age: 18 })\n</code></pre><p>编译后</p><pre><code class=\"language-js\">function test(u) {\n    console.log(u.name);\n    console.log(u.age);\n}\ntest({ name: \'zhangs\', age: 18 });\n</code></pre><p>可见，typescript 属于编译时实施类型检查（静态类型）的技术</p><h3>3) 类型</h3><table style=\"width: auto;\"><tbody><tr><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">类型</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">例</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">备注</th></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">字符串类型</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">string</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\"></td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">数字类型</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">number</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\"></td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">布尔类型</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">boolean</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\"></td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">数组类型</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">number[],string[], boolean[] 依此类推</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\"></td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">任意类型</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">any</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">相当于又回到了没有类型的时代</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">复杂类型</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">type 与 interface</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\"></td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">函数类型</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">() =&gt; void</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">对函数的参数和返回值进行说明</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">字面量类型</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">\"a\"|\"b\"|\"c\"</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">限制变量或参数的取值</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">nullish类型</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">null 与 undefined</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\"></td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">泛型</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\"><code>&lt;T&gt;</code>，<code>&lt;T extends 父类型&gt;</code></td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\"></td></tr></tbody></table><h4>标注位置</h4><h5>标注变量</h5><pre><code class=\"language-typescript\">let message: string = \'hello,world\'\n</code></pre><ul><li>一般可以省略，因为可以根据后面的字面量推断出前面变量类型</li></ul><pre><code class=\"language-typescript\">let message = \'hello,world\'\n</code></pre><h5>标注参数</h5><pre><code class=\"language-typescript\">function greet(name: string) {\n    \n}\n</code></pre><p>很多时候，都能够推断出参数类型</p><pre><code class=\"language-typescript\">const names = [\'Alice\', \'Bob\', \'Eve\']\nconst lowercaseNames = names.map((e: string) =&gt; e.toLowerCase())\n</code></pre><ul><li>可以用类型推断，推断出 e 是 string 类型</li></ul><h5>标注返回值</h5><pre><code class=\"language-typescript\">function add(a: number, b: number) : number {\n    return a + b\n}\n</code></pre><ul><li>一般也可以省略，因为可以根据返回值做类型推断</li></ul><h4>复杂类型</h4><h5>type</h5><pre><code class=\"language-typescript\">type Cat = {\n  name: string,\n  age: number\n}\n\nconst c1: Cat = { name: \'小白\', age: 1 }\nconst c2: Cat = { name: \'小花\' }					  // 错误: 缺少 age 属性\nconst c3: Cat = { name: \'小黑\', age: 1, sex: \'公\' } // 错误: 多出 sex 属性\n</code></pre><h5>interface</h5><pre><code class=\"language-typescript\">interface Cat {\n  name: string,\n  age: number\n}\n\nconst c1: Cat = { name: \'小白\', age: 1 }\nconst c2: Cat = { name: \'小花\' }					  // 错误: 缺少 age 属性\nconst c3: Cat = { name: \'小黑\', age: 1, sex: \'公\' } // 错误: 多出 sex 属性\n</code></pre><h5>可选属性</h5><p>如果需要某个属性可选，可以用下面的语法</p><pre><code class=\"language-typescript\">interface Cat {\n  name: string,\n  age?: number\n}\n\nconst c1: Cat = { name: \'小白\', age: 1 }\nconst c2: Cat = { name: \'小花\' }					  // 正确: age 属性可选\n</code></pre><ul><li>可选属性要注意处理 undefined 值</li></ul><h5>鸭子类型</h5><pre><code class=\"language-typescript\">interface Cat {\n  name: string\n}\n\nfunction test(cat: Cat) {\n  console.log(cat.name)\n}\n\nconst c1 = { name: \'小白\', age: 1 } \ntest(c1)\n</code></pre><ul><li>const c1 并没有声明类型为 Cat，但它与 Cat 类型有一样的属性，也可以被当作是 Cat 类型</li></ul><h4>方法类型</h4><pre><code class=\"language-typescript\">interface Api {\n  foo(): void,\n  bar(str: string): string\n}\n\nfunction test(api: Api) {\n  api.foo()\n  console.log(api.bar(\'hello\'))\n}\n\ntest({\n  foo() { console.log(\'ok\') },\n  bar(str: string) { return str.toUpperCase() }\n})\n</code></pre><h4>字面量类型</h4><pre><code class=\"language-typescript\">function printText(s: string, alignment: \"left\" | \"right\" | \"center\") {\n  console.log(s, alignment)\n}\n\nprintText(\'hello\', \'left\')\nprintText(\'hello\', \'aaa\') // 错误: 取值只能是 left | right | center\n</code></pre><h4>nullish 类型</h4><pre><code class=\"language-typescript\">function test(x?: string | null) {\n  console.log(x?.toUpperCase())\n}\n\ntest(\'aaa\')\ntest(null)\ntest()\n</code></pre><ul><li>x?: string | null 表示可能是 undefined 或者是 string 或者是 null</li></ul><h4>泛型</h4><p>下面的几个类型声明显然有一定的相似性</p><pre><code class=\"language-typescript\">interface RefString {\n  value: string\n}\n\ninterface RefNumber {\n  value: number\n}\n\ninterface RefBoolean {\n  value: boolean\n}\n\nconst r1: RefString = { value: \'hello\' }\nconst r2: RefNumber = { value: 123 }\nconst r3: RefBoolean = { value: true }\n</code></pre><p>可以改进为</p><pre><code class=\"language-typescript\">interface Ref&lt;T&gt; {\n  value: T\n}\n\nconst r1: Ref&lt;string&gt; = { value: \'hello\' }\nconst r2: Ref&lt;number&gt; = { value: 123 }\nconst r3: Ref&lt;boolean&gt; = { value: true }\n</code></pre><ul><li>泛型的要点就是 <code>&lt;类型参数&gt;</code>，把【类型】也当作一个变化的要素，像参数一样传递过来，这样就可以派生出结构相似的新类型</li></ul><p>函数定义也支持泛型</p><pre><code class=\"language-typescript\">function ref&lt;T&gt;(n: T): Ref&lt;T&gt; {\n  return { value: n }\n}\n\nconst v1 = ref(\"hello\"); 	// Ref&lt;string&gt;\nconst v2 = ref(123.3333);	// Ref&lt;number&gt;\n\nv1.value.toLocaleLowerCase()\nv2.value.toFixed(2)\n</code></pre><h3>4) 意义</h3><h4>更好理解框架</h4><p>现在越来越多的前端框架采用 typescript，如果懂 typescript 语法，可以更好地阅读框架代码</p><p>以 Map 为例</p><pre><code class=\"language-typescript\">const map = new Map&lt;string, string&gt;()\nmap\n  .set(\"a\", \"b\")\n  .set(\"c\", \"d\")\n\nmap.forEach((value,key,m)=&gt;{\n  console.log(value, key)\n})\n</code></pre><ul><li>注意编译需要 <code>tsc --target es6 .\\xxx.ts</code></li></ul><h4>更好的提示</h4><p>例如，从服务器返回的一段 json，如果不用 typescript，则编辑器也不能给出准确的提示</p><pre><code class=\"language-typescript\">interface User {\n  name: string,\n  age: number\n}\n\nconst user: User = JSON.parse(`{ \"name\":\"张三\", \"age\":18 }`)\n</code></pre><h3>5) 类</h3><blockquote>关于 TypeScript 与 JavaScript 中的类语法不是重点，class 相关语法只是起到辅助作用，更重要的是前面讲的 interface</blockquote><h4>基本语法</h4><pre><code class=\"language-typescript\">class User {\n    name: string;\n    \n    constructor(name: string) {\n        this.name = name\n    }\n}\n\nconst u = new User(\'张三\')\n</code></pre><p>其实会被编译成这个样子（默认 --target=es3）</p><pre><code class=\"language-js\">var User = /** @class */ (function () {\n    function User(name) {\n        this.name = name;\n    }\n    return User;\n}());\nvar u = new User(\'张三\');\n</code></pre><p>所以 js 中的 class，并不等价于 java 中的 class，它还是基于原型实现的，原理参考第二章（036、037）</p><h4>只读属性</h4><pre><code class=\"language-typescript\">class User {\n  readonly name: string;\n  \n  constructor(name: string) {\n      this.name = name\n  }\n}\n\nconst u = new User(\'张三\')\nu.name = \'李四\'				// 编译错误\n</code></pre><ul><li>readonly 是 typescript 特有的，表示该属性只读</li></ul><h4>方法</h4><pre><code class=\"language-typescript\">class User {\n  readonly name: string;\n  \n  constructor(name: string) {\n      this.name = name\n  }\n\n  study() {\n    console.log(`[${this.name}]正在学习`)\n  }\n}\n\nconst u = new User(\'张三\')\nu.study()\n</code></pre><h4>get，set</h4><pre><code class=\"language-typescript\">class User {\n  _name: string;\n\n  constructor(name: string) {\n    this._name = name\n  }\n\n  get name() {\n    return this._name\n  }\n\n  set name(name: string) {\n    this._name = name\n  }\n}\n\nconst u = new User(\'张三\')\nconsole.log(u.name)\nu.name = \'李四\'\nconsole.log(u.name)\n</code></pre><ul><li>注意，需要在编译时加上 <code>tsc --target es6 .\\xxx.ts</code> 选项</li><li>es6 等价于 es2015，再此之上还有 es2016 ... es2022</li></ul><h4>类与接口</h4><pre><code class=\"language-typescript\">interface User {\n  name: string\n  study(course: string): void\n}\n\nclass UserImpl implements User {\n  name: string;\n  constructor(name: string) {\n    this.name = name\n  }\n  study(course: string) {\n    console.log(`[${this.name}]正在学习[${course}]`)\n  }\n  foo() { }\n}\n\nconst user: User = new UserImpl(\'张三\')\nuser.study(\'Typescript\')\nuser.foo() // 错误，必须是接口中定义的方法\n</code></pre><h4>继承与接口</h4><pre><code class=\"language-typescript\">interface Flyable {\n  fly(): void\n}\n\nclass Animal {\n  name: string;\n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nclass Bird extends Animal implements Flyable {\n  fly() {\n    console.log(`${this.name}在飞翔`)\n  }\n}\n\nconst b: Flyable & Animal = new Bird(\"小花\")\nb.fly()\n</code></pre><ul><li>Flyable & Animal 表示变量是 flyable 类型，同时也是 Animal 类型</li></ul><h4>方法重写</h4><pre><code class=\"language-typescript\">class Father {\n  study(): void {\n    console.log(`father study`)\n  }\n}\n\nclass Son extends Father {  \n  study(): void {\n    super.study()\n    console.log(`son study`)\n  }\n}\n\nconst f: Father = new Son()\nf.study()\n</code></pre><h2>2. Vue3 基础</h2><p>技术选型</p><ul><li>Vue </li><li>语法</li><li>构建工具</li><li>路由</li><li>共享存储</li><li>视图组件</li></ul><h3>1) 环境准备</h3><h4>创建项目</h4><p>采用 vite 作为前端项目的打包，构建工具</p><pre><code class=\"language-cmd\">npm init vite@latest\n</code></pre><p>按提示操作</p><pre><code class=\"language-cmd\">cd 项目目录\nnpm install\nnpm run dev\n</code></pre><h4>编码 IDE</h4><p>推荐采用微软的 VSCode 作为开发工具，到它的官网 <a href=\"https://code.visualstudio.com/\" target=\"\">Visual Studio Code - Code Editing. Redefined</a> 下载安装即可</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220911090418621.png\" alt=\"image-20220911090418621\" data-href=\"\" style=\"\"/></p><p>要对 *.vue 做语法支持，还要安装一个 Volar 插件</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220911090756694.png\" alt=\"image-20220911090756694\" data-href=\"\" style=\"\"/></p><h4>安装 devtools</h4><ul><li>devtools 插件网址：<a href=\"https://devtools.vuejs.org/guide/installation.html\" target=\"\">https://devtools.vuejs.org/guide/installation.html</a></li></ul><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220815141648040.png\" alt=\"image-20220815141648040\" data-href=\"\" style=\"\"/></p><h4>修改端口</h4><p>打开项目根目录下 vite.config.ts</p><pre><code class=\"language-typescript\">import { defineConfig } from \'vite\'\nimport vue from \'@vitejs/plugin-vue\'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [vue()],\n  server: {\n    port: 7070\n  }\n})\n</code></pre><ul><li>文档地址：<a href=\"https://vitejs.cn/config/#server-port\" target=\"\">配置 Vite {#configuring-vite} | Vite中文网 (vitejs.cn)</a></li></ul><h4>配置代理</h4><p>为了避免前后端服务器联调时， fetch、xhr 请求产生跨域问题，需要配置代理，同样是修改项目根目录下 vite.config.ts</p><pre><code class=\"language-typescript\">import { defineConfig } from \'vite\'\nimport vue from \'@vitejs/plugin-vue\'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [vue()],\n  server: {\n    port: 7070,\n    proxy: {\n      \'/api\': {\n        target: \'http://localhost:8080\',\n        changeOrigin: true\n      }\n    }\n  }\n})\n</code></pre><ul><li>文档地址：<a href=\"https://vitejs.cn/config/#server-proxy\" target=\"\">配置 Vite {#configuring-vite} | Vite中文网 (vitejs.cn)</a></li></ul><h4>项目结构</h4><pre><code >index.html\npackage.json\ntsconfig.json\nvite.config.ts\n├─public\n└─src\n    ├─assets\n    ├─components\n    ├─model\n    ├─router\n    ├─store\n    └─views\n</code></pre><ul><li>index.html 为主页面</li><li>package.json npm 配置文件</li><li>tsconfig.json typescript 配置文件</li><li>vite.config.ts vite 配置文件</li><li>public 静态资源</li><li>src/components 可重用组件</li><li>src/model 模型定义</li><li>src/router 路由</li><li>src/store 共享存储</li><li>src/views 视图组件</li></ul><h3>2) Vue 组件</h3><p>Vue 的组件文件以 .vue 结尾，每个组件由三部分组成</p><pre><code class=\"language-vue\">&lt;script setup lang=\"ts\"&gt;&lt;/script&gt;\n\n&lt;template&gt;&lt;/template&gt;\n\n&lt;style scoped&gt;&lt;/style&gt;\n</code></pre><ul><li>script 代码部分，控制模板的数据来源和行为</li><li>template 模板部分，由它生成 html 代码</li><li>style 样式部分，一般不咋关心</li></ul><p>根组件是 src/App.vue，先来个 Hello,world 例子</p><pre><code class=\"language-vue\">&lt;script setup lang=\"ts\"&gt;\nimport { ref } from \"vue\";\nlet msg = ref(\"hello\"); // 把数据变成响应式的\n\nfunction change() {\n  msg.value = \"world\";\n  console.log(msg);\n}\n&lt;/script&gt;\n&lt;template&gt;\n  &lt;h1&gt;{{ msg }}&lt;/h1&gt;\n  &lt;input type=\"button\" value=\"修改msg\" @click=\"change\" /&gt;\n&lt;/template&gt;\n</code></pre><ul><li>{{msg}} 用来把一个变量绑定到页面上某个位置</li><li>绑定的变量必须用 ref 函数来封装</li></ul><h4>main.ts</h4><pre><code class=\"language-typescript\">import { createApp } from \'vue\'\nimport \'./style.css\'\nimport App from \'./App.vue\'\n\ncreateApp(App)\n  .mount(\'#app\')\n</code></pre><ul><li>createApp 是创建一个 Vue 应用程序，它接收的参数 App 即之前我们看到的根组件</li><li>mount 就是把根组件生成的 html 代码片段【挂载】到 index.html 中 id 为 app 的 html 元素上</li></ul><p>可以修改自己的组件文件，挂载到主页面</p><p>新建 src/views/E0.vue，内容如下</p><pre><code class=\"language-vue\">&lt;script setup lang=\"ts\"&gt;\nimport { ref } from \'vue\'\nconst msg = ref(\'Hello, World!!\')\n&lt;/script&gt;\n&lt;template&gt;\n  &lt;h1&gt;{{ msg }}&lt;/h1&gt;\n&lt;/template&gt;\n</code></pre><p>修改 main.ts 将自己的组件文件挂载</p><pre><code class=\"language-typescript\">import { createApp } from \'vue\'\nimport \'./style.css\'\n// import App from \'./App.vue\'\nimport E0 from \'./views/E0.vue\'\n\ncreateApp(E0).mount(\'#app\')\n</code></pre><ul><li>以后我们用这样的方式演示课堂案例</li></ul><p>打开浏览器控制台，进入 Vue 的开发工具，尝试做如下修改</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220906141650435.png\" alt=\"image-20220906141650435\" data-href=\"\" style=\"\"/></p><p>当把 msg 的值由 \"Hello, World\" 改为 \"你好\" 时，会发现页面展示同步发生了变化</p><h4>ref 与 reactive</h4><p>vue 提供了两个函数，都可以将数据变为【响应式】的</p><pre><code class=\"language-vue\">&lt;script setup lang=\"ts\"&gt;\nimport { ref, reactive } from \'vue\'\nconst msg = ref(\'Hello, World\')\nconst user = reactive({ name: \'张三\' })\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;h2&gt;{{msg}}&lt;/h2&gt;\n  &lt;h2&gt;{{user.name}}&lt;/h2&gt;\n&lt;/template&gt;\n</code></pre><ul><li>ref 能将任意类型的数据变为【响应式】的</li><li>reactive 只能将对象类型变为【响应式】，对基本类型无效（例如 string，number，boolean）</li></ul><p>还有一点不同</p><pre><code class=\"language-vue\">&lt;script setup lang=\"ts\"&gt;\nimport { ref, reactive } from \'vue\'\nconst u1 = ref({ name: \'张三\' })\nconst u2 = reactive({ name: \'张三\' })\n\nfunction test() {\n  console.log(u1.value)\n  console.log(u2)\n}\n\ntest()\n&lt;/script&gt;\n  \n&lt;template&gt;\n  &lt;h2&gt;{{u1.name}}&lt;/h2&gt;\n  &lt;h2&gt;{{u2.name}}&lt;/h2&gt;\n&lt;/template&gt;\n</code></pre><ul><li>在 template 模板中使用 ref 包装的数据，直接写【变量名】就可以了</li><li>但在代码中要使用 ref 包装的数据，必须用【变量名.value】才能访问到</li><li>reactive 包装的数据，在模板中和代码中都是一致的</li></ul><h4>属性绑定</h4><pre><code class=\"language-vue\">&lt;script setup lang=\"ts\"&gt;\nimport { ref } from \'vue\'\nconst path = ref(\'/src/assets/vue.svg\')\n\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;img :src=\"path\" alt=\"\"&gt;\n&lt;/template&gt;\n</code></pre><ul><li>【:属性名】用来将标签属性与【响应式】变量绑定</li></ul><h4>事件绑定</h4><pre><code class=\"language-vue\">&lt;script setup lang=\"ts\"&gt;\nimport { ref } from \'vue\'\nconst count = ref(0)\nfunction dec() {\n  count.value--\n}\nfunction inc() {\n  count.value++\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;input type=\"button\" value=\"-\" @click=\"dec\"&gt;\n  &lt;h2&gt;{{count}}&lt;/h2&gt;\n  &lt;input type=\"button\" value=\"+\" @click=\"inc\"&gt;\n&lt;/template&gt;\n</code></pre><ul><li>【@事件名】用来将标签属性与函数绑定，事件发生后执行函数内代码</li></ul><h4>表单绑定</h4><pre><code class=\"language-vue\">&lt;script setup lang=\"ts\"&gt;\nimport { ref } from \"vue\";\nconst user = ref({\n  name:\'张三\',\n  age:18,\n  sex:\'男\',\n  fav:[\'游泳\',\'打球\']\n})\n\nfunction saveUser() {\n  console.log(user.value)\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div class=\"outer\"&gt;\n    &lt;div&gt;\n      &lt;label for=\"\"&gt;请输入姓名&lt;/label&gt;\n      &lt;input type=\"text\" v-model=\"user.name\"/&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;label for=\"\"&gt;请输入年龄&lt;/label&gt;\n      &lt;input type=\"text\" v-model=\"user.age\"/&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;label for=\"\"&gt;请选择性别&lt;/label&gt;\n      男 &lt;input type=\"radio\" value=\"男\" v-model=\"user.sex\"/&gt; \n      女 &lt;input type=\"radio\" value=\"女\" v-model=\"user.sex\"/&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;label for=\"\"&gt;请选择爱好&lt;/label&gt;\n      游泳 &lt;input type=\"checkbox\" value=\"游泳\" v-model=\"user.fav\"/&gt; \n      打球 &lt;input type=\"checkbox\" value=\"打球\" v-model=\"user.fav\"/&gt; \n      健身 &lt;input type=\"checkbox\" value=\"健身\" v-model=\"user.fav\"/&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;input type=\"button\" value=\"保存\" @click=\"saveUser\"&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n  div {\n    margin-bottom: 8px;\n  }\n  .outer {\n    width: 100%;\n    position: relative;\n    padding-left: 80px;\n  }\n  label {\n    text-align: left;\n    width: 100px;\n    display: inline-block;\n    position: absolute;\n    left :0;\n  }\n&lt;/style&gt;\n</code></pre><ul><li>用 v-model 实现双向绑定，即 </li><li>双向绑定只适用于表单这种带【输入】功能的标签，其它标签的数据绑定，单向就足够了</li><li>复选框这种标签，双向绑定的 javascript 数据类型一般用数组</li></ul><h4>计算属性</h4><p>有时在数据展示时要做简单的计算</p><pre><code class=\"language-vue\">&lt;script setup lang=\"ts\"&gt;\nimport { ref } from \'vue\'\nconst firstName = ref(\'三\')\nconst lastName = ref(\'张\')\n\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;h2&gt;{{lastName + firstName}}&lt;/h2&gt;\n  &lt;h3&gt;{{lastName + firstName}}&lt;/h3&gt;\n  &lt;h4&gt;{{lastName + firstName}}&lt;/h4&gt;\n&lt;/template&gt;\n</code></pre><p>看起来较为繁琐，可以用计算属性改进</p><pre><code class=\"language-vue\">&lt;script setup lang=\"ts\"&gt;\nimport { ref, computed } from \'vue\'\nconst firstName = ref(\'三\')\nconst lastName = ref(\'张\')\nconst fullName = computed(() =&gt; {\n  console.log(\'enter\')\n  return lastName.value + firstName.value\n})\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;h2&gt;{{fullName}}&lt;/h2&gt;\n  &lt;h3&gt;{{fullName}}&lt;/h3&gt;\n  &lt;h4&gt;{{fullName}}&lt;/h4&gt;\n&lt;/template&gt;\n</code></pre><ul><li>fullName 即为计算属性，它具备缓存功能，即 firstName 和 lastName 的值发生了变化，才会重新计算</li><li>如果用函数实现相同功能，则没有缓存功能</li></ul><pre><code class=\"language-vue\">&lt;script setup lang=\"ts\"&gt;\nimport { ref } from \'vue\'\nconst firstName = ref(\'三\')\nconst lastName = ref(\'张\')\nfunction fullName() {\n  console.log(\'enter\')\n  return lastName.value + firstName.value\n}\n&lt;/script&gt;\n  \n&lt;template&gt;\n  &lt;h2&gt;{{fullName()}}&lt;/h2&gt;\n  &lt;h3&gt;{{fullName()}}&lt;/h3&gt;\n  &lt;h4&gt;{{fullName()}}&lt;/h4&gt;\n&lt;/template&gt;\n</code></pre><h4>xhr</h4><p>浏览器中有两套 API 可以和后端交互，发送请求、接收响应，fetch api 前面我们已经介绍过了，另一套 api 是 xhr，基本用法如下</p><pre><code class=\"language-js\">const xhr = new XMLHttpRequest()\nxhr.onload = function() {\n    console.log(xhr.response)\n}\nxhr.open(\'GET\', \'http://localhost:8080/api/students\')\nxhr.responseType = \"json\"\nxhr.send()\n</code></pre><p>但这套 api 虽然功能强大，但比较老，不直接支持 Promise，因此有必要对其进行改造</p><pre><code class=\"language-typescript\">function get(url: string) {\n  return new Promise((resolve, reject)=&gt;{\n    const xhr = new XMLHttpRequest()\n    xhr.onload = function() {\n      if(xhr.status === 200){\n        resolve(xhr.response)\n      } else if(xhr.status === 404) {\n        reject(xhr.response)\n      } // 其它情况也需考虑，这里简化处理\n    }\n    xhr.open(\'GET\', url)\n    xhr.responseType = \'json\'\n    xhr.send()\n  })\n}\n</code></pre><ul><li>Promise 对象适合用来封装异步操作，并可以配合 await 一齐使用</li><li>Promise 在构造时，需要一个箭头函数，箭头函数有两个参数 resolve 和 reject</li><li>await 会一直等到 Promise 内调用了 resolve 或 reject 才会继续向下运行</li></ul><p>调用示例1：同步接收结果，不走代理</p><pre><code class=\"language-js\">try {\n  const resp = await get(\"http://localhost:8080/api/students\")\n  console.log(resp)\n} catch (e) {\n  console.error(e)\n}\n</code></pre><p>调用示例2：走代理</p><pre><code class=\"language-js\">try {\n  const resp = await get(\'/api/students\')\n  console.log(resp)  \n} catch(e) {\n  console.log(e)\n}\n</code></pre><ul><li>走代理明显慢不少</li></ul><h4>axios</h4><h5>基本用法</h5><p>axios 就是对 xhr api 的封装，手法与前面例子类似</p><p>安装</p><pre><code class=\"language-cmd\">npm install axios\n</code></pre><p>一个简单的例子</p><pre><code class=\"language-vue\">&lt;script setup lang=\"ts\"&gt;\nimport { ref, onMounted } from \"vue\";\nimport axios from \"axios\";\n\nlet count = ref(0);\n\nasync function getStudents() {\n  try {\n    const resp = await axios.get(\"/api/students\");\n    count.value = resp.data.data.length;\n  } catch (e) {\n    console.log(e);\n  }\n}\n\nonMounted(() =&gt; {\n  getStudents()\n})\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;h2&gt;学生人数为：{{ count }}&lt;/h2&gt;\n&lt;/template&gt;\n</code></pre><ul><li>onMounted 指 vue 组件生成的 html 代码片段，挂载完毕后被执行</li></ul><p>再来看一个 post 例子</p><pre><code class=\"language-vue\">&lt;script setup lang=\"ts\"&gt;\nimport { ref } from \"vue\";\nimport axios from \"axios\";\n\nconst student = ref({\n  name: \'\',\n  sex: \'男\',\n  age: 18\n})\n\nasync function addStudent() {\n  console.log(student.value)\n  const resp = await axios.post(\'/api/students\', student.value)\n  console.log(resp.data.data)\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;div&gt;\n      &lt;input type=\"text\" placeholder=\"请输入姓名\" v-model=\"student.name\"/&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;label for=\"\"&gt;请选择性别&lt;/label&gt;\n      男 &lt;input type=\"radio\" value=\"男\" v-model=\"student.sex\"/&gt; \n      女 &lt;input type=\"radio\" value=\"女\" v-model=\"student.sex\"/&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;input type=\"number\" placeholder=\"请输入年龄\" v-model=\"student.age\"/&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;input type=\"button\" value=\"添加\" @click=\"addStudent\"/&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;style scoped&gt;\ndiv {\n  font-size: 14px;\n}\n&lt;/style&gt;\n</code></pre><h5>环境变量</h5><ul><li>开发环境下，联调的后端服务器地址是 <code>http://localhost:8080</code>，</li><li>上线改为生产环境后，后端服务器地址为 <code>http://itheima.com</code></li></ul><p>这就要求我们区分开发环境和生产环境，这件事交给构建工具 vite 来做</p><p>默认情况下，vite 支持上面两种环境，分别对应根目录下两个配置文件 </p><ul><li>.env.development - 开发环境</li><li>.env.production - 生产环境</li></ul><p>针对以上需求，分别在两个文件中加入</p><pre><code class=\"language-properties\">VITE_BACKEND_API_BASE_URL = \'http://localhost:8080\'\n</code></pre><p>和</p><pre><code class=\"language-properties\">VITE_BACKEND_API_BASE_URL = \'http://itheima.com\'\n</code></pre><p>然后在代码中使用 vite 给我们提供的特殊对象 <code>import.meta.env</code>，就可以获取到 <code>VITE_BACKEND_API_BASE_URL</code> 在不同环境下的值</p><pre><code class=\"language-js\">import.meta.env.VITE_BACKEND_API_BASE_URL\n</code></pre><p>默认情况下，不能智能提示自定义的环境变量，做如下配置：新增文件 <code>src/env.d.ts</code> 并添加如下内容</p><pre><code class=\"language-typescript\">/// &lt;reference types=\"vite/client\" /&gt;\n\ninterface ImportMetaEnv {\n  readonly VITE_BACKEND_API_BASE_URL: string\n  // 更多环境变量...\n}\n\ninterface ImportMeta {\n  readonly env: ImportMetaEnv\n}\n</code></pre><ul><li>参考文档地址 <a href=\"https://cn.vitejs.dev/guide/env-and-mode.html\" target=\"\">环境变量和模式 | Vite 官方中文文档 (vitejs.dev)</a></li></ul><h5>baseURL</h5><p>可以自己创建一个 axios 对象，方便添加默认设置，新建文件 /src/api/request.ts</p><pre><code class=\"language-typescript\">// 创建新的 axios 对象\nimport axios from \'axios\'\nconst _axios = axios.create({\n  baseURL: import.meta.env.VITE_BACKEND_API_BASE_URL\n})\n\nexport default _axios\n</code></pre><p>然后在其它组件中引用这个 ts 文件，例如 /src/views/E8.vue，就不用自己拼接路径前缀了</p><pre><code class=\"language-vue\">&lt;script setup lang=\"ts\"&gt;\nimport axios from \'../api/request\'\n// ...\nawait axios.post(\'/api/students\', ...)    \n&lt;/script&gt;\n</code></pre><h5>拦截器</h5><pre><code class=\"language-typescript\">// 创建新的 axios 对象\nimport axios from \'axios\'\nconst _axios = axios.create({\n  baseURL: import.meta.env.VITE_BACKEND_API_BASE_URL\n})\n\n// 请求拦截器\n_axios.interceptors.request.use(\n  (config)=&gt;{ // 统一添加请求头\n    config.headers = {\n      Authorization: \'aaa.bbb.ccc\'\n    }\n    return config\n  },\n  (error)=&gt;{ // 请求出错时的处理\n    return Promise.reject(error)\n  }\n)\n\n// 响应拦截器\n_axios.interceptors.response.use(\n  (response)=&gt;{ // 状态码  2xx\n    // 这里的code是自定义的错误码\n    if(response.data.code === 200) {\n      return response\n    }     \n    else if(response.data.code === 401) {       \n      // 情况1\n      return Promise.resolve({})\n    }\n    // ... \n  },\n  (error)=&gt;{ // 状态码 &gt; 2xx, 400,401,403,404,500\n    console.error(error) // 处理了异常\n    if(error.response.status === 400) {\n      // 情况1\n    } else if(error.response.status === 401) {\n      // 情况2\n    } \n    // ...\n    return Promise.resolve({})\n  }\n)\n\nexport default _axios\n</code></pre><p>处理响应时，又分成两种情况</p><ol><li>后端返回的是标准响应状态码，这时会走响应拦截器第二个箭头函数，用 error.response.status 做分支判断</li><li>后端返回的响应状态码总是200，用自定义错误码表示出错，这时会走响应拦截器第一个箭头函数，用 response.data.code 做分支判断</li></ol><p>另外</p><ul><li>Promise.reject(error) 类似于将异常继续向上抛出，异常由调用者（Vue组件）来配合 try ... catch 来处理</li><li>Promise.resolve({}) 表示错误已解决，返回一个空对象，调用者中接到这个空对象时，需要配合 ?. 来避免访问不存在的属性</li></ul><h4>条件与列表</h4><p>首先，新增模型数据 src/model/Model8080.ts</p><pre><code class=\"language-typescript\">export interface Student {\n  id: number;\n  name: string;\n  sex: string;\n  age: number;\n}\n\n// 如果 spring 错误，返回的对象格式\nexport interface SpringError {\n  timestamp: string,\n  status: number,\n  error: string,\n  message: string,\n  path: string\n}\n\n// 如果 spring 成功，返回 list 情况\nexport interface SpringList&lt;T&gt; {\n  data: T[],\n  message?: string,\n  code: number\n}\n\n// 如果 spring 成功，返回 page 情况\nexport interface SpringPage&lt;T&gt; {\n  data: { list: T[], total: number },\n  message?: string,\n  code: number\n}\n\n// 如果 spring 成功，返回 string 情况\nexport interface SpringString {\n  data: string,\n  message?: string,\n  code: number\n}\n\nimport { AxiosResponse } from \'axios\'\nexport interface AxiosRespError extends AxiosResponse&lt;SpringError&gt; { }\nexport interface AxiosRespList&lt;T&gt; extends AxiosResponse&lt;SpringList&lt;T&gt;&gt; { }\nexport interface AxiosRespPage&lt;T&gt; extends AxiosResponse&lt;SpringPage&lt;T&gt;&gt; { }\nexport interface AxiosRespString extends AxiosResponse&lt;SpringString&gt; { }\n</code></pre><p>其中 </p><ul><li>AxiosRespPage 代表分页时的响应类型</li><li>AxiosRespList 代表返回集合时的响应类型</li><li>AxiosRespString 代表返回字符串时的响应类型</li><li>AxiosRespError 代表 Spring 出错时时的响应类型</li></ul><pre><code class=\"language-vue\">&lt;script lang=\"ts\" setup&gt;\nimport { ref, onMounted } from \"vue\";\nimport axios from \"../api/request\";\nimport { Student, SpringList } from \"../model/Model8080\";\n\n// 说明 students 数组类型为 Student[]\nconst students = ref&lt;Student[]&gt;([]);\n\nasync function getStudents() {\n  // 说明 resp.data 类型是 SpringList&lt;Student&gt;\n  const resp = await axios.get&lt;SpringList&lt;Student&gt;&gt;(\"/api/students\");  \n  console.log(resp.data.data);\n  students.value = resp.data.data;\n}\n\nonMounted(() =&gt; getStudents());\n&lt;/script&gt;\n&lt;template&gt;\n  &lt;div class=\"outer\"&gt;\n    &lt;div class=\"title\"&gt;学生列表&lt;/div&gt;\n    &lt;div class=\"thead\"&gt;\n      &lt;div class=\"row bold\"&gt;\n        &lt;div class=\"col\"&gt;编号&lt;/div&gt;\n        &lt;div class=\"col\"&gt;姓名&lt;/div&gt;\n        &lt;div class=\"col\"&gt;性别&lt;/div&gt;\n        &lt;div class=\"col\"&gt;年龄&lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=\"tbody\"&gt;\n      &lt;div v-if=\"students.length === 0\"&gt;暂无数据&lt;/div&gt;\n      &lt;template v-else&gt;\n        &lt;div class=\"row\" v-for=\"s of students\" :key=\"s.id\"&gt;\n          &lt;div class=\"col\"&gt;{{ s.id }}&lt;/div&gt;\n          &lt;div class=\"col\"&gt;{{ s.name }}&lt;/div&gt;\n          &lt;div class=\"col\"&gt;{{ s.sex }}&lt;/div&gt;\n          &lt;div class=\"col\"&gt;{{ s.age }}&lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/template&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;style scoped&gt;\n.outer {\n  font-family: 华文行楷;\n  font-size: 20px;\n  width: 500px;\n}\n\n.title {\n  margin-bottom: 10px;\n  font-size: 30px;\n  color: #333;\n  text-align: center;\n}\n\n.row {\n  background-color: #fff;\n  display: flex;\n  justify-content: center;\n}\n\n.col {\n  border: 1px solid #f0f0f0;\n  width: 15%;\n  height: 35px;\n  text-align: center;\n  line-height: 35px;\n}\n\n.bold .col {\n  background-color: #f1f1f1;\n}\n&lt;/style&gt;\n</code></pre><ul><li>加入泛型是为了更好的提示</li><li>v-if 与 v-else 不能和 v-for 处于同一标签</li><li>template 标签还有一个用途，就是用它少生成一层真正 html 代码</li><li>可以看到将结果封装为响应式数据还是比较繁琐的，后面会使用 useRequest 改进</li></ul><h4>监听器</h4><p>利用监听器，可以在【响应式】的基础上添加一些副作用，把更多的东西变成【响应式的】</p><ul><li>原本只是数据变化 =&gt; 页面更新</li><li>watch 可以在数据变化时 =&gt; 其它更新</li></ul><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;input type=\"text\" v-model=\"name\" /&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\nimport { ref, watch } from \"vue\";\nfunction useStorage(name: string) {\n  const data = ref(sessionStorage.getItem(name) ?? \"\");\n  watch(data, (newValue) =&gt; {\n    sessionStorage.setItem(name, newValue);\n  });\n  return data;\n}\nconst name = useStorage(\"name\");\n&lt;/script&gt;\n</code></pre><ul><li>名称为 useXXXX 的函数，作用是返回带扩展功能的【响应式】数据</li><li>localStorage &nbsp; 即使浏览器关闭，数据还在</li><li>sessionStorage &nbsp;数据工作在浏览器活动期间</li></ul><h4>vueuse</h4><p>安装</p><pre><code class=\"language-cmd\">npm install @vueuse/core\n</code></pre><p>一些函数的用法</p><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;h3&gt;X: {{x}}&lt;/h3&gt;\n  &lt;h3&gt;Y: {{y}}&lt;/h3&gt;\n\n  &lt;h3&gt;{{count}}&lt;/h3&gt;\n  &lt;input type=\"button\" @click=\"inc()\" value=\"+\"&gt;\n  &lt;input type=\"button\" @click=\"dec()\" value=\"-\"&gt;\n\n  &lt;input type=\"text\" v-model=\"name\"&gt;\n&lt;/template&gt;\n&lt;script setup lang=\"ts\"&gt;\nimport { useMouse, useCounter, useStorage } from \'@vueuse/core\'\n\nconst {x, y} = useMouse()\n\nconst {count, inc, dec} = useCounter()\n\nconst name = useStorage(\"name\", \"\")\n&lt;/script&gt;\n</code></pre><h4>useRequest</h4><p>响应式的 axios 封装，官网地址 <a href=\"https://next.cn.attojs.org/\" target=\"\">一个 Vue 请求库 | VueRequest (attojs.org)</a></p><p>首先安装 vue-request</p><pre><code class=\"language-cmd\">npm install vue-request@next\n</code></pre><p>组件</p><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;h3 v-if=\"students.length === 0\"&gt;暂无数据&lt;/h3&gt;\n  &lt;ul v-else&gt;\n    &lt;li v-for=\"s of students\" :key=\"s.id\"&gt;\n      &lt;span&gt;{{s.name}}&lt;/span&gt;\n      &lt;span&gt;{{s.sex}}&lt;/span&gt;\n      &lt;span&gt;{{s.age}}&lt;/span&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/template&gt;\n&lt;script setup lang=\"ts\"&gt;\nimport axios from \"../api/request\"\nimport { useRequest } from \'vue-request\'\nimport { computed } from \'vue\'\nimport { AxiosRespList, Student } from \'../model/Model8080\'\n\n// data 代表就是 axios 的响应对象\nconst { data } = useRequest&lt;AxiosRespList&lt;Student&gt;&gt;(() =&gt; axios.get(\'/api/students\'))\n\nconst students = computed(()=&gt;{\n  return data?.value?.data.data || []\n})\n&lt;/script&gt;\n&lt;style scoped&gt;\nul li {\n  list-style: none;\n  font-family: \"华文行楷\";\n}\n\nli span:nth-child(1) {\n  font-size: 24px;\n}\nli span:nth-child(2) {\n  font-size: 12px;\n  color: crimson;\n  vertical-align: bottom;\n}\nli span:nth-child(3) {\n  font-size: 12px;\n  color: darkblue;\n  vertical-align: top;\n}\n&lt;/style&gt;\n</code></pre><ul><li>data.value 的取值一开始是 undefined，随着响应返回变成 axios 的响应对象</li><li>用 computed 进行适配</li></ul><h4>usePagination</h4><p>在 src/model/Model8080.ts 中补充类型说明</p><pre><code class=\"language-typescript\">export interface StudentQueryDto {\n  name?: string,\n  sex?: string,\n  age?: string, // 18,20\n  page: number,\n  size: number\n}\n</code></pre><ul><li>js 中类似于 18,20 这样以逗号分隔字符串，会在 get 传参时转换为 java 中的整数数组</li></ul><p>编写组件</p><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;input type=\"text\" placeholder=\"请输入姓名\" v-model=\"dto.name\"&gt;\n  &lt;select v-model=\"dto.sex\"&gt;\n    &lt;option value=\"\" selected&gt;请选择性别&lt;/option&gt;\n    &lt;option value=\"男\"&gt;男&lt;/option&gt;\n    &lt;option value=\"女\"&gt;女&lt;/option&gt;\n  &lt;/select&gt;\n  &lt;input type=\"text\" placeholder=\"请输入年龄范围\" v-model=\"dto.age\"&gt;\n  &lt;br&gt;\n  &lt;input type=\"text\" placeholder=\"请输入页码\" v-model=\"dto.page\"&gt;\n  &lt;input type=\"text\" placeholder=\"请输入页大小\" v-model=\"dto.size\"&gt;\n  &lt;input type=\"button\" value=\"搜索\" @click=\"search\"&gt;\n  &lt;hr&gt;\n  &lt;h3 v-if=\"students.length === 0\"&gt;暂无数据&lt;/h3&gt;\n  &lt;ul v-else&gt;\n    &lt;li v-for=\"s of students\" :key=\"s.id\"&gt;\n      &lt;span&gt;{{s.name}}&lt;/span&gt;\n      &lt;span&gt;{{s.sex}}&lt;/span&gt;\n      &lt;span&gt;{{s.age}}&lt;/span&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n  &lt;hr&gt;\n  总记录数{{total}} 总页数{{totalPage}}\n&lt;/template&gt;\n&lt;script setup lang=\"ts\"&gt;\nimport axios from \"../api/request\"\nimport { usePagination } from \'vue-request\'\nimport { computed, ref } from \'vue\'\nimport { AxiosRespPage, Student, StudentQueryDto } from \'../model/Model8080\'\n\nconst dto = ref&lt;StudentQueryDto&gt;({name:\'\', sex:\'\', age:\'\', page:1, size:5})\n\n// data 代表就是 axios 的响应对象\n// 泛型参数1: 响应类型\n// 泛型参数2: 请求类型\nconst { data, total, totalPage, run } = usePagination&lt;AxiosRespPage&lt;Student&gt;, StudentQueryDto[]&gt;(\n  (d) =&gt; axios.get(\'/api/students/q\', {params: d}), // 箭头函数\n  {\n    defaultParams: [ dto.value ], // 默认参数, 会作为参数传递给上面的箭头函数\n    pagination: {\n      currentKey: \'page\', // 指明当前页属性\n      pageSizeKey: \'size\', // 指明页大小属性\n      totalKey: \'data.data.total\' // 指明总记录数属性\n    } \n  } // 选项\n)\n\nconst students = computed(()=&gt;{\n  return data?.value?.data.data.list || []\n})\n\nfunction search() {\n  run(dto.value) // 会作为参数传递给usePagination的箭头函数\n}\n&lt;/script&gt;\n&lt;style scoped&gt;\nul li {\n  list-style: none;\n  font-family: \"华文行楷\";\n}\n\nli span:nth-child(1) {\n  font-size: 24px;\n}\nli span:nth-child(2) {\n  font-size: 12px;\n  color: crimson;\n  vertical-align: bottom;\n}\nli span:nth-child(3) {\n  font-size: 12px;\n  color: darkblue;\n  vertical-align: top;\n}\ninput,select {\n  width: 100px;\n}\n&lt;/style&gt;\n</code></pre><ul><li>usePagination 只需要定义一次，后续还想用它内部的 axios 发请求，只需调用 run 函数</li></ul><h4>子组件</h4><h5>例1</h5><p>定义子组件 Child1</p><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;div class=\"container\"&gt;\n    &lt;div class=\"card\"&gt;\n      &lt;div&gt;\n        &lt;p class=\"name\"&gt;{{name}}&lt;/p&gt;\n        &lt;p class=\"location\"&gt;{{country}}&lt;/p&gt;\n      &lt;/div&gt;\n      &lt;img :src=\"avatar || \'/src/assets/vue.svg\'\"/&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script setup lang=\"ts\"&gt;\n// 定义属性,  编译宏\ndefineProps&lt;{name:string,country:string,avatar?:string}&gt;()\n&lt;/script&gt;\n&lt;style scoped&gt;\n.container {\n  width: 100%;\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: space-evenly;\n  flex-direction: row-reverse;\n}\n.name {\n  font-weight: bold;\n}\n.location {\n  font-size: 0.8em;\n  color: #6d597a;\n}\n.card {\n  display: flex;\n  justify-content: space-evenly;\n  padding: 1em;\n  margin: 1rem;\n  border-radius: 5px;\n  background: #fff;\n  width: 200px;\n  box-shadow: 0 14px 28px rgba(0, 0, 0, 0.25), 0 10px 10px rgba(0, 0, 0, 0.22);\n}\n\n.card:hover {\n  transform: rotate(-5deg);\n}\n\n.card img {\n  margin-left: 1em;\n  border-radius: 50%;\n  max-width: 55px;\n  max-height: 55px;\n}\n&lt;/style&gt;\n</code></pre><p>父组件引用</p><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;Child1 name=\"张三\" country=\"中国\" avatar=\"/src/assets/vue.svg\"&gt;&lt;/Child1&gt;\n  &lt;Child1 name=\"李四\" country=\"印度\" avatar=\"/vite.svg\"&gt;&lt;/Child1&gt;\n  &lt;Child1 name=\"王五\" country=\"韩国\" &gt;&lt;/Child1&gt;\n&lt;/template&gt;\n&lt;script lang=\"ts\" setup&gt;\nimport Child1 from \'../components/Child1.vue\';\n&lt;/script&gt;\n</code></pre><h5>例2</h5><p>首先添加类型说明 model/ModelRandomUser.ts</p><pre><code class=\"language-typescript\">import { AxiosResponse } from \"axios\";\nexport interface AxiosRespResults extends AxiosResponse&lt;Results&gt;{}\n\nexport interface Results {\n  info: {\n    page: number,\n    results: number\n  },\n  results: Result[]\n}\n\nexport interface Result {\n  gender: \'male\' | \'female\',\n  name: {\n    first: string,\n    last: string\n  },\n  location: {\n    country: string\n  },\n  picture: {\n    medium: string\n  },\n  login: {\n    username: string\n  }\n}\n</code></pre><p>子组件不变，父组件使用子组件</p><pre><code class=\"language-vue\">&lt;!-- 父组件 --&gt;\n&lt;template&gt;\n  &lt;Child1 v-for=\"u of users\" \n    :name=\"u.name.first\" \n    :country=\"u.location.country\" \n    :avatar=\"u.picture.medium\"\n    :key=\"u.login.username\"&gt;&lt;/Child1&gt;\n&lt;/template&gt;\n&lt;script setup lang=\"ts\"&gt;\nimport axios from \"axios\";\nimport { useRequest } from \"vue-request\";\nimport { computed } from \"vue\";\nimport { AxiosRespResults } from \'../model/ModelRandomUser\'\nimport Child1 from \"../components/Child1.vue\";\n\nconst { data } = useRequest&lt;AxiosRespResults&gt;(\n  ()=&gt;axios.get(\'https://randomuser.me/api/?results=3\')\n)\n\nconst users = computed(()=&gt;{\n  return data.value?.data.results || []\n})\n&lt;/script&gt;\n</code></pre><p>如果觉得 Result 数据结构嵌套太复杂，还可以做一个类型映射</p><pre><code class=\"language-vue\">&lt;!-- 父组件 --&gt;\n&lt;template&gt;\n  &lt;Child1 v-for=\"u of users\" \n    :name=\"u.name\" \n    :country=\"u.country\" \n    :avatar=\"u.avatar\"\n    :key=\"u.username\"&gt;&lt;/Child1&gt;\n&lt;/template&gt;\n&lt;script setup lang=\"ts\"&gt;\nimport axios from \"axios\";\nimport { useRequest } from \"vue-request\";\nimport { computed } from \"vue\";\nimport { AxiosRespResults, Result } from \'../model/ModelRandomUser\'\nimport Child1 from \"../components/Child1.vue\";\n\nconst { data } = useRequest&lt;AxiosRespResults&gt;(\n  ()=&gt;axios.get(\'https://randomuser.me/api/?results=3\')\n)\n\nconst users = computed(()=&gt;{\n  return data.value?.data.results.map(resultToUser) || []\n})\n\ninterface User {\n  name: string,\n  country: string,\n  avatar: string,\n  username: string\n}\nfunction resultToUser(r:Result):User {\n  return {\n    name: r.name.first,\n    country: r.location.country,\n    avatar: r.picture.medium,\n    username: r.login.username\n  }\n}\n&lt;/script&gt;\n</code></pre><ul><li>resultToUser 将 Result 类型映射为 User 类型</li></ul><h2>3. Vue 进阶</h2><h3>1) Antdv</h3><p>添加必要插件</p><pre><code class=\"language-cmd\">npm install ant-design-vue\n</code></pre><ul><li>ant-design-vue 组件库插件</li></ul><p>引入 antdv 功能，修改 main.ts</p><pre><code class=\"language-typescript\">import { createApp } from \'vue\'\nimport \'./style.css\'\nimport App from \'./App.vue\'\nimport antd from \'ant-design-vue\'\nimport \'ant-design-vue/dist/antd.css\'\n\ncreateApp(App).use(antd).mount(\'#app\')\n</code></pre><h4>表格</h4><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;!-- &lt;a-table :columns=\"columns\" :dataSource=\"students\" rowKey=\"id\"&gt;&lt;/a-table&gt; --&gt;\n  &lt;a-table :columns=\"columns\" :dataSource=\"students\" :rowKey=\"rowKey\"&gt;&lt;/a-table&gt;\n&lt;/template&gt;\n&lt;script setup lang=\"ts\"&gt;\nimport axios from \"../api/request\";\nimport { ref, computed } from \"vue\";\nimport { useRequest } from \"vue-request\";\nimport { AxiosRespList, Student } from \"../model/Model8080\";\n\nconst {data} = useRequest&lt;AxiosRespList&lt;Student&gt;&gt;(\n  ()=&gt;axios.get(\'/api/students\')\n)\n\nconst students = computed(()=&gt;{\n  return data.value?.data.data || []\n})\n\nfunction rowKey(r:Student) {\n  return r.id\n}\n\nconst columns = ref([\n  {\n    title:\'编号\',\n    dataIndex:\'id\'\n  },\n  {\n    title:\'姓名\',\n    dataIndex:\'name\'\n  },\n  {\n    title:\'性别\',\n    dataIndex:\'sex\'\n  },\n  {\n    title:\'年龄\',\n    dataIndex:\'age\'\n  }\n])\n&lt;/script&gt;\n</code></pre><h4>分页</h4><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;a-table :columns=\"columns\" :data-source=\"students\" row-key=\"id\"\n   :pagination=\"pagination\" @change=\"tableChange\"&gt;&lt;/a-table&gt;\n&lt;/template&gt;\n&lt;script setup lang=\"ts\"&gt;\nimport axios from \"../api/request\";\nimport { ref, computed } from \"vue\";\nimport { usePagination } from \"vue-request\";\nimport { AxiosRespPage, Student, StudentQueryDto } from \"../model/Model8080\";\nimport { PaginationProps } from \"ant-design-vue\";\nimport DateBody from \"ant-design-vue/lib/vc-picker/panels/DatePanel/DateBody\";\n\nconst dto = ref({page: 1, size: 5})\n\nconst {data, total, run} = usePagination&lt;AxiosRespPage&lt;Student&gt;, StudentQueryDto[]&gt;(\n  (d)=&gt; axios.get(\'/api/students/q\', {params:d}),\n  {\n    defaultParams: [dto.value],\n    pagination: {\n      currentKey: \"page\",\n      pageSizeKey: \'size\',\n      totalKey: \'data.data.total\'\n    }\n  }\n)\n\n// 在页号或页大小改变时调用\nfunction tableChange(pagination: PaginationProps) { \n  console.log(pagination)\n  dto.value.page = pagination.current ?? 1\n  dto.value.size = pagination.pageSize ?? 5\n  run(dto.value)\n}\n\nconst pagination = computed&lt;PaginationProps&gt;(()=&gt;{\n  return {\n    current: dto.value.page, // 当前页\n    pageSize: dto.value.size, // 页大小\n    total: total.value,       // 总记录数\n    showSizeChanger: true,    // 显示页大小的下拉列表\n    pageSizeOptions: [\"1\",\"2\",\"3\",\"4\",\"5\"] // 自定义下拉列表内容\n  }\n})\n\nconst students = computed(()=&gt;{\n  return data.value?.data.data.list || []\n})\n\nconst columns = ref([\n  {\n    title: \"编号\",\n    dataIndex: \"id\",\n  },\n  {\n    title: \"姓名\",\n    dataIndex: \"name\",\n  },\n  {\n    title: \"性别\",\n    dataIndex: \"sex\",\n  },\n  {\n    title: \"年龄\",\n    dataIndex: \"age\",\n  },\n]);\n&lt;/script&gt;\n</code></pre><h4>搜索、删除</h4><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;a-row&gt;\n    &lt;a-col :span=\"2\"&gt;\n      &lt;a-button type=\"primary\" size=\"small\"&gt;新增&lt;/a-button&gt;\n    &lt;/a-col&gt;\n    &lt;a-col :span=\"4\"&gt;\n      &lt;a-popconfirm title=\"确认要删除选中学生吗?\"\n        ok-text=\"确定\" cancel-text=\"取消\" @confirm=\"onDeleteIds\"\n        @visibleChange=\"onVisibleChange\" :visible=\"visible\"&gt;\n        &lt;a-button type=\"primary\" size=\"small\"&gt;删除选中&lt;/a-button&gt;\n      &lt;/a-popconfirm&gt;\n    &lt;/a-col&gt;\n    &lt;a-col :span=\"4\"&gt;\n    &lt;/a-col&gt;\n    &lt;a-col :span=\"4\"&gt;\n      &lt;a-input v-model:value=\"dto.name\" placeholder=\"输姓名\" size=\"small\"&gt;&lt;/a-input&gt;\n    &lt;/a-col&gt;\n    &lt;a-col :span=\"4\"&gt;\n      &lt;a-select v-model:value=\"dto.sex\" placeholder=\"选性别\" :allowClear=\"true\" size=\"small\"&gt;\n        &lt;a-select-option value=\"男\"&gt;男&lt;/a-select-option&gt;\n        &lt;a-select-option value=\"女\"&gt;女&lt;/a-select-option&gt;\n      &lt;/a-select&gt;\n    &lt;/a-col&gt;\n    &lt;a-col :span=\"4\"&gt;\n      &lt;a-select v-model:value=\"dto.age\" placeholder=\"选年龄\" :allowClear=\"true\" size=\"small\"&gt;\n        &lt;a-select-option value=\"0,20\"&gt;20以下&lt;/a-select-option&gt;\n        &lt;a-select-option value=\"21,30\"&gt;21~30&lt;/a-select-option&gt;\n        &lt;a-select-option value=\"31,40\"&gt;31~40&lt;/a-select-option&gt;\n        &lt;a-select-option value=\"40,120\"&gt;40以上&lt;/a-select-option&gt;\n      &lt;/a-select&gt;\n    &lt;/a-col&gt;\n    &lt;a-col :span=\"2\"&gt;\n      &lt;a-button @click=\"tableChange\" type=\"primary\" size=\"small\"&gt;搜索&lt;/a-button&gt;\n    &lt;/a-col&gt;\n  &lt;/a-row&gt;\n  &lt;hr&gt;\n  &lt;a-table :columns=\"columns\" :data-source=\"students\" row-key=\"id\"\n    :pagination=\"pagination\" @change=\"tableChange\"\n    :row-selection=\"{selectedRowKeys:ids,onChange:onSelectChange}\"&gt;\n    &lt;template #bodyCell=\"{column, record}\"&gt;\n      &lt;template v-if=\"column.dataIndex===\'name\'\"&gt;\n      {{record.name + (record.sex===\'男\'?\'(大侠)\':\'(女侠)\')}}\n      &lt;/template&gt;\n\n      &lt;template v-else-if=\"column.dataIndex===\'operation\'\"&gt;\n      &lt;a&gt;修改&lt;/a&gt;\n      &lt;a-divider type=\"vertical\"&gt;&lt;/a-divider&gt;\n      &lt;a-popconfirm title=\"确认要删除该学生吗?\"\n        ok-text=\"确定\" cancel-text=\"取消\" @confirm=\"onDelete(record.id)\"&gt;\n        &lt;a&gt;删除&lt;/a&gt;   \n      &lt;/a-popconfirm&gt;         \n      &lt;/template&gt;\n    &lt;/template&gt;\n  &lt;/a-table&gt;\n  \n&lt;/template&gt;\n&lt;script setup lang=\"ts\"&gt;\nimport axios from \"../api/request\";\nimport { ref, computed } from \"vue\";\nimport { usePagination, useRequest } from \"vue-request\";\nimport { AxiosRespPage, AxiosRespString, Student, StudentQueryDto } from \"../model/Model8080\";\nimport { PaginationProps } from \"ant-design-vue\";\n\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 搜索功能开始\nconst dto = ref({page: 1, size: 5, name: \'\', sex: null, age: null})\n\nconst {data, total, run: search} = usePagination&lt;AxiosRespPage&lt;Student&gt;, StudentQueryDto[]&gt;(\n  (d) =&gt; axios.get(\'/api/students/q\', {params:d}),\n  {\n    defaultParams: [dto.value],\n    pagination: {\n      currentKey: \"page\",\n      pageSizeKey: \'size\',\n      totalKey: \'data.data.total\'\n    }\n  }\n)\n\nfunction tableChange(pagination: PaginationProps) { \n  // console.log(pagination)\n  dto.value.page = pagination.current ?? 1\n  dto.value.size = pagination.pageSize ?? 5\n  search(dto.value)\n}\n\nconst pagination = computed&lt;PaginationProps&gt;(()=&gt;{\n  return {\n    current: dto.value.page, // 当前页\n    pageSize: dto.value.size, // 页大小\n    total: total.value,       // 总记录数\n    showSizeChanger: true,    // 显示页大小的下拉列表\n    pageSizeOptions: [\"1\",\"2\",\"3\",\"4\",\"5\"] // 自定义下拉列表内容\n  }\n})\n\nconst students = computed(()=&gt;{\n  return data.value?.data.data.list || []\n})\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 搜索功能结束\n\n\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 删除功能开始\nasync function onDelete(id:number) {\n  // console.log(\"学生id是:\"+id)\n  await deleteById(id)      // 删除请求 删除响应\n  search(dto.value)        //                   查询请求 查询响应\n}\n\nconst { runAsync: deleteById } = useRequest&lt;AxiosRespString, number[]&gt;(\n  (id) =&gt; axios.delete(`/api/students/${id}`),\n  {\n    manual: true\n  }\n)\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 删除功能结束\n\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 删除选中开始\nconst ids = ref&lt;number[]&gt;([])\n\nfunction onSelectChange(keys:number[]) {\n  // console.log(keys)\n  ids.value = keys\n}\n\nasync function onDeleteIds() {\n  await deleteByIds(ids.value)\n  ids.value = []\n  search(dto.value)\n}\n\nconst { runAsync: deleteByIds } = useRequest&lt;AxiosRespString, number[][]&gt;(\n  (ids)=&gt;axios.delete(\'/api/students\', {data: ids}),\n  {\n    manual: true\n  }\n)\n\nconst visible = ref(false)\n\nfunction onVisibleChange(v:boolean) {\n  if(!v) { // 希望隐藏\n    visible.value = false\n  } else { // 希望显示\n    visible.value = ids.value.length &gt; 0\n  }\n}\n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 删除选中结束\n\nconst columns = ref([\n  {\n    title: \"编号\",\n    dataIndex: \"id\",\n  },\n  {\n    title: \"姓名\",\n    dataIndex: \"name\",\n  },\n  {\n    title: \"性别\",\n    dataIndex: \"sex\",\n  },\n  {\n    title: \"年龄\",\n    dataIndex: \"age\",\n  },\n  {\n    title: \'操作\',\n    dataIndex: \'operation\'\n  }\n]);\n&lt;/script&gt;\n&lt;style scoped&gt;\n  .ant-input, .ant-select {\n    width: 80px;\n  }\n&lt;/style&gt;\n</code></pre><h4>新增、修改</h4><p>子组件</p><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;a-modal :visible=\"visible\" :title=\"title\" \n    @ok=\"onOk\" @cancel=\"onCancel\"&gt;\n    &lt;a-form&gt;\n      &lt;a-form-item label=\"编号\" v-if=\"id\"&gt;\n        &lt;a-input readonly v-model:value=\"id\"&gt;&lt;/a-input&gt;\n      &lt;/a-form-item&gt;\n      &lt;a-form-item label=\"姓名\"&gt;\n        &lt;a-input v-model:value=\"dto.name\"&gt;&lt;/a-input&gt;\n      &lt;/a-form-item&gt;\n      &lt;a-form-item label=\"性别\"&gt;\n        &lt;a-radio-group v-model:value=\"dto.sex\"&gt;\n          &lt;a-radio-button value=\"男\"&gt;男&lt;/a-radio-button&gt;\n          &lt;a-radio-button value=\"女\"&gt;女&lt;/a-radio-button&gt;\n        &lt;/a-radio-group&gt;\n      &lt;/a-form-item&gt;\n      &lt;a-form-item label=\"年龄\"&gt;\n        &lt;a-input-number v-model:value=\"dto.age\"&gt;&lt;/a-input-number&gt;\n      &lt;/a-form-item&gt;\n    &lt;/a-form&gt;\n  &lt;/a-modal&gt;\n&lt;/template&gt;\n&lt;script setup lang=\"ts\"&gt;\nimport axios from \"../api/request\";\nimport { ref, computed } from \"vue\";\nimport { useRequest } from \"vue-request\";\nimport { StudentSaveDto, AxiosRespString } from \"../model/Model8080\";\nimport { Form } from \'ant-design-vue\'\n\n// 定义属性\nconst props = defineProps&lt;{id:number, dto:StudentSaveDto, visible:boolean}&gt;()\n\nconst title = computed(()=&gt; props.id===0?\'新增学生\':\'修改学生\')\n\n// 定义事件\nconst emit = defineEmits([\'update:visible\', \'saved\'])\n\nasync function onOk() {\n  if(props.id === 0) {\n    await insert(props.dto)\n  } else {\n    await update(props.dto)\n  }\n  emit(\'saved\')\n  // 发送事件给父组件, 希望把 visible 改为 false\n  emit(\'update:visible\', false) \n}\n\nfunction onCancel() {\n  // 发送事件给父组件, 希望把 visible 改为 false\n  emit(\'update:visible\', false)\n}\n\nconst {runAsync:insert} = useRequest&lt;AxiosRespString,StudentSaveDto[]&gt;(\n  (dto)=&gt;axios.post(\'/api/students\', dto),\n  {\n    manual: true\n  }\n)\n\nconst {runAsync:update} = useRequest&lt;AxiosRespString,StudentSaveDto[]&gt;(\n  (dto)=&gt;axios.put(`/api/students/${props.id}`, dto),\n  {\n    manual: true\n  }\n)\n&lt;/script&gt;\n</code></pre><p>父组件使用子组件</p><pre><code class=\"language-vue\">&lt;A4Save :id=\"id\" :dto=\"saveDto\" v-model:visible=\"saveVisible\"&gt;&lt;/A4Save&gt;\n\n&lt;script setup lang=\"ts\"&gt;\n// ...\n// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 新增、修改开始\nconst saveVisible = ref(false)\nconst id = ref(0)\nconst saveDto = reactive({name:\'\', sex:\'男\', age:18})\n\nfunction onInsert() {\n  saveVisible.value = true\n  id.value = 0\n  Object.assign(saveDto, {name:\'\', sex:\'男\', age:18})\n}\n\nfunction onUpdate(record: Student) {\n  saveVisible.value = true\n  id.value = record.id\n  Object.assign(saveDto, record)\n}\n\nfunction onSaved() {\n  search(dto.value)\n}    \n// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 新增、修改结束\n&lt;/script&gt;\n</code></pre><ul><li>saveDto 使用 reactive 包装，是为了解决后续表单校验失效问题</li><li>Object.assign 是将源对象（参数2）的属性值赋值给目标对象（参数1）的同名属性，效果等价于 saveDto.name = record.name saveDto.sex = record.sex saveDto.age = record.age</li></ul><h4>全局消息</h4><p>在 request.ts 中对响应消息统一处理</p><pre><code class=\"language-typescript\">import { message } from \'ant-design-vue\'\n\n// ...\n// 响应拦截器\n_axios.interceptors.response.use(\n  (response)=&gt;{ // 状态码  2xx\n    if(response.data.message) {\n      message.success(response.data.message, 3)\n    }    \n    // ... \n  },\n  (error)=&gt;{ // 状态码 &gt; 2xx, 400,401,403,404,500\n    // ...\n  }\n)\n</code></pre><h4>表单校验</h4><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;a-modal :visible=\"visible\" :title=\"title\" \n    @ok=\"onOk\" @cancel=\"onCancel\"&gt;\n    &lt;a-form&gt;\n      &lt;a-form-item label=\"编号\" v-if=\"id\"&gt;\n        &lt;a-input readonly v-model:value=\"id\"&gt;&lt;/a-input&gt;\n      &lt;/a-form-item&gt;\n      &lt;a-form-item label=\"姓名\" v-bind=\"validateInfos.name\"&gt;\n        &lt;a-input v-model:value=\"dto.name\"&gt;&lt;/a-input&gt;\n      &lt;/a-form-item&gt;\n      &lt;a-form-item label=\"性别\" v-bind=\"validateInfos.sex\"&gt;\n        &lt;a-radio-group v-model:value=\"dto.sex\"&gt;\n          &lt;a-radio-button value=\"男\"&gt;男&lt;/a-radio-button&gt;\n          &lt;a-radio-button value=\"女\"&gt;女&lt;/a-radio-button&gt;\n        &lt;/a-radio-group&gt;\n      &lt;/a-form-item&gt;\n      &lt;a-form-item label=\"年龄\" v-bind=\"validateInfos.age\"&gt;\n        &lt;a-input-number v-model:value=\"dto.age\"&gt;&lt;/a-input-number&gt;\n      &lt;/a-form-item&gt;\n    &lt;/a-form&gt;\n  &lt;/a-modal&gt;\n&lt;/template&gt;\n&lt;script setup lang=\"ts\"&gt;\nimport axios from \"../api/request\";\nimport { ref, computed } from \"vue\";\nimport { useRequest } from \"vue-request\";\nimport { StudentSaveDto, AxiosRespString } from \"../model/Model8080\";\nimport { Form } from \'ant-design-vue\'\n\n// 定义属性\nconst props = defineProps&lt;{id:number, dto:StudentSaveDto, visible:boolean}&gt;()\n\nconst title = computed(()=&gt; props.id===0?\'新增学生\':\'修改学生\')\n\n// 定义事件\nconst emit = defineEmits([\'update:visible\', \'saved\'])\n\nasync function onOk() {\n  try {\n    // 提交前校验\n    await validate()\n    if(props.id === 0) {\n      await insert(props.dto)\n    } else {\n      await update(props.dto)\n    }\n    emit(\'saved\')\n    // 发送事件给父组件, 希望把 visible 改为 false\n    emit(\'update:visible\', false) \n  } catch (e) {\n    console.error(e)\n  }\n}\n\nfunction onCancel() {\n  // 发送事件给父组件, 希望把 visible 改为 false\n  emit(\'update:visible\', false)\n}\n\nconst {runAsync:insert} = useRequest&lt;AxiosRespString,StudentSaveDto[]&gt;(\n  (dto)=&gt;axios.post(\'/api/students\', dto),\n  {\n    manual: true\n  }\n)\n\nconst {runAsync:update} = useRequest&lt;AxiosRespString,StudentSaveDto[]&gt;(\n  (dto)=&gt;axios.put(`/api/students/${props.id}`, dto),\n  {\n    manual: true\n  }\n)\n\nconst rules = ref({\n  name: [\n    {required: true, message:\'姓名必须\'},\n    {min:2, message:\'字符数至少为2\'}\n  ],\n  sex: [\n    {required: true, message:\'性别必须\'}\n  ],\n  age: [\n    {required: true, message:\'年龄必须\'},\n    {min:10, message:\'年龄最小为10岁\', type:\'number\'},\n    {max:120, message:\'年龄最大为120岁\', type:\'number\'}\n  ]\n})\n\n// 参数1: 待校验的数据\n// 参数2: 校验规则\nconst { validateInfos, validate } = Form.useForm(props.dto, rules)\n&lt;/script&gt;\n</code></pre><h3>2) vue-router</h3><h4>安装</h4><pre><code class=\"language-cmd\">npm install vue-router@4\n</code></pre><h4>创建 router</h4><p>首先创建一个 /src/router/a5router.ts 文件，在其中定义路由</p><pre><code class=\"language-typescript\">import {createRouter, createWebHashHistory} from \'vue-router\'\nimport A51 from \'../views/A51.vue\'\nimport A52 from \'../views/A52.vue\'\n// 路由 =&gt; 路径和组件之间的对应关系\nconst routes = [\n  {\n    path: \'/a1\',\n    component: A51\n  },\n  {\n    path: \'/a2\', \n    component: A52\n  }\n]\n\nconst router = createRouter({ \n  history: createWebHashHistory(), // 路径格式\n  routes: routes // 路由数组\n})\n\nexport default router\n</code></pre><ul><li>createWebHashHistory 是用 # 符号作为【单页面】跳转技术，上面两个路由访问时路径格式为 http://localhost:7070/#/a1 http://localhost:7070/#/a2</li><li>每个路由都有两个必须属性 path：路径 component：组件</li><li>createRouter 用来创建 router 对象，作为默认导出</li></ul><p>需要在 main.ts 中导入 router 对象：</p><pre><code class=\"language-typescript\">// ...\nimport A5 from \'./views/A5.vue\'  // vue-router\nimport router from \'./router/a5router\'\ncreateApp(A5).use(antdv).use(router).mount(\'#app\')\n</code></pre><p>A5 是根组件，不必在 router 中定义，但需要在其中定义 router-view，用来控制路由跳转后，A51、A52 这些组件的显示位置，内容如下</p><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;div class=\"a5\"&gt;\n    &lt;router-view&gt;&lt;/router-view&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre><p>效果如下</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220926145812121.png\" alt=\"image-20220926145812121\" data-href=\"\" style=\"\"/></p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220926145959690.png\" alt=\"image-20220926145959690\" data-href=\"\" style=\"\"/></p><h4>动态导入</h4><pre><code class=\"language-typescript\">import {createRouter, createWebHashHistory} from \'vue-router\'\nimport A51 from \'../views/A51.vue\'\nimport A52 from \'../views/A52.vue\'\nconst routes = [\n  // ...\n  {\n    path: \'/a3\',\n    component: () =&gt; import(\'../views/A53.vue\')\n  }\n]\n</code></pre><ul><li>用 import 关键字导入，效果是打包时会将组件的 js 代码都打包成一个大的 js 文件，如果组件非常多，会影响页面加载速度</li><li>而 import 函数导入（动态导入），则是按需加载，即</li></ul><h4>嵌套路由</h4><p>如果希望再嵌套更深层次的路由跳转，例如：希望在 A53 组件内再进行路由跳转</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220926150819624.png\" alt=\"image-20220926150819624\" data-href=\"\" style=\"\"/></p><p>首先，修改 A53.vue</p><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;div class=\"a53\"&gt;\n    &lt;router-view&gt;&lt;/router-view&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre><p>其次，再修改 /src/router/a5router.ts 文件 内容</p><pre><code class=\"language-typescript\">import {createRouter, createWebHashHistory} from \'vue-router\'\nimport A51 from \'../views/A51.vue\'\nimport A52 from \'../views/A52.vue\'\nconst routes = [\n  // ...\n  {\n    path: \'/a3\',\n    component: () =&gt; import(\'../views/A53.vue\'),\n    children: [\n      {\n        path: \'student\',\n        component: () =&gt; import(\'../views/A531.vue\')\n      },\n      {\n        path: \'teacher\',\n        component: () =&gt; import(\'../views/A532.vue\')\n      }\n    ]\n  }\n]\n\n// ...\n</code></pre><p>将来访问 /a3/student 时，效果为</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220926151216217.png\" alt=\"image-20220926151216217\" data-href=\"\" style=\"\"/></p><p>访问 /a3/teacher 时，效果为</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220926151249403.png\" alt=\"image-20220926151249403\" data-href=\"\" style=\"\"/></p><h4>重定向</h4><p>用法1</p><pre><code class=\"language-typescript\">import {createRouter, createWebHashHistory} from \'vue-router\'\nimport A51 from \'../views/A51.vue\'\nimport A52 from \'../views/A52.vue\'\nconst routes = [\n  // ...\n  {\n    path: \'/a3\',\n    component: () =&gt; import(\'../views/A53.vue\'),\n    redirect: \'/a3/student\', // 重定向到另外路径\n    children: [\n      {\n        path: \'student\',\n        component: () =&gt; import(\'../views/A531.vue\')\n      },\n      {\n        path: \'teacher\',\n        component: () =&gt; import(\'../views/A532.vue\')\n      }\n    ]\n  }\n]\n// ...\n</code></pre><p>效果是，页面输入 /a3，紧接着会重定向跳转到 /a3/student</p><p>用法2</p><pre><code class=\"language-typescript\">import {createRouter, createWebHashHistory} from \'vue-router\'\nimport A51 from \'../views/A51.vue\'\nimport A52 from \'../views/A52.vue\'\nconst routes = [\n  {\n    path: \'/a1\',\n    component: A51\n  },\n  {\n    path: \'/a2\', \n    component: A52\n  },\n  // ...\n  {\n    path: \'/:pathMatcher(.*)*\', // 可以匹配剩余的路径\n    redirect: \'/a2\'\n  }\n]\n// ...\n</code></pre><p>效果是，当页面输入一个不存在路径 /aaa 时，会被 <code>path: \'/:pathMatcher(.*)*\'</code> 匹配到，然后重定向跳转到 A52 组件去</p><h4>主页布局</h4><p>借助 antdv 的 layout 组件，可以实现主页【上】【左】【右】布局</p><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;div class=\"a53\"&gt;\n    &lt;a-layout&gt;\n      &lt;a-layout-header&gt;&lt;/a-layout-header&gt;\n      &lt;a-layout&gt;\n        &lt;a-layout-sider&gt;&lt;/a-layout-sider&gt;\n        &lt;a-layout-content&gt;\n          &lt;router-view&gt;&lt;/router-view&gt;\n        &lt;/a-layout-content&gt;\n      &lt;/a-layout&gt;\n    &lt;/a-layout&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;style scoped&gt;\n.a53 {\n  height: 100%;\n  background-color: rgb(220, 225, 255);\n  background-image: url(\"data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\'%3E%3Ctext x=\'35\' y=\'10\' font-size=\'14\' font-family=\'system-ui, sans-serif\' text-anchor=\'middle\' dominant-baseline=\'middle\'%3EA53(主页)%3C/text%3E%3C/svg%3E\");\n  padding: 20px;\n  box-sizing: border-box;\n}\n.ant-layout-header {\n  height: 50px;\n  background-color:darkseagreen;\n}\n\n.ant-layout-sider {\n  background-color:lightsalmon;\n}\n\n.ant-layout-content {\n  background-color: aliceblue;\n}\n\n.ant-layout-footer {\n  background-color:darkslateblue;\n  height: 30px;\n}\n\n.ant-layout {\n  height: 100%;\n}\n\n.ant-layout-has-sider {\n  height: calc(100% - 50px);\n}\n&lt;/style&gt;\n</code></pre><h4>侧边栏菜单</h4><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;div class=\"a53\"&gt;\n    &lt;a-layout&gt;\n      &lt;a-layout-header&gt;&lt;/a-layout-header&gt;\n      &lt;a-layout&gt;\n        &lt;a-layout-sider&gt;\n          &lt;a-menu theme=\"dark\" mode=\"inline\"&gt;\n            &lt;a-menu-item :key=\"1\"&gt;\n              &lt;router-link to=\"/a3/student\"&gt;菜单1&lt;/router-link&gt;\n            &lt;/a-menu-item&gt;\n            &lt;a-menu-item :key=\"2\"&gt;\n              &lt;router-link to=\"/a3/teacher\"&gt;菜单2&lt;/router-link&gt;\n            &lt;/a-menu-item&gt;\n            &lt;a-menu-item :key=\"3\"&gt;菜单3&lt;/a-menu-item&gt;\n            &lt;a-sub-menu :key=\"4\" title=\"菜单4\"&gt;\n              &lt;a-menu-item :key=\"41\"&gt;菜单41&lt;/a-menu-item&gt;\n              &lt;a-menu-item :key=\"42\"&gt;菜单42&lt;/a-menu-item&gt;\n            &lt;/a-sub-menu&gt;\n          &lt;/a-menu&gt;\n        &lt;/a-layout-sider&gt;\n        &lt;a-layout-content&gt;\n          &lt;router-view&gt;&lt;/router-view&gt;\n        &lt;/a-layout-content&gt;\n      &lt;/a-layout&gt;\n    &lt;/a-layout&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre><ul><li>a-menu-item 与 a-sub-menu 都必须为 key 属性唯一赋值，否则会产生混乱</li><li>router-link 标签用来切换路由，to 是目标路由的路径</li><li>theme 属性定义菜单的主题（默认亮色主题，dark 为暗色主题）</li><li>mode 属性定义子菜单的展示模式（默认弹出，inline 显示在下方）</li></ul><h4>菜单图标</h4><p>安装图标依赖</p><pre><code class=\"language-cmd\">npm install @ant-design/icons-vue\n</code></pre><p>菜单中使用图标</p><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;div class=\"a53\"&gt;\n    &lt;a-layout&gt;\n      &lt;a-layout-header&gt;&lt;/a-layout-header&gt;\n      &lt;a-layout&gt;\n        &lt;a-layout-sider&gt;\n          &lt;a-menu theme=\"dark\" mode=\"inline\"&gt;\n            &lt;a-menu-item :key=\"1\"&gt;\n              &lt;template #icon&gt;\n                &lt;highlight-outlined /&gt;\n              &lt;/template&gt;\n              &lt;router-link to=\"/a3/student\"&gt;菜单1&lt;/router-link&gt;\n            &lt;/a-menu-item&gt;\n            &lt;a-menu-item :key=\"2\"&gt;\n              &lt;template #icon&gt;\n                &lt;align-center-outlined /&gt;\n              &lt;/template&gt;\n              &lt;router-link to=\"/a3/teacher\"&gt;菜单2&lt;/router-link&gt;\n            &lt;/a-menu-item&gt;\n            &lt;a-menu-item :key=\"3\"&gt;\n              &lt;template #icon&gt;\n                &lt;strikethrough-outlined /&gt;\n              &lt;/template&gt;\n              菜单3&lt;/a-menu-item&gt;\n            &lt;a-sub-menu :key=\"4\" title=\"菜单4\"&gt;\n              &lt;template #icon&gt;\n                &lt;sort-descending-outlined /&gt;\n              &lt;/template&gt;\n              &lt;a-menu-item :key=\"41\"&gt;菜单41&lt;/a-menu-item&gt;\n              &lt;a-menu-item :key=\"42\"&gt;菜单42&lt;/a-menu-item&gt;\n            &lt;/a-sub-menu&gt;\n          &lt;/a-menu&gt;\n        &lt;/a-layout-sider&gt;\n        &lt;a-layout-content&gt;\n          &lt;router-view&gt;&lt;/router-view&gt;\n        &lt;/a-layout-content&gt;\n      &lt;/a-layout&gt;\n    &lt;/a-layout&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script setup lang=\"ts\"&gt;\nimport {HighlightOutlined, AlignCenterOutlined, StrikethroughOutlined, SortDescendingOutlined} from \'@ant-design/icons-vue\'\n&lt;/script&gt;\n</code></pre><ul><li>图标组件没有全局绑定，需要 import 之后才能使用</li><li>用 <code>&lt;template #icon&gt;&lt;/template&gt;</code> 插槽，才能确定图标展示的位置（菜单文字之前）</li></ul><h4>二次封装图标组件</h4><p>最终希望用统一的图标组件去使用图标，图标名只是作为一个属性值传递进去，例如：</p><p>使用者</p><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;a-icon icon=\"highlight-outlined\"&gt;&lt;/a-icon&gt;\n  &lt;a-icon icon=\"align-center-outlined\"&gt;&lt;/a-icon&gt;\n  &lt;a-icon icon=\"strikethrough-outlined\"&gt;&lt;/a-icon&gt;\n  &lt;a-icon icon=\"sort-descending-outlined\"&gt;&lt;/a-icon&gt;\n&lt;/template&gt;\n&lt;script setup lang=\"ts\"&gt;\nimport AIcon from \'../components/AIcon1.vue\'\n&lt;/script&gt;\n</code></pre><h5>方法1，使用 vue 组件</h5><pre><code class=\"language-vue\">&lt;script lang=\"ts\" setup&gt;\nimport {HighlightOutlined, AlignCenterOutlined, StrikethroughOutlined, SortDescendingOutlined} from \'@ant-design/icons-vue\'\nconst props = defineProps&lt;{icon:string}&gt;()\n&lt;/script&gt;\n&lt;template&gt;\n  &lt;highlight-outlined v-if=\"icon===\'highlight-outlined\'\"&gt;&lt;/highlight-outlined&gt;\n  &lt;align-center-outlined v-else-if=\"icon===\'align-center-outlined\'\"&gt;&lt;/align-center-outlined&gt;\n  &lt;strikethrough-outlined v-else-if=\"icon===\'strikethrough-outlined\'\"&gt;&lt;/strikethrough-outlined&gt;\n  &lt;sort-descending-outlined v-else-if=\"icon===\'sort-descending-outlined\'\"&gt;&lt;/sort-descending-outlined&gt;\n&lt;/template&gt;\n</code></pre><ul><li>缺点：实现太笨</li></ul><h5>方法2，使用函数式组件</h5><pre><code class=\"language-typescript\">import { h } from \"vue\"\nimport * as Icons from \'@ant-design/icons-vue\'\n\ninterface Module {\n  [p:string]: any\n}\n\n// 参数1: 组件属性\nconst AIcon = (props:{icon:string}) =&gt; {\n  // console.log(props.icon)\n  // console.log(Icons)\n  // 参数1: 组件对象\n  const im: Module = Icons\n  return h(im[toCamelCase(props.icon)])\n}\n\nexport default AIcon\n\n// 将-分隔的单词转换为大驼峰命名的单词\nfunction toCamelCase(str: string) { // highlight-outlined\n  return str.split(\'-\') // [\'highlight\', \'outlined\']\n    .map((e)=&gt; e.charAt(0).toUpperCase() + e.slice(1) ) // [\'Highlight\', \'Outlined\']\n    .join(\'\')\n}\n/*\nIcons 的结构如下\n{\n  HighlightOutlined: HighlightOutlined组件对象,\n  MonitorOutlined: MonitorOutlined组件对象,\n  ...\n}\n*/\n</code></pre><ul><li>需要动态生成标签的时候，可以考虑使用函数式组件</li></ul><h5>方法3，使用 jsx 组件</h5><p>首先，安装 &nbsp;</p><pre><code class=\"language-cmd\">npm install @vitejs/plugin-vue-jsx -D\n</code></pre><p>配置 vite.config.ts</p><pre><code class=\"language-typescript\">import { defineConfig } from \'vite\'\nimport vue from \'@vitejs/plugin-vue\'\nimport vueJsx from \'@vitejs/plugin-vue-jsx\'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [vue(), vueJsx()]\n})\n</code></pre><p>编写一个 Hi.tsx 组件</p><pre><code class=\"language-tsx\">export default {\n  props: {\n    msg: String\n  },\n  setup(props: { msg: string }) {\n    return () =&gt; &lt;h5&gt;{props.msg}&lt;/h5&gt;\n  }\n}\n</code></pre><p>然后被其它组件使用</p><pre><code class=\"language-vue\">&lt;script setup lang=\"ts\"&gt;\nimport Hi from \'../components/Hi\'\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;Hi msg=\"Hello,World\"&gt;&lt;/Hi&gt;\n&lt;/template&gt;\n</code></pre><p>用 jsx 实现图标组件</p><pre><code class=\"language-typescript\">import * as Icons from \'@ant-design/icons-vue\'\n\ninterface Module {\n  [p:string]: any\n}\n\nfunction toCamelCase(str: string) { // highlight-outlined\n  return str\n    .split(\"-\") // [\'highlight\', \'outlined\']\n    .map((e) =&gt; e.charAt(0).toUpperCase() + e.slice(1)) // [\'Highlight\', \'Outlined\']\n    .join(\"\"); // HighlightOutlined\n}\n\nexport default {\n  props: {\n    icon: String\n  },\n  setup(props: {icon: string}) {\n    const im: Module = Icons\n    const tag = im[toCamelCase(props.icon)] // 图标组件\n    // HighlightOutlined\n    return ()=&gt; &lt;tag&gt;&lt;/tag&gt; // 返回组件标签\n  }\n}\n</code></pre><h4>动态路由与菜单</h4><h5>路由文件</h5><p>a6router.js</p><pre><code class=\"language-typescript\">import { createRouter, createWebHashHistory } from \'vue-router\'\nimport { useStorage } from \'@vueuse/core\'\nimport { Route, Menu } from \'../model/Model8080\'\nconst clientRoutes = [\n  {\n    path: \'/login\',\n    name: \'login\',\n    component: () =&gt; import(\'../views/A6Login.vue\')\n  },\n  {\n    path: \'/404\',\n    name: \'404\',\n    component: () =&gt; import(\'../views/A6NotFound.vue\')\n  },\n  {\n    path: \'/\',\n    name: \'main\',\n    component: () =&gt; import(\'../views/A6Main.vue\')\n  },\n  {\n    path: \'/:pathMatcher(.*)*\',\n    name: \'remaining\',\n    redirect: \'/404\'\n  }\n]\n\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes: clientRoutes\n})\n\nexport const serverMenus = useStorage&lt;Menu[]&gt;(\'serverMenus\', [])\nconst serverRoutes = useStorage&lt;Route[]&gt;(\'serverRoutes\', [])\naddServerRoutes(serverRoutes.value)\n\nexport function addServerRoutes(routeList: Route[]) {\n  for (const r of routeList) {\n    if (r.parentName) {\n      router.addRoute(r.parentName, {\n        path: r.path,\n        component: () =&gt; import(r.component),\n        name: r.name\n      })\n    }\n  }\n  serverRoutes.value = routeList\n}\n\nexport function resetRoutes() {\n  for (const r of clientRoutes) {\n    router.addRoute(r)\n  }\n  serverRoutes.value = null\n  serverMenus.value = null\n}\n\nexport default router\n</code></pre><p>本文件重要的函数及变量</p><ul><li>addServerRoutes 函数向路由表中添加由服务器提供的路由，路由分成两部分</li><li>resetRoutes 函数用来将路由重置为 clientRoutes </li><li>serverMenus 变量记录服务器变化的菜单，存储于 localStorage</li></ul><h5>登录组件</h5><p>动态路由应当在登录时生成，A6Login.vue</p><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;div class=\"login\"&gt;\n    &lt;a-form :label-col=\"{ span: 6 }\" autocomplete=\"off\"&gt;\n      &lt;a-form-item label=\"用户名\" v-bind=\"validateInfos.username\"&gt;\n        &lt;a-input v-model:value=\"dto.username\" /&gt;\n      &lt;/a-form-item&gt;\n      &lt;a-form-item label=\"密码\" v-bind=\"validateInfos.password\"&gt;\n        &lt;a-input-password v-model:value=\"dto.password\" /&gt;\n      &lt;/a-form-item&gt;\n      &lt;a-form-item :wrapper-col=\"{ offset: 6, span: 16 }\"&gt;\n        &lt;a-button type=\"primary\" @click=\"onClick\"&gt;Submit&lt;/a-button&gt;\n      &lt;/a-form-item&gt;      \n    &lt;/a-form&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script setup lang=\"ts\"&gt;\nimport { ref, onMounted } from \'vue\'\nimport { Form } from \'ant-design-vue\'\nimport { useRouter } from \'vue-router\'\nimport axios from \'../api/request\'\nimport { useRequest } from \'vue-request\'\nimport { AxiosRespToken, LoginDto, AxiosRespMenuAndRoute } from \'../model/Model8080\'\nimport { resetRoutes, addServerRoutes, serverMenus } from \'../router/a6router\'\nconst dto = ref({username:\'\', password:\'\'})\nconst rules = ref({\n  username: [\n    {required: true, message:\'用户名必填\'}\n  ],\n  password:[\n    {required: true, message:\'密码必填\'}\n  ]\n})\nconst { validateInfos, validate } = Form.useForm(dto, rules)\nconst router = useRouter()\nconst { runAsync:login } = useRequest&lt;AxiosRespToken, LoginDto[]&gt;((dto)=&gt; axios.post(\'/api/loginJwt\', dto), {manual:true})\nconst { runAsync:menu } = useRequest&lt;AxiosRespMenuAndRoute, string[]&gt;((username)=&gt; axios.get(`/api/menu/${username}`), {manual:true})\nasync function onClick() {\n  try {\n    await validate()\n    const loginResp = await login(dto.value\n    if(loginResp.data.code === 200) { // 登录成功\n      const token = loginResp.data.data.token\n      const menuResp = await menu(dto.value.username)\n      const routeList = menuResp.data.data.routeList\n      addServerRoutes(routeList)\n      serverMenus.value = menuResp.data.data.menuTree\n      router.push(\'/\')\n    })\n  } catch (e) {\n    console.error(e)\n  }\n}\nonMounted(()=&gt;{\n  resetRoutes()\n})\n&lt;/script&gt;\n&lt;style scoped&gt;\n.login{\n  margin: 200px auto;\n  width: 25%;\n  padding: 20px;\n  height: 180px;\n  background-color: antiquewhite;\n}\n&lt;/style&gt;\n</code></pre><ul><li>登录成功后去请求 <code>/api/menu/{username}</code> &nbsp;获取该用户的菜单和路由</li><li>router.push 方法用来以编程方式跳转至主页路由</li></ul><h5>主页组件</h5><p>A6Main.vue</p><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;div class=\"a6main\"&gt;\n    &lt;a-layout&gt;\n      &lt;a-layout-header&gt;\n      &lt;/a-layout-header&gt;\n      &lt;a-layout&gt;\n        &lt;a-layout-sider&gt;\n          &lt;a-menu mode=\"inline\" theme=\"dark\"&gt;\n            &lt;template v-for=\"m1 of serverMenus\"&gt;\n              &lt;a-sub-menu v-if=\"m1.children\" :key=\"m1.id\" :title=\"m1.title\"&gt;\n                &lt;template #icon&gt;&lt;a-icon :icon=\"m1.icon\"&gt;&lt;/a-icon&gt;&lt;/template&gt;\n                &lt;a-menu-item v-for=\"m2 of m1.children\" :key=\"m2.id\"&gt;\n                  &lt;template #icon&gt;&lt;a-icon :icon=\"m2.icon\"&gt;&lt;/a-icon&gt;&lt;/template&gt;\n                  &lt;router-link v-if=\"m2.routePath\" :to=\"m2.routePath\"&gt;{{m2.title}}&lt;/router-link&gt;\n                  &lt;span v-else&gt;{{m2.title}}&lt;/span&gt;\n                &lt;/a-menu-item&gt;\n              &lt;/a-sub-menu&gt;\n              &lt;a-menu-item v-else :key=\"m1.id\"&gt;\n                &lt;template #icon&gt;&lt;a-icon :icon=\"m1.icon\"&gt;&lt;/a-icon&gt;&lt;/template&gt;\n                &lt;router-link v-if=\"m1.routePath\" :to=\"m1.routePath\"&gt;{{m1.title}}&lt;/router-link&gt;\n                &lt;span v-else&gt;{{m1.title}}&lt;/span&gt;\n              &lt;/a-menu-item&gt;\n            &lt;/template&gt;            \n          &lt;/a-menu&gt;\n        &lt;/a-layout-sider&gt;\n        &lt;a-layout-content&gt;\n          &lt;router-view&gt;&lt;/router-view&gt;\n        &lt;/a-layout-content&gt;\n      &lt;/a-layout&gt;\n    &lt;/a-layout&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script setup lang=\"ts\"&gt;\nimport AIcon from \'../components/AIcon3\' // jsx icon 组件\nimport { serverMenus } from \'../router/a6router\'\n&lt;/script&gt;\n&lt;style scoped&gt;\n.a6main {\n  height: 100%;\n  background-color: rgb(220, 225, 255);\n  box-sizing: border-box;\n}\n.ant-layout-header {\n  height: 50px;\n  background-color:darkseagreen;\n}\n\n.ant-layout-sider {\n  background-color:lightsalmon;\n}\n\n.ant-layout-content {\n  background-color: aliceblue;\n}\n\n.ant-layout-footer {\n  background-color:darkslateblue;\n  height: 30px;\n}\n\n.ant-layout {\n  height: 100%;\n}\n\n.ant-layout-has-sider {\n  height: calc(100% - 50px);\n}\n\n&lt;/style&gt;\n</code></pre><h4>token 使用</h4><ol><li>获取用户信息，例如服务器端可以把用户名、该用户的路由、菜单信息都统一从 token 返回</li><li>前端路由跳转依据，例如跳转前检查 token，如果不存在，表示未登录，就避免跳转至某些路由</li><li>后端 api 访问依据，例如每次发请求携带 token，后端需要身份校验的 api 需要用到</li></ol><h3>3) pinia</h3><p>需求：在组件 p1 里更新了数据，主页组件也同步更新显示</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220930172635166.png\" alt=\"image-20220930172635166\" data-href=\"\" style=\"\"/></p><ul><li>storage 虽然可以实现多个组件的数据共享，但是需要【主动访问】才能获取更新后的数据</li><li>本例中由于没有涉及主页组件的 mounted 操作，因此并不会【主动】获取 storage 的数据</li></ul><h4>安装</h4><pre><code class=\"language-cmd\">npm install pinia\n</code></pre><p>在 main.ts 中引入</p><pre><code class=\"language-typescript\">import { createPinia } from \'pinia\'\n\n// ...\ncreateApp(A6).use(antdv).use(router).use(createPinia()).mount(\'#app\')\n</code></pre><h4>定义Store</h4><p>再新建 store 目录来管理共享数据，下面是 /src/store/UserInfo.ts</p><pre><code class=\"language-typescript\">import axios from \'../api/request\'\nimport { defineStore } from \"pinia\"\nimport { UserInfoDto } from \'../model/Model8080\'\n\nexport const useUserInfo = defineStore(\'userInfo\', {\n  state: () =&gt; {\n    return { username: \'\', name: \'\', sex: \'\' }\n  },\n  actions: {\n    async get(username: string) {\n      const resp = await axios.get(`/api/info/${username}`)\n      Object.assign(this, resp.data.data)\n    },\n    async update(dto: UserInfoDto) {\n      await axios.post(\'/api/info\', dto)\n      Object.assign(this, dto)\n    }\n  }\n})\n</code></pre><ul><li>定义了 useUserInfo 函数，用来获取共享数据，它可能用于多个组件 命名习惯上，函数变量以 use 打头</li><li>state 定义数据格式</li><li>actions 定义操作数据的方法 get 方法用来获取用户信息 update 方法用来修改用户信息</li><li>由于 useRequest 必须放在 setup 函数内，这里简化起见，直接使用了 axios</li></ul><p>获取用户信息</p><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;div class=\"a6main\"&gt;\n    &lt;a-layout&gt;\n      &lt;a-layout-header&gt;\n        &lt;span&gt;{{serverUsername}} 【{{userInfo.name}} - {{userInfo.sex}}】&lt;/span&gt;\n      &lt;/a-layout-header&gt;\n      &lt;a-layout&gt;\n        &lt;!-- ... --&gt;\n      &lt;/a-layout&gt;\n    &lt;/a-layout&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script setup lang=\"ts\"&gt;\nimport { onMounted } from \'vue\';\nimport AIcon from \'../components/AIcon3\' // jsx icon 组件\nimport { serverMenus, serverUsername } from \'../router/a6router\'\nimport { useUserInfo } from \'../store/UserInfo\'\nconst userInfo = useUserInfo()\n\nonMounted(()=&gt;{\n  userInfo.get(serverUsername.value)\n})\n&lt;/script&gt;\n</code></pre><p>修改用户信息</p><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;div class=\"a6p1\"&gt;\n    &lt;h3&gt;修改用户信息&lt;/h3&gt;\n    &lt;hr&gt;\n    &lt;a-form&gt;\n      &lt;a-form-item label=\"用户名\"&gt;\n        &lt;a-input readonly v-model:value=\"dto.username\"&gt;&lt;/a-input&gt;\n      &lt;/a-form-item&gt;\n      &lt;a-form-item label=\"姓名\" v-bind=\"validateInfos.name\"&gt;\n        &lt;a-input v-model:value=\"dto.name\"&gt;&lt;/a-input&gt;\n      &lt;/a-form-item&gt;\n      &lt;a-form-item label=\"性别\"&gt;\n        &lt;a-radio-group v-model:value=\"dto.sex\"&gt;\n          &lt;a-radio-button value=\"男\"&gt;男&lt;/a-radio-button&gt;\n          &lt;a-radio-button value=\"女\"&gt;女&lt;/a-radio-button&gt;\n        &lt;/a-radio-group&gt;\n      &lt;/a-form-item&gt;\n    &lt;/a-form&gt;\n    &lt;a-button type=\"primary\" @click=\"onClick\"&gt;确定&lt;/a-button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script setup lang=\"ts\"&gt;\nimport { Form } from \'ant-design-vue\'\nimport { onMounted, ref } from \'vue\'\nimport { UserInfoDto } from \'../model/Model8080\'\nimport { useUserInfo } from \'../store/UserInfo\';\nconst dto = ref&lt;UserInfoDto&gt;({ username: \'\', name: \'\', sex: \'\' })\nconst userInfo = useUserInfo()\nonMounted(()=&gt;{\n  Object.assign(dto.value, userInfo)\n})\nconst rules = ref({\n  name: [\n    {required: true, message:\'姓名必填\'}\n  ]\n})\nconst { validateInfos, validate } = Form.useForm(dto, rules)\nasync function onClick() {\n  try {\n    await validate()\n    await userInfo.update(dto.value)\n  } catch (e) {\n    console.error(e)\n  }\n}\n&lt;/script&gt;\n</code></pre><ul><li>不能直接把 userInfo 绑定到表单，需要 dto 中转一下</li><li>userInfo.update 和 useInfo.get 返回的都是 Promise 对象，可以配合 await 一起用</li></ul><h3>后记</h3><p>vite + vue3 + vue-router + ts 还没有太多成熟的项目范例，可以参考 <a href=\"https://github.com/sendya/preview-pro\" target=\"\">GitHub - sendya/preview-pro: Use pro-layout in vitejs. preview https://sendya.github.io/preview-pro/index.html</a>，它提供了基本的布局和样例代码</p>', '林志杰', '1626518508932235265', 1, 2, 1, '2023-05-17 19:28:56.201', '2023-05-31 00:00:00.051');
INSERT INTO `blog` VALUES ('a9ff1bf7223b5478a6d4d8038a32f8dd', '毕业啦', 'http://rt6vvz8xh.bkt.clouddn.com/blogFile/1629495477589856258/b219ebc4b74543a9e3e0ca386c1dac8eb8011464.webp', '“博客”当然是个大家都陌生的名词,博客的英文名词就是“Blog或Weblog”(指人时对应于Blogger),是一个典型的网络新事物,查阅最新的英文词典也不可能查到', '<p>6666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666</p>', '林志杰', '1626518508932235265', 1, 1, 0, '2023-05-02 18:45:46.750', '2023-05-17 00:00:00.178');
INSERT INTO `blog` VALUES ('d66d1121624f62a98054335a7acdda1e', '07_Java程序员要掌握的前端_HTM', 'http://rusndkp3v.bkt.clouddn.com/blogFile/1629495477589856258/html.jpg', '前端老师不知道后端学员的痛点，他认为重要的咱不关心，他认为是常识一带而过的又恰恰是咱迷茫的地方，作为后端老师，我更懂后端学员', '<h1>前言</h1><p>Java 程序员一提起前端知识，心情那是五味杂陈，百感交集。</p><ul><li>说不学它吧，说不定进公司以后，就会被抓壮丁去时不时写点前端代码</li><li>说学它吧，HTML、CSS、JavaScript 哪个不得下大功夫才能精通？</li><li>学一点够不够用呢？如果只学基础的 JavaScript 是不够用的，前端都已经工程化了，Vue、React 这些框架你去看吧，光有点基础根本看不懂，甚至连前端页面路径在哪儿配置，如何跳转都不甚了解，所以得学，而且要学的还不少，请把前端当作 web 不可或缺的一部分来学习。</li><li>学习前端好处挺多，我听说过这么一句挺有道理的话：一个程序员至少应该掌握一门静态语言，如 Java，还应该掌握一门动态语言，如 JavaScript。而且，你不觉得学了前端，就如打通了程序员的任督二脉，可以独立接活了嘛</li></ul><p>这门课为什么不由前端老师来讲？</p><ul><li>前端老师不知道后端学员的痛点，他认为重要的咱不关心，他认为是常识一带而过的又恰恰是咱迷茫的地方，作为后端老师，我更懂后端学员</li><li>前端老师不懂后端知识，只能用前端思维来讲前端，如果授课老师懂 Java，能用一些现有知识对比讲解，能起到快速突破的效果</li><li>前端每个框架动辄需要数十个小时的学习，咱耗不起，我们更希望学到对我们最有用的那部分，其它的省省吧，总不能夺了前端程序员的饭碗</li></ul><p>课程安排</p><ul><li>整个课程分成五章</li></ul><h1>第一章. HTML 与 CSS</h1><p>HTML 是什么：即 HyperText Markup language 超文本标记语言，咱们熟知的网页就是用它编写的，HTML 的作用是定义网页的内容和结构。</p><ul><li>HyperText 是指用超链接的方式组织网页，把网页联系起来</li><li>Markup 是指用 <code>&lt;标签&gt;</code> 的方式赋予内容不同的功能和含义</li></ul><p>CSS 是什么：即 Cascading &nbsp;Style &nbsp;Sheets 级联（层叠）样式表，它描述了网页的表现与展示效果</p><h2>1. HTML 元素</h2><p>HTML 由一系列元素 <code>elements</code> 组成，例如</p><pre><code class=\"language-html\">&lt;p&gt;Hello, world!&lt;/p&gt;\n</code></pre><ul><li>整体称之为元素</li><li>&lt;p&gt; 和 &lt;/p&gt; 分别称为起始和结束标签</li><li>标签包围起来的 Hello, world 称之为内容</li><li>p 是预先定义好的 html 标签，作用是将内容作为一个单独的段落</li></ul><p>元素还可以有属性，如</p><pre><code class=\"language-html\">&lt;p id=\"p1\"&gt;Hello, world!&lt;/p&gt;\n</code></pre><ul><li>属性一般是预先定义好的，这里的 id 属性是给元素一个唯一的标识</li></ul><p>元素之间可以嵌套，如</p><pre><code class=\"language-html\">&lt;p&gt;HTML 是一门非常&lt;b&gt;强大&lt;/b&gt;的语言&lt;/p&gt;\n</code></pre><p>错误嵌套写法：</p><pre><code class=\"language-html\">&lt;p&gt;HTML 是一门非常&lt;b&gt;强大的语言&lt;/p&gt;&lt;/b&gt;\n</code></pre><p>不包含内容的元素称之为空元素，如</p><pre><code class=\"language-html\">&lt;img src=\"1.png\"&gt;\n&lt;img src=\"1.png\"/&gt;\n</code></pre><ul><li>img 作用是用来展示图片</li><li>src 属性用来指明图片路径</li></ul><h2>2. HTML 页面</h2><p>前面介绍的只是单独的 HTML 元素，它们可以充当一份完整的 HTML 页面的组成部分</p><pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;测试页面&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p id=\"p1\"&gt;Hello, world!&lt;/p&gt;\n    &lt;img src=\"1.png\"&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ul><li><code>html</code> 元素囊括了页面中所有其它元素，整个页面只需一个，称为根元素</li><li><code>head</code> 元素包含的是那些不用于展现内容的元素，如 <code>title</code>，<code>link</code>，<code>meta</code> 等</li><li><code>body</code> 元素包含了对用户展现内容的元素，例如后面会学到的用于展示文本、图片、视频、音频的各种元素</li></ul><h2>3. 常见元素</h2><h3>1) 文本</h3><h4>Heading</h4><pre><code class=\"language-html\">&lt;h1&gt;1号标题&lt;/h1&gt;\n&lt;h2&gt;2号标题&lt;/h2&gt;\n&lt;h3&gt;3号标题&lt;/h3&gt;\n&lt;h4&gt;4号标题&lt;/h4&gt;\n&lt;h5&gt;5号标题&lt;/h5&gt;\n&lt;h6&gt;6号标题&lt;/h6&gt;\n</code></pre><h4>Paragraph</h4><pre><code class=\"language-html\">&lt;p&gt;段落&lt;/p&gt;\n</code></pre><h4>List</h4><p>无序列表 unordered list</p><pre><code class=\"language-html\">&lt;ul&gt;\n    &lt;li&gt;列表项1&lt;/li&gt;\n    &lt;li&gt;列表项2&lt;/li&gt;\n    &lt;li&gt;列表项3&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre><p>有序列表</p><pre><code class=\"language-html\">&lt;ol&gt;\n    &lt;li&gt;列表项1&lt;/li&gt;\n    &lt;li&gt;列表项2&lt;/li&gt;\n    &lt;li&gt;列表项3&lt;/li&gt;\n&lt;/ol&gt;\n</code></pre><p>多级列表</p><pre><code class=\"language-html\">&lt;ul&gt;\n    &lt;li&gt;\n        北京市\n        &lt;ul&gt;\n            &lt;li&gt;海淀区&lt;/li&gt;\n            &lt;li&gt;朝阳区&lt;/li&gt;\n            &lt;li&gt;昌平区&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n        河北省\n        &lt;ul&gt;\n            &lt;li&gt;石家庄&lt;/li&gt;\n            &lt;li&gt;保定&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;\n</code></pre><h4>Anchor</h4><p>锚，超链接</p><pre><code class=\"language-html\">&lt;a href=\"网页地址\"&gt;超链接文本&lt;/a&gt;\n</code></pre><h3>2) 多媒体</h3><h4>Image</h4><pre><code class=\"language-html\">&lt;img src=\"文件路径\"&gt;\n</code></pre><p>src 格式有 3 种</p><ul><li>文件地址</li><li>data URL，格式如下 data:媒体类型;base64,数据</li><li>object URL，需要配合 javascript 使用</li></ul><h4>Video</h4><pre><code class=\"language-html\">&lt;video src=\"文件路径\"&gt;&lt;/video&gt;\n</code></pre><h4>Audio</h4><pre><code class=\"language-html\">&lt;audio src=\"文件路径\"&gt;&lt;/audio&gt;\n</code></pre><h3>3) 表单</h3><h4>作用与语法</h4><p>表单的作用：<strong>收集</strong>用户填入的<strong>数据</strong>，并将这些数据<strong>提交给服务器</strong></p><p>表单的语法</p><pre><code class=\"language-html\">&lt;form action=\"服务器地址\" method=\"请求方式\" enctype=\"数据格式\"&gt;\n    &lt;!-- 表单项 --&gt;\n    \n    &lt;input type=\"submit\" value=\"提交按钮\"&gt;\n&lt;/form&gt;\n</code></pre><ul><li>method 请求方式有 </li><li>enctype 在 post 请求时，指定请求体的数据格式</li><li>其中表单项提供多种收集数据的方式</li></ul><h4>常见的表单项</h4><p>文本框</p><pre><code class=\"language-html\">&lt;input type=\"text\" name=\"uesrname\"&gt;\n</code></pre><p>密码框</p><pre><code class=\"language-html\">&lt;input type=\"password\" name=\"password\"&gt;\n</code></pre><p>隐藏框</p><pre><code class=\"language-html\">&lt;input type=\"hidden\" name=\"id\"&gt;\n</code></pre><p>日期框</p><pre><code class=\"language-html\">&lt;input type=\"date\" name=\"birthday\"&gt;\n</code></pre><p>单选</p><pre><code class=\"language-html\">&lt;input type=\"radio\" name=\"sex\" value=\"男\" checked&gt;\n&lt;input type=\"radio\" name=\"sex\" value=\"女\"&gt;\n</code></pre><p>多选</p><pre><code class=\"language-html\">&lt;input type=\"checkbox\" name=\"fav\" value=\"唱歌\"&gt;\n&lt;input type=\"checkbox\" name=\"fav\" value=\"逛街\"&gt;\n&lt;input type=\"checkbox\" name=\"fav\" value=\"游戏\"&gt;\n</code></pre><p>文件上传</p><pre><code class=\"language-html\">&lt;input type=\"file\" name=\"avatar\"&gt;\n</code></pre><h2>4. HTTP 请求</h2><h3>1) 请求组成</h3><p>请求由三部分组成</p><ol><li>请求行</li><li>请求头</li><li>请求体</li></ol><p>可以用 telnet 程序测试</p><h3>2) 请求方式与数据格式</h3><h4>get 请求示例</h4><pre><code >GET /test2?name=%E5%BC%A0&age=20 HTTP/1.1\nHost: localhost\n</code></pre><ul><li>%E5%BC%A0 是【张】经过 URL 编码后的结果</li></ul><h4>post 请求示例</h4><pre><code >POST /test2 HTTP/1.1\nHost: localhost\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 21\n\nname=%E5%BC%A0&age=18\n</code></pre><p>application/x-www-form-urlencoed 格式细节：</p><ul><li>参数分成名字和值，中间用 = 分隔</li><li>多个参数使用 & 进行分隔</li><li>【张】等特殊字符需要用 encodeURIComponent() 编码为 【%E5%BC%A0】后才能发送</li></ul><h4>json 请求示例</h4><pre><code >POST /test3 HTTP/1.1\nHost: localhost\nContent-Type: application/json\nContent-Length: 25\n\n{\"name\":\"zhang\",\"age\":18}\n</code></pre><p>json 对象格式</p><pre><code >{\"属性名\":属性值}\n</code></pre><p>其中属性值可以是</p><ul><li>字符串 \"\"</li><li>数字</li><li>true, false</li><li>null</li><li>对象</li><li>数组</li></ul><p>json 数组格式</p><pre><code >[元素1, 元素2, ...]\n</code></pre><h4>multipart 请求示例</h4><pre><code >POST /test2 HTTP/1.1\nHost: localhost\nContent-Type: multipart/form-data; boundary=123\nContent-Length: 125\n\n--123\nContent-Disposition: form-data; name=\"name\"\n\nlisi\n--123\nContent-Disposition: form-data; name=\"age\"\n\n30\n--123--\n</code></pre><ul><li>boundary=123 用来定义分隔符</li><li>起始分隔符是 <code>--分隔符</code></li><li>结束分隔符是 <code>--分隔符--</code></li></ul><h4>数据格式小结</h4><p>客户端发送</p><ul><li>编码 </li><li>表单只支持以 application/x-www-form-urlencoded 和 multipart/form-data 格式发送数据</li><li>文件上传需要用 multipart/form-data 格式</li><li>js 代码可以支持任意格式发送数据</li></ul><p>服务端接收</p><ul><li>对 application/x-www-form-urlencoded 和 multipart/form-data 格式的数据，Spring 接收方式是统一的，只需要用 java bean 的属性名对应请求参数名即可</li><li>对于 applicaiton/json 格式的数据，Spring 接收需要使用 @RequestBody 注解 + java bean 的方式</li></ul><h3>3) session 原理</h3><p>Http 无状态，有会话</p><ul><li>无状态是指，请求之间相互独立，第一次请求的数据，第二次请求不能重用</li><li>有会话是指，客户端和服务端都有相应的技术，可以暂存数据，让数据在请求间共享</li></ul><p>服务端使用了 session 技术来暂存数据</p><p>存</p><pre><code >GET /s1?name=zhang HTTP/1.1\nHost: localhost\n</code></pre><p>取</p><pre><code >GET /s2 HTTP/1.1\nHost: localhost\nCookie: JSESSIONID=560FA845D02AE09B176E1BC5D9816A5D\n</code></pre><p>session 技术实现身份验证</p><pre><code class=\"language-mermaid\">sequenceDiagram\nparticipant Client\nparticipant L as LoginController\nparticipant i as LoginInterceptor\nparticipant Session\nrect rgb(200, 223, 255)\nClient -&gt;&gt; +L : 登录请求\nL -&gt;&gt; L : 检查用户名，密码，验证通过\nL -&gt;&gt; +Session : 存入用户名\nSession --&gt;&gt; -L: \nL --&gt;&gt; -Client: 登录成功\nend\nrect rgb(200, 190, 255)\nClient -&gt;&gt; +i : 其它请求\ni -&gt;&gt; +Session : 获取用户名\nSession --&gt;&gt; -i : \ni -&gt;&gt; i: 用户名存在，放行\ni --&gt;&gt; -Client : \nend\n</code></pre><h3>4) jwt 原理</h3><p>jwt 技术实现身份验证</p><pre><code class=\"language-mermaid\">sequenceDiagram\nparticipant Client\nparticipant L as LoginController\nparticipant i as LoginInterceptor\n\nrect rgb(200, 223, 255)\nClient -&gt;&gt; +L : 登录请求\nL -&gt;&gt; L : 检查用户名，密码，验证通过\nL --&gt;&gt; -Client : 登录成功，返回token\nend\n\nrect rgb(150, 190, 155)\nClient -&gt;&gt; +i : 其它请求，携带token\ni -&gt;&gt; i : 校验token，校验无误，放行\ni --&gt;&gt; -Client : \nend\n</code></pre><p>生成 token</p><pre><code >GET /j1?name=zhang&pass=123 HTTP/1.1\nHost: localhost\n</code></pre><p>校验 token</p><pre><code >GET /j2 HTTP/1.1\nHost: localhost\nAuthorization: eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhZG1pbiJ9._1-P_TLlzQPb1_lCyGwplMZaKQ8Mcw_plBbYPZ3OX28\n</code></pre><h2>5. CSS</h2><p>即 Cascading &nbsp;Style &nbsp;Sheets，它描述了网页的表现与展示效果</p><h3>1) 选择器</h3><ul><li>type 选择器 - 根据标签名进行匹配（元素选择器）</li><li>class 选择器 - 根据元素的 class 属性进行匹配</li><li>id 选择器 - 根据元素的 id 属性进行匹配</li></ul><h3>2) 属性和值</h3><ul><li>background-color : red;</li><li>...</li><li>display</li></ul><h3>3) 布局</h3><p>与布局相关的 html 元素</p><ul><li>div</li><li>template</li></ul>', '林志杰', '1626518508932235265', 1, 2, 1, '2023-05-17 17:35:56.854', '2023-05-31 00:00:00.051');
INSERT INTO `blog` VALUES ('e03dc851c11d00093784efcbc923d894', 'sql', 'http://rt6vvz8xh.bkt.clouddn.com/blogFile/1629495477589856258/b219ebc4b74543a9e3e0ca386c1dac8eb8011464.webp', '“博客”当然是个大家都陌生的名词,博客的英文名词就是“Blog或Weblog”(指人时对应于Blogger),是一个典型的网络新事物,查阅最新的英文词典也不可能查到', '啥计划的大啊啊所多', '林志杰', '1626518508932235265', 1, 1, 0, '2023-03-20 05:30:43.828', '2023-05-17 00:00:00.178');
INSERT INTO `blog` VALUES ('fddd1509a51d8ecbbd5c7a575b59b2dc', '09_Java程序员要掌握的前端vue2', 'http://rusndkp3v.bkt.clouddn.com/blogFile/1629495477589856258/vue2.webp', 'vue2', '<h1>三. Vue 2</h1><h2>1. Vue 基础</h2><h3>1) 环境准备</h3><h4>安装脚手架</h4><pre><code >npm install -g @vue/cli\n</code></pre><ul><li>-g 参数表示全局安装，这样在任意目录都可以使用 vue 脚本创建项目</li></ul><h4>创建项目</h4><pre><code class=\"language-cmd\">vue ui\n</code></pre><p>使用图形向导来创建 vue 项目，如下图，输入项目名</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220815141136895.png\" alt=\"image-20220815141136895\" data-href=\"\" style=\"\"/></p><p>选择手动配置项目</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220815141312244.png\" alt=\"image-20220815141312244\" data-href=\"\" style=\"\"/></p><p>添加 vue router 和 vuex</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220815141412380.png\" alt=\"image-20220815141412380\" data-href=\"\" style=\"\"/></p><p>选择版本，创建项目</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220815141459878.png\" alt=\"image-20220815141459878\" data-href=\"\" style=\"\"/></p><h4>安装 devtools</h4><ul><li>devtools 插件网址：<a href=\"https://devtools.vuejs.org/guide/installation.html\" target=\"\">https://devtools.vuejs.org/guide/installation.html</a></li></ul><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220815141648040.png\" alt=\"image-20220815141648040\" data-href=\"\" style=\"\"/></p><h4>运行项目</h4><p>进入项目目录，执行</p><pre><code class=\"language-cmd\">npm run serve\n</code></pre><h4>修改端口</h4><p>前端服务器默认占用了 8080 端口，需要修改一下</p><ul><li>文档地址：DevServer | webpack</li><li>打开 vue.config.js 添加 const { defineConfig } = require(\'@vue/cli-service\') module.exports = defineConfig({ // ... devServer: { port: 7070 } })</li></ul><h4>添加代理</h4><p>为了避免前后端服务器联调时， fetch、xhr 请求产生跨域问题，需要配置代理</p><ul><li>文档地址同上</li><li>打开 vue.config.js 添加 const { defineConfig } = require(\'@vue/cli-service\') module.exports = defineConfig({ // ... devServer: { port: 7070, proxy: { \'/api\': { target: \'http://localhost:8080\', changeOrigin: true } } } })</li></ul><h4>Vue 项目结构</h4><pre><code >PS D:\\2022.js\\代码\\第3章\\client&gt; tree src\nD:\\2022.JS\\代码\\第3章\\CLIENT\\SRC\n├─assets\n├─components\n├─router\n├─store\n└─views\n</code></pre><ul><li>assets - 静态资源</li><li>components - 可重用组件</li><li>router - 路由</li><li>store - 数据共享</li><li>views - 视图组件</li></ul><p>以后还会添加</p><ul><li>api - 跟后台交互，发送 fetch、xhr 请求，接收响应</li><li>plugins - 插件</li></ul><h3>2) Vue 组件</h3><p>Vue 的组件文件以 .vue 结尾，每个组件由三部分组成</p><pre><code class=\"language-vue\">&lt;template&gt;&lt;/template&gt;\n\n&lt;script&gt;&lt;/script&gt;\n\n&lt;style&gt;&lt;/style&gt;\n</code></pre><ul><li>template 模板部分，由它生成 html 代码</li><li>script 代码部分，控制模板的数据来源和行为</li><li>style 样式部分，一般不咋关心</li></ul><p>入口组件是 App.vue</p><p>先删除原有代码，来个 Hello, World 例子</p><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;h1&gt;{{msg}}&lt;/h1&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  data() {\n    return {\n      msg: \"Hello, Vue!\"\n    }\n  }\n}\n&lt;/script&gt;\n</code></pre><p>解释</p><ul><li>export default 导出组件对象，供 main.js 导入使用</li><li>这个对象有一个 data 方法，返回一个<strong>对象</strong>，给 template 提供数据</li><li><code>{{}}</code> 在 Vue 里称之为插值表达式，用来<strong>绑定</strong> data 方法返回的<strong>对象</strong>属性，<strong>绑定</strong>的含义是数据发生变化时，页面显示会同步变化</li></ul><h4>文本插值</h4><pre><code class=\"language-vue\">&lt;template&gt;\n    &lt;div&gt;\n        &lt;h1&gt;{{ name }}&lt;/h1&gt;\n        &lt;h1&gt;{{ age &gt; 60 ? \'老年\' : \'青年\' }}&lt;/h1&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nconst options = {\n    data: function () {\n        return { name: \'张三\', age: 70 };\n    }\n};\nexport default options;\n&lt;/script&gt;\n</code></pre><ul><li><code>{{}}</code> 里只能绑定一个属性，绑定多个属性需要用多个 <code>{{}}</code> 分别绑定</li><li>template 内只能有一个根元素</li><li>插值内可以进行简单的表达式计算</li></ul><h4>属性绑定</h4><pre><code class=\"language-vue\">&lt;template&gt;\n    &lt;div&gt;\n        &lt;div&gt;&lt;input type=\"text\" v-bind:value=\"name\"&gt;&lt;/div&gt;\n        &lt;div&gt;&lt;input type=\"date\" v-bind:value=\"birthday\"&gt;&lt;/div&gt;\n        &lt;div&gt;&lt;input type=\"text\" :value=\"age\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nconst options = {\n    data: function () {\n        return { name: \'王五\', birthday: \'1995-05-01\', age: 20 };\n    }\n};\nexport default options;\n&lt;/script&gt;\n</code></pre><ul><li>简写方式：可以省略 v-bind 只保留冒号</li></ul><h4>事件绑定</h4><pre><code class=\"language-vue\">&lt;!-- 事件绑定 --&gt;\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;div&gt;&lt;input type=\"button\" value=\"点我执行m1\" v-on:click=\"m1\"&gt;&lt;/div&gt;\n        &lt;div&gt;&lt;input type=\"button\" value=\"点我执行m2\" @click=\"m2\"&gt;&lt;/div&gt;\n        &lt;div&gt;{{count}}&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nconst options = {\n    data: function () {\n        return { count: 0 };\n    },\n    methods: {\n        m1() {\n            this.count ++;\n            console.log(\"m1\")\n        },\n        m2() {\n            this.count --;\n            console.log(\"m2\")\n        }\n    }\n};\nexport default options;\n&lt;/script&gt;\n</code></pre><ul><li>简写方式：可以把 v-on: 替换为 @</li><li>在 methods 方法中的 this 代表的是 data 函数返回的数据对象</li></ul><h4>双向绑定</h4><pre><code class=\"language-vue\">&lt;template&gt;\n    &lt;div&gt;\n        &lt;div&gt;\n            &lt;label for=\"\"&gt;请输入姓名&lt;/label&gt;\n            &lt;input type=\"text\" v-model=\"name\"&gt;\n        &lt;/div&gt;\n        &lt;div&gt;\n            &lt;label for=\"\"&gt;请输入年龄&lt;/label&gt;\n            &lt;input type=\"text\" v-model=\"age\"&gt;\n        &lt;/div&gt;\n        &lt;div&gt;\n            &lt;label for=\"\"&gt;请选择性别&lt;/label&gt;\n            男 &lt;input type=\"radio\" value=\"男\" v-model=\"sex\"&gt;\n            女 &lt;input type=\"radio\" value=\"女\" v-model=\"sex\"&gt;\n        &lt;/div&gt;\n        &lt;div&gt;\n            &lt;label for=\"\"&gt;请选择爱好&lt;/label&gt;\n            游泳 &lt;input type=\"checkbox\" value=\"游泳\" v-model=\"fav\"&gt;\n            打球 &lt;input type=\"checkbox\" value=\"打球\" v-model=\"fav\"&gt;\n            健身 &lt;input type=\"checkbox\" value=\"健身\" v-model=\"fav\"&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nconst options = {\n    data: function () {\n        return { name: \'\', age: null, sex:\'男\' , fav:[\'打球\']};\n    },\n    methods: {\n    }\n};\nexport default options;\n&lt;/script&gt;\n</code></pre><ul><li>用 v-model 实现双向绑定，即 </li><li>双向绑定只适用于表单这种带【输入】功能的标签，其它标签的数据绑定，单向就足够了</li><li>复选框这种标签，双向绑定的 javascript 数据类型一般用数组</li></ul><h4>计算属性</h4><pre><code class=\"language-vue\">&lt;!-- 计算属性 --&gt;\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;h2&gt;{{fullName}}&lt;/h2&gt;\n        &lt;h2&gt;{{fullName}}&lt;/h2&gt;\n        &lt;h2&gt;{{fullName}}&lt;/h2&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nconst options = {\n    data: function () {\n        return { firstName: \'三\', lastName: \'张\' };\n    },\n    /* methods: {\n        fullName() {\n            console.log(\'进入了 fullName\')\n            return this.lastName + this.firstName;\n        }\n    },*/\n    computed: {\n        fullName() {\n            console.log(\'进入了 fullName\')\n            return this.lastName + this.firstName;\n        }\n    }\n};\nexport default options;\n</code></pre><ul><li>普通方法调用必须加 ()，没有缓存功能</li><li>计算属性使用时就把它当属性来用，不加 ()，有缓存功能：</li></ul><h4>axios</h4><p>axios 它的底层是用了 XMLHttpRequest（xhr）方式发送请求和接收响应，xhr 相对于之前讲过的 fetch api 来说，功能更强大，但由于是比较老的 api，不支持 Promise，axios 对 xhr 进行了封装，使之支持 Promise，并提供了对请求、响应的统一拦截功能</p><p>安装</p><pre><code class=\"language-cmd\">npm install axios -S\n</code></pre><p>导入</p><pre><code class=\"language-js\">import axios from \'axios\'\n</code></pre><ul><li>axios 默认导出一个对象，这里的 import 导入的就是它默认导出的对象</li></ul><p>方法</p><table style=\"width: auto;\"><tbody><tr><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">请求</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">备注</th></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">axios.get(url[, config])</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">:star:</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">axios.delete(url[, config])</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\"></td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">axios.head(url[, config])</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\"></td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">axios.options(url[, config])</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\"></td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">axios.post(url[, data[, config]])</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">:star:</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">axios.put(url[, data[, config]])</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\"></td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">axios.patch(url[, data[, config]])</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\"></td></tr></tbody></table><ul><li>config - 选项对象、例如查询参数、请求头...</li><li>data - 请求体数据、最常见的是 json 格式数据</li><li>get、head 请求无法携带请求体，这应当是浏览器的限制所致（xhr、fetch api 均有限制）</li><li>options、delete 请求可以通过 config 中的 data 携带请求体</li></ul><p>例子</p><pre><code class=\"language-vue\">&lt;template&gt;\n    &lt;div&gt;\n        &lt;input type=\"button\" value=\"获取远程数据\" @click=\"sendReq()\"&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport axios from \'axios\'\nconst options = {\n    methods: {\n        async sendReq() {\n            // 1. 演示 get, post\n            // const resp = await axios.post(\'/api/a2\');\n\n            // 2. 发送请求头\n            // const resp = await axios.post(\'/api/a3\',{},{\n            //     headers:{\n            //         Authorization:\'abc\'\n            //     }\n            // });\n\n            // 3. 发送请求时携带查询参数 ?name=xxx&age=xxx\n            // const name = encodeURIComponent(\'&&&\');\n            // const age = 18;\n            // const resp = await axios.post(`/api/a4?name=${name}&age=${age}`);\n\n            // 不想自己拼串、处理特殊字符、就用下面的办法\n            // const resp = await axios.post(\'/api/a4\', {}, {\n            //     params: {\n            //         name:\'&&&&\',\n            //         age: 20\n            //     }\n            // });\n\n            // 4. 用请求体发数据，格式为 urlencoded\n            // const params = new URLSearchParams();\n            // params.append(\"name\", \"张三\");\n            // params.append(\"age\", 24)\n\n            // const resp = await axios.post(\'/api/a4\', params);\n\n            // 5. 用请求体发数据，格式为 multipart\n            // const params = new FormData();\n            // params.append(\"name\", \"李四\");\n            // params.append(\"age\", 30);\n            // const resp = await axios.post(\'/api/a5\', params);\n\n            // 6. 用请求体发数据，格式为 json\n            const resp = await axios.post(\'/api/a5json\', {\n                name: \'王五\',\n                age: 50\n            });\n\n            console.log(resp);\n        }\n    }\n};\nexport default options;\n&lt;/script&gt;\n</code></pre><p>创建实例</p><pre><code class=\"language-js\">const _axios = axios.create(config);\n</code></pre><ul><li>axios 对象可以直接使用，但使用的是默认的设置</li><li>用 axios.create 创建的对象，可以覆盖默认设置，config 见下面说明</li></ul><p>常见的 config 项有</p><table style=\"width: auto;\"><tbody><tr><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">名称</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">含义</th></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">baseURL</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">将自动加在 url 前面</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">headers</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">请求头，类型为简单对象</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">params</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">跟在 URL 后的请求参数，类型为简单对象或 URLSearchParams</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">data</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">请求体，类型有简单对象、FormData、URLSearchParams、File 等</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">withCredentials</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">跨域时是否携带 Cookie 等凭证，默认为 false</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">responseType</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">响应类型，默认为 json</td></tr></tbody></table><p>例</p><pre><code class=\"language-js\">const _axios = axios.create({\n    baseURL: \'http://localhost:8080\',\n    withCredentials: true\n});\nawait _axios.post(\'/api/a6set\')\nawait _axios.post(\'/api/a6get\')\n</code></pre><ul><li>生产环境希望 xhr 请求不走代理，可以用 baseURL 统一修改</li><li>希望跨域请求携带 cookie，需要配置 withCredentials: true，服务器也要配置 allowCredentials = true，否则浏览器获取跨域返回的 cookie 时会报错</li></ul><p>响应格式</p><table style=\"width: auto;\"><tbody><tr><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">名称</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">含义</th></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">data</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">响应体数据 :star:</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">status</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">状态码 :star:</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">headers</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">响应头</td></tr></tbody></table><ul><li>200 表示响应成功</li><li>400 请求数据不正确 age=abc</li><li>401 身份验证没通过</li><li>403 没有权限</li><li>404 资源不存在</li><li>405 不支持请求方式 post</li><li>500 服务器内部错误</li></ul><p>请求拦截器</p><pre><code class=\"language-js\">_axios.interceptors.request.use(\n  function(config) {\n    // 比如在这里添加统一的 headers\n    return config;\n  },\n  function(error) {\n    return Promise.reject(error);\n  }\n);\n</code></pre><p>响应拦截器</p><pre><code class=\"language-js\">_axios.interceptors.response.use(\n  function(response) {\n    // 2xx 范围内走这里\n    return response;\n  },\n  function(error) {\n    // 超出 2xx, 比如 4xx, 5xx 走这里\n    return Promise.reject(error);\n  }\n);\n</code></pre><h4>条件渲染</h4><pre><code class=\"language-vue\">&lt;template&gt;\n    &lt;div&gt;\n        &lt;input type=\"button\" value=\"获取远程数据\" @click=\"sendReq()\"&gt;\n        &lt;div class=\"title\"&gt;学生列表&lt;/div&gt;\n        &lt;div class=\"thead\"&gt;\n            &lt;div class=\"row bold\"&gt;\n                &lt;div class=\"col\"&gt;编号&lt;/div&gt;\n                &lt;div class=\"col\"&gt;姓名&lt;/div&gt;\n                &lt;div class=\"col\"&gt;性别&lt;/div&gt;\n                &lt;div class=\"col\"&gt;年龄&lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=\"tbody\"&gt;\n            &lt;div class=\"row\" v-if=\"students.length &gt; 0\"&gt;显示学生数据&lt;/div&gt;\n            &lt;div class=\"row\" v-else&gt;暂无学生数据&lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport axios from \'../util/myaxios\'\nconst options = {\n    data: function() {\n        return {\n            students: []\n        };\n    },\n    methods : {\n        async sendReq() {\n            const resp = await axios.get(\"/api/students\");\n            console.log(resp.data.data)\n            this.students = resp.data.data;\n        }\n    }\n};\nexport default options;\n&lt;/script&gt;\n&lt;style scoped&gt;\n    div {\n        font-family: 华文行楷;\n        font-size: 20px;\n    }\n\n    .title {\n        margin-bottom: 10px;\n        font-size: 30px;\n        color: #333;\n        text-align: center;\n    }\n\n    .row {\n        background-color: #fff;\n        display: flex;\n        justify-content: center;\n    }\n\n    .col {\n        border: 1px solid #f0f0f0;\n        width: 15%;\n        height: 35px;\n        text-align: center;\n        line-height: 35px;\n    }\n\n    .bold .col {\n        background-color: #f1f1f1;\n    }\n&lt;/style&gt;\n</code></pre><h4>列表渲染</h4><pre><code class=\"language-vue\">&lt;template&gt;\n    &lt;div&gt;\n        &lt;!-- &lt;input type=\"button\" value=\"获取远程数据\" @click=\"sendReq()\"&gt; --&gt;\n        &lt;div class=\"title\"&gt;学生列表&lt;/div&gt;\n        &lt;div class=\"thead\"&gt;\n            &lt;div class=\"row bold\"&gt;\n                &lt;div class=\"col\"&gt;编号&lt;/div&gt;\n                &lt;div class=\"col\"&gt;姓名&lt;/div&gt;\n                &lt;div class=\"col\"&gt;性别&lt;/div&gt;\n                &lt;div class=\"col\"&gt;年龄&lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=\"tbody\"&gt;\n            &lt;div v-if=\"students.length &gt; 0\"&gt;\n                &lt;div class=\"row\" v-for=\"s of students\" :key=\"s.id\"&gt;\n                    &lt;div class=\"col\"&gt;{{s.id}}&lt;/div&gt;\n                    &lt;div class=\"col\"&gt;{{s.name}}&lt;/div&gt;\n                    &lt;div class=\"col\"&gt;{{s.sex}}&lt;/div&gt;\n                    &lt;div class=\"col\"&gt;{{s.age}}&lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"row\" v-else&gt;暂无学生数据&lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport axios from \'../util/myaxios\'\nconst options = {\n    mounted: function(){\n        this.sendReq()\n    },\n    data: function() {\n        return {\n            students: []\n        };\n    },\n    methods : {\n        async sendReq() {\n            const resp = await axios.get(\"/api/students\");\n            console.log(resp.data.data)\n            this.students = resp.data.data;\n        }\n    }\n};\nexport default options;\n&lt;/script&gt;\n&lt;style scoped&gt;\n    div {\n        font-family: 华文行楷;\n        font-size: 20px;\n    }\n\n    .title {\n        margin-bottom: 10px;\n        font-size: 30px;\n        color: #333;\n        text-align: center;\n    }\n\n    .row {\n        background-color: #fff;\n        display: flex;\n        justify-content: center;\n    }\n\n    .col {\n        border: 1px solid #f0f0f0;\n        width: 15%;\n        height: 35px;\n        text-align: center;\n        line-height: 35px;\n    }\n\n    .bold .col {\n        background-color: #f1f1f1;\n    }\n&lt;/style&gt;\n</code></pre><ul><li>v-if 和 v-for 不能用于同一个标签</li><li>v-for 需要配合特殊的标签属性 key 一起使用，并且 key 属性要绑定到一个能起到唯一标识作用的数据上，本例绑定到了学生编号上</li><li>options 的 mounted 属性对应一个函数，此函数会在组件挂载后（准备就绪）被调用，可以在它内部发起请求，去获取学生数据</li></ul><h4>重用组件</h4><p>按钮组件</p><pre><code class=\"language-vue\">&lt;template&gt;\n    &lt;div class=\"button\" :class=\"[type,size]\"&gt;\n        a&lt;slot&gt;&lt;/slot&gt;b\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nconst options = {\n    props: [\"type\", \"size\"]\n};\nexport default options;\n&lt;/script&gt;\n</code></pre><ul><li>注意，省略了样式部分</li></ul><p>使用组件</p><pre><code class=\"language-vue\">&lt;template&gt;\n    &lt;div&gt;\n        &lt;h1&gt;父组件&lt;/h1&gt;\n        &lt;my-button type=\"primary\" size=\"small\"&gt;1&lt;/my-button&gt;\n        &lt;my-button type=\"danger\" size=\"middle\"&gt;2&lt;/my-button&gt;\n        &lt;my-button type=\"success\" size=\"large\"&gt;3&lt;/my-button&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport MyButton from \'../components/MyButton.vue\'\nconst options = {\n    components: {\n        MyButton\n    }\n};\nexport default options;\n&lt;/script&gt;\n</code></pre><h2>2. Vue 进阶</h2><h3>1) ElementUI</h3><p>安装</p><pre><code class=\"language-cmd\">npm install element-ui -S\n</code></pre><p>引入组件</p><pre><code class=\"language-js\">import Element from \'element-ui\'\nimport \'element-ui/lib/theme-chalk/index.css\'\n\nVue.use(Element)\n</code></pre><p>测试，在自己的组件中使用 ElementUI 的组件</p><pre><code class=\"language-vue\">&lt;el-button&gt;按钮&lt;/el-button&gt;\n</code></pre><h4>表格组件</h4><pre><code class=\"language-vue\">&lt;template&gt;\n    &lt;div&gt;\n        &lt;el-table :data=\"students\"&gt;\n            &lt;el-table-column label=\"编号\" prop=\"id\"&gt;&lt;/el-table-column&gt;\n            &lt;el-table-column label=\"姓名\" prop=\"name\"&gt;&lt;/el-table-column&gt;\n            &lt;el-table-column label=\"性别\" prop=\"sex\"&gt;&lt;/el-table-column&gt;\n            &lt;el-table-column label=\"年龄\" prop=\"age\"&gt;&lt;/el-table-column&gt;\n        &lt;/el-table&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport axios from \'../util/myaxios\'\nconst options = {\n    async mounted() {\n        const resp = await axios.get(\'/api/students\');\n        this.students = resp.data.data\n    },\n    data() {\n        return {\n            students: []\n        }\n    }\n}\nexport default options;\n&lt;/script&gt;\n</code></pre><h4>分页组件</h4><pre><code class=\"language-vue\">&lt;template&gt;\n    &lt;div&gt;\n        &lt;el-table v-bind:data=\"students\"&gt;\n            &lt;el-table-column label=\"编号\" prop=\"id\"&gt;&lt;/el-table-column&gt;\n            &lt;el-table-column label=\"姓名\" prop=\"name\"&gt;&lt;/el-table-column&gt;\n            &lt;el-table-column label=\"性别\" prop=\"sex\"&gt;&lt;/el-table-column&gt;\n            &lt;el-table-column label=\"年龄\" prop=\"age\"&gt;&lt;/el-table-column&gt;\n        &lt;/el-table&gt;\n        &lt;el-pagination \n            :total=\"total\"\n            :page-size=\"queryDto.size\"\n            :current-page=\"queryDto.page\"\n            layout=\"prev,pager,next,sizes,-&gt;,total\"\n            :page-sizes=\"[5,10,15,20]\"\n            @current-change=\"currentChange\"\n            @size-change=\"sizeChange\"\n        &gt;&lt;/el-pagination&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport axios from \'../util/myaxios\'\nconst options = {\n    mounted() {\n        this.query();\n    },\n    methods: {\n        currentChange(page) {\n            this.queryDto.page = page;\n            this.query();\n        },\n        sizeChange(size){\n            this.queryDto.size = size;\n            this.query();\n        },\n        async query() {\n            const resp = await axios.get(\'/api/students/q\', {\n                params: this.queryDto\n            });\n            this.students = resp.data.data.list;\n            this.total = resp.data.data.total;\n        }\n    },\n    data() {\n        return {\n            students: [],\n            total: 0,\n            queryDto: {\n                page: 1,\n                size: 5\n            }\n        }\n    }\n}\nexport default options;\n&lt;/script&gt;\n</code></pre><ul><li>三种情况都应该触发查询</li><li>查询传参应该根据后台需求，灵活采用不同方式</li><li>返回响应的格式也许会很复杂，需要掌握【根据返回的响应结构，获取数据】的能力</li></ul><h4>分页搜索</h4><pre><code class=\"language-vue\">&lt;template&gt;\n    &lt;div&gt;\n        &lt;el-input placeholder=\"请输入姓名\" size=\"mini\" v-model=\"queryDto.name\"&gt;&lt;/el-input&gt;\n        &lt;el-select placeholder=\"请选择性别\" size=\"mini\" v-model=\"queryDto.sex\" clearable&gt;\n            &lt;el-option value=\"男\"&gt;&lt;/el-option&gt;\n            &lt;el-option value=\"女\"&gt;&lt;/el-option&gt;\n        &lt;/el-select&gt;\n        &lt;el-select placeholder=\"请选择年龄\" size=\"mini\" v-model=\"queryDto.age\" clearable&gt;\n            &lt;el-option value=\"0,20\" label=\"0到20岁\"&gt;&lt;/el-option&gt;\n            &lt;el-option value=\"21,30\" label=\"21到30岁\"&gt;&lt;/el-option&gt;\n            &lt;el-option value=\"31,40\" label=\"31到40岁\"&gt;&lt;/el-option&gt;\n            &lt;el-option value=\"41,120\" label=\"41到120岁\"&gt;&lt;/el-option&gt;\n        &lt;/el-select&gt;\n        &lt;el-button type=\"primary\" size=\"mini\" @click=\"search()\"&gt;搜索&lt;/el-button&gt;\n        &lt;el-divider&gt;&lt;/el-divider&gt;\n        &lt;el-table v-bind:data=\"students\"&gt;\n            &lt;el-table-column label=\"编号\" prop=\"id\"&gt;&lt;/el-table-column&gt;\n            &lt;el-table-column label=\"姓名\" prop=\"name\"&gt;&lt;/el-table-column&gt;\n            &lt;el-table-column label=\"性别\" prop=\"sex\"&gt;&lt;/el-table-column&gt;\n            &lt;el-table-column label=\"年龄\" prop=\"age\"&gt;&lt;/el-table-column&gt;\n        &lt;/el-table&gt;\n        &lt;el-pagination :total=\"total\" :page-size=\"queryDto.size\" :current-page=\"queryDto.page\"\n            layout=\"prev,pager,next,sizes,-&gt;,total\" :page-sizes=\"[5, 10, 15, 20]\" @current-change=\"currentChange\"\n            @size-change=\"sizeChange\"&gt;&lt;/el-pagination&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport axios from \'../util/myaxios\'\nconst options = {\n    mounted() {\n        this.query();\n    },\n    methods: {\n        currentChange(page) {\n            this.queryDto.page = page;\n            this.query();\n        },\n        sizeChange(size) {\n            this.queryDto.size = size;\n            this.query();\n        },\n        async query() {\n            const resp = await axios.get(\'/api/students/q\', {\n                params: this.queryDto\n            });\n            this.students = resp.data.data.list;\n            this.total = resp.data.data.total;\n        },\n        search() {\n            this.query();\n        }\n    },\n    data() {\n        return {\n            students: [],\n            total: 0,\n            queryDto: {\n                name: \'\',\n                sex: \'\',\n                age: \'\',  \n                page: 1,\n                size: 5\n            }\n        }\n    }\n}\nexport default options;\n&lt;/script&gt;\n</code></pre><ul><li>sex 与 &nbsp;age 均用 <code>\'\'</code> 表示用户没有选择的情况</li><li>age 取值 <code>0,20</code> 会被 spring 转换为 <code>new int[]{0, 20}</code></li><li>age 取值 <code>\'\'</code> 会被 spring 转换为 <code>new int[0]</code></li></ul><h4>级联选择</h4><p>级联选择器中选项的数据结构为</p><pre><code class=\"language-js\">[\n    {value:100, label:\'主页\',children:[\n        {value:101, label:\'菜单1\', children:[\n            {value:105, label:\'子项1\'},\n            {value:106, label:\'子项2\'}\n        ]},\n        {value:102, label:\'菜单2\', children:[\n            {value:107, label:\'子项3\'},\n            {value:108, label:\'子项4\'},\n            {value:109, label:\'子项5\'}\n        ]},\n        {value:103, label:\'菜单3\', children:[\n            {value:110, label:\'子项6\'},\n            {value:111, label:\'子项7\'}\n        ]},\n        {value:104, label:\'菜单4\'}\n    ]}\n]\n</code></pre><p>下面的例子是将后端返回的一维数组【树化】</p><pre><code class=\"language-vue\">&lt;template&gt;\n    &lt;el-cascader :options=\"ops\"&gt;&lt;/el-cascader&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport axios from \'../util/myaxios\'\nconst options = {\n    async mounted() {\n        const resp = await axios.get(\'/api/menu\')\n        console.log(resp.data.data)\n        const array = resp.data.data;\n\n        const map = new Map(); \n\n        // 1. 将所有数据存入 map 集合(为了接下来查找效率)\n        for(const {id,name,pid} of array) {\n            map.set(id, {value:id, label:name, pid:pid})\n        }\n        // 2. 建立父子关系\n        // 3. 找到顶层对象\n        const top = [];\n        for(const obj of map.values()) {\n            const parent = map.get(obj.pid);\n            if(parent !== undefined) {\n                parent.children ??= [];\n                parent.children.push(obj);\n            } else {\n                top.push(obj)\n            }\n        }\n        this.ops = top;\n    },\n    data(){\n        return {\n            ops: []\n        }\n    }\n};\nexport default options;\n&lt;/script&gt;\n</code></pre><h3>2) Vue-Router</h3><p>vue 属于单页面应用，所谓的路由，就是根据浏览器路径不同，用不同的<strong>视图组件</strong>替换这个页面内容展示</p><h4>配置路由</h4><p>新建一个路由 js 文件，例如 src/router/example14.js，内容如下</p><pre><code class=\"language-js\">import Vue from \'vue\'\nimport VueRouter from \'vue-router\'\nimport ContainerView from \'@/views/example14/ContainerView.vue\'\nimport LoginView from \'@/views/example14/LoginView.vue\'\nimport NotFoundView from \'@/views/example14/NotFoundView.vue\'\n\nVue.use(VueRouter)\n\nconst routes = [\n  {\n    path:\'/\',\n    component: ContainerView\n  },\n  {\n    path:\'/login\',\n    component: LoginView\n  },\n  {\n    path:\'/404\',\n    component: NotFoundView\n  }\n]\n\nconst router = new VueRouter({\n  routes\n})\n\nexport default router\n</code></pre><ul><li>最重要的就是建立了【路径】与【视图组件】之间的映射关系</li><li>本例中映射了 3 个路径与对应的视图组件</li></ul><p>在 main.js 中采用我们的路由 js</p><pre><code class=\"language-js\">import Vue from \'vue\'\nimport e14 from \'./views/Example14View.vue\'\nimport router from \'./router/example14\'  // 修改这里\nimport store from \'./store\'\nimport Element from \'element-ui\'\nimport \'element-ui/lib/theme-chalk/index.css\'\n\nVue.config.productionTip = false\n\nVue.use(Element)\nnew Vue({\n  router,\n  store,\n  render: h =&gt; h(e14)\n}).$mount(\'#app\')\n</code></pre><p>根组件是 Example14View.vue，内容为：</p><pre><code class=\"language-vue\">&lt;template&gt;\n    &lt;div class=\"all\"&gt;\n        &lt;router-view&gt;&lt;/router-view&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n</code></pre><ul><li>样式略</li><li>其中 <code>&lt;router-view&gt;</code> 起到占位作用，改变路径后，这个路径对应的视图组件就会占据 <code>&lt;router-view&gt;</code> 的位置，替换掉它之前的内容</li></ul><h4>动态导入</h4><pre><code class=\"language-js\">import Vue from \'vue\'\nimport VueRouter from \'vue-router\'\n\nVue.use(VueRouter)\n\nconst routes = [\n  {\n    path:\'/\',\n    component: () =&gt; import(\'@/views/example14/ContainerView.vue\')\n  },\n  {\n    path:\'/login\',\n    component: () =&gt; import(\'@/views/example14/LoginView.vue\')\n  },\n  {\n    path:\'/404\',\n    component: () =&gt; import(\'@/views/example14/NotFoundView.vue\')\n  }\n]\n\nconst router = new VueRouter({\n  routes\n})\n\nexport default router\n</code></pre><ul><li>静态导入是将所有组件的 js 代码打包到一起，如果组件非常多，打包后的 js 文件会很大，影响页面加载速度</li><li>动态导入是将组件的 js 代码放入独立的文件，用到时才加载</li></ul><h4>嵌套路由</h4><p>组件内再要切换内容，就需要用到嵌套路由（子路由），下面的例子是在【ContainerView 组件】内定义了 3 个子路由</p><pre><code class=\"language-js\">const routes = [\n  {\n    path:\'/\',\n    component: () =&gt; import(\'@/views/example14/ContainerView.vue\'),\n    redirect: \'/c/p1\',\n    children: [\n      { \n        path:\'c/p1\',\n        component: () =&gt; import(\'@/views/example14/container/P1View.vue\')\n      },\n      { \n        path:\'c/p2\',\n        component: () =&gt; import(\'@/views/example14/container/P2View.vue\')\n      },\n      { \n        path:\'c/p3\',\n        component: () =&gt; import(\'@/views/example14/container/P3View.vue\')\n      }\n    ]\n  },\n  {\n    path:\'/login\',\n    component: () =&gt; import(\'@/views/example14/LoginView.vue\')\n  },\n  {\n    path:\'/404\',\n    component: () =&gt; import(\'@/views/example14/NotFoundView.vue\')\n  },\n  {\n    path:\'*\',\n    redirect: \'/404\'\n  }\n]\n</code></pre><p>子路由变化，切换的是【ContainerView 组件】中 <code>&lt;router-view&gt;&lt;/router-view&gt;</code> 部分的内容</p><pre><code class=\"language-java\">&lt;template&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;router-view&gt;&lt;/router-view&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n</code></pre><ul><li>redirect 可以用来重定向（跳转）到一个新的地址</li><li>path 的取值为 * 表示匹配不到其它 path 时，就会匹配它</li></ul><h4>ElementUI 布局</h4><p>通常主页要做布局，下面的代码是 ElementUI 提供的【上-【左-右】】布局</p><pre><code class=\"language-vue\">&lt;template&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;el-container&gt;\n            &lt;el-header&gt;&lt;/el-header&gt;\n            &lt;el-container&gt;\n                &lt;el-aside width=\"200px\"&gt;&lt;/el-aside&gt;\n                &lt;el-main&gt;\n                    &lt;router-view&gt;&lt;/router-view&gt;\n                &lt;/el-main&gt;\n            &lt;/el-container&gt;\n        &lt;/el-container&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n</code></pre><h4>路由跳转</h4><h5>标签式</h5><pre><code class=\"language-vue\">&lt;el-aside width=\"200px\"&gt;\n    &lt;router-link to=\"/c1/p1\"&gt;P1&lt;/router-link&gt;\n    &lt;router-link to=\"/c1/p2\"&gt;P2&lt;/router-link&gt;\n    &lt;router-link to=\"/c1/p3\"&gt;P3&lt;/router-link&gt;\n&lt;/el-aside&gt;\n</code></pre><h5>编程式</h5><pre><code class=\"language-vue\">&lt;el-header&gt;\n    &lt;el-button type=\"primary\" icon=\"el-icon-edit\" \n               circle size=\"mini\" @click=\"jump(\'/c1/p1\')\"&gt;&lt;/el-button&gt;\n    &lt;el-button type=\"success\" icon=\"el-icon-check\" \n               circle size=\"mini\" @click=\"jump(\'/c1/p2\')\"&gt;&lt;/el-button&gt;\n    &lt;el-button type=\"warning\" icon=\"el-icon-star-off\" \n               circle size=\"mini\" @click=\"jump(\'/c1/p3\')\"&gt;&lt;/el-button&gt;\n&lt;/el-header&gt;\n</code></pre><p>jump 方法</p><pre><code class=\"language-vue\">&lt;script&gt;\nconst options = {\n    methods : {\n        jump(url) {\n            this.$router.push(url);\n        }\n    }\n}\nexport default options;\n&lt;/script&gt;\n</code></pre><ul><li>其中 this.$router 是拿到路由对象</li><li>push 方法根据 url 进行跳转</li></ul><h5>导航菜单</h5><pre><code class=\"language-vue\">&lt;el-menu router background-color=\"#545c64\" text-color=\"#fff\" active-text-color=\"#ffd04b\"&gt;\n    &lt;el-submenu index=\"/c1\"&gt;\n        &lt;span slot=\"title\"&gt;\n            &lt;i class=\"el-icon-platform-eleme\"&gt;&lt;/i&gt;\n            菜单1\n        &lt;/span&gt;\n        &lt;el-menu-item index=\"/c1/p1\"&gt;子项1&lt;/el-menu-item&gt;\n        &lt;el-menu-item index=\"/c1/p2\"&gt;子项2&lt;/el-menu-item&gt;\n        &lt;el-menu-item index=\"/c1/p3\"&gt;子项3&lt;/el-menu-item&gt;\n    &lt;/el-submenu&gt;\n    &lt;el-menu-item index=\"/c2\"&gt;\n        &lt;span slot=\"title\"&gt;\n            &lt;i class=\"el-icon-phone\"&gt;&lt;/i&gt;\n            菜单2\n        &lt;/span&gt;\n    &lt;/el-menu-item&gt;\n    &lt;el-menu-item index=\"/c3\"&gt;\n        &lt;span slot=\"title\"&gt;\n            &lt;i class=\"el-icon-star-on\"&gt;&lt;/i&gt;\n            菜单3\n        &lt;/span&gt;\n    &lt;/el-menu-item&gt;\n&lt;/el-menu&gt;\n</code></pre><ul><li>图标和菜单项文字建议用 <code>&lt;span slot=\'title\'&gt;&lt;/span&gt;</code> 包裹起来</li><li><code>el-menu</code> 标签上加上 <code>router</code> 属性，表示结合导航菜单与路由对象，此时，就可以利用菜单项的 <code>index</code> 属性来路由跳转</li></ul><h4>动态路由与菜单</h4><p>将菜单、路由信息（仅主页的）存入数据库中</p><pre><code class=\"language-sql\">insert into menu(id, name, pid, path, component, icon) values\n    (101, \'菜单1\', 0,   \'/m1\',    null,         \'el-icon-platform-eleme\'),\n    (102, \'菜单2\', 0,   \'/m2\',    null,         \'el-icon-delete-solid\'),\n    (103, \'菜单3\', 0,   \'/m3\',    null,         \'el-icon-s-tools\'),\n    (104, \'菜单4\', 0,   \'/m4\',    \'M4View.vue\', \'el-icon-user-solid\'),\n    (105, \'子项1\', 101, \'/m1/c1\', \'C1View.vue\', \'el-icon-s-goods\'),\n    (106, \'子项2\', 101, \'/m1/c2\', \'C2View.vue\', \'el-icon-menu\'),\n    (107, \'子项3\', 102, \'/m2/c3\', \'C3View.vue\', \'el-icon-s-marketing\'),\n    (108, \'子项4\', 102, \'/m2/c4\', \'C4View.vue\', \'el-icon-s-platform\'),\n    (109, \'子项5\', 102, \'/m2/c5\', \'C5View.vue\', \'el-icon-picture\'),\n    (110, \'子项6\', 103, \'/m3/c6\', \'C6View.vue\', \'el-icon-upload\'),\n    (111, \'子项7\', 103, \'/m3/c7\', \'C7View.vue\', \'el-icon-s-promotion\');\n</code></pre><p>不同的用户查询的的菜单、路由信息是不一样的</p><p>例如：访问 <code>/api/menu/admin</code> 返回所有的数据</p><pre><code class=\"language-json\">[\n    {\n        \"id\": 102,\n        \"name\": \"菜单2\",\n        \"icon\": \"el-icon-delete-solid\",\n        \"path\": \"/m2\",\n        \"pid\": 0,\n        \"component\": null\n    },\n    {\n        \"id\": 107,\n        \"name\": \"子项3\",\n        \"icon\": \"el-icon-s-marketing\",\n        \"path\": \"/m2/c3\",\n        \"pid\": 102,\n        \"component\": \"C3View.vue\"\n    },\n    {\n        \"id\": 108,\n        \"name\": \"子项4\",\n        \"icon\": \"el-icon-s-platform\",\n        \"path\": \"/m2/c4\",\n        \"pid\": 102,\n        \"component\": \"C4View.vue\"\n    },\n    {\n        \"id\": 109,\n        \"name\": \"子项5\",\n        \"icon\": \"el-icon-picture\",\n        \"path\": \"/m2/c5\",\n        \"pid\": 102,\n        \"component\": \"C5View.vue\"\n    }\n]\n</code></pre><p>访问 <code>/api/menu/wang</code> 返回</p><pre><code class=\"language-json\">[\n    {\n        \"id\": 103,\n        \"name\": \"菜单3\",\n        \"icon\": \"el-icon-s-tools\",\n        \"path\": \"/m3\",\n        \"pid\": 0,\n        \"component\": null\n    },\n    {\n        \"id\": 110,\n        \"name\": \"子项6\",\n        \"icon\": \"el-icon-upload\",\n        \"path\": \"/m3/c6\",\n        \"pid\": 103,\n        \"component\": \"C6View.vue\"\n    },\n    {\n        \"id\": 111,\n        \"name\": \"子项7\",\n        \"icon\": \"el-icon-s-promotion\",\n        \"path\": \"/m3/c7\",\n        \"pid\": 103,\n        \"component\": \"C7View.vue\"\n    }\n]\n</code></pre><p>前端根据他们身份不同，动态添加路由和显示菜单</p><h5>动态路由</h5><pre><code class=\"language-js\">export function addServerRoutes(array) {\n  for (const { id, path, component } of array) {\n    if (component !== null) {\n      // 动态添加路由\n      // 参数1：父路由名称\n      // 参数2：路由信息对象\n      router.addRoute(\'c\', {\n        path: path,\n        name: id,\n        component: () =&gt; import(`@/views/example15/container/${component}`)\n      });\n    }\n  }\n}\n</code></pre><ul><li>js 这边只保留几个固定路由，如主页、404 和 login</li><li>以上方法执行时，将服务器返回的路由信息加入到名为 c 的父路由中去</li><li>这里要注意组件路径，前面 @/views 是必须在 js 这边完成拼接的，否则 import 函数会失效</li></ul><h5>重置路由</h5><p>在用户注销时应当重置路由</p><pre><code class=\"language-js\">export function resetRouter() {\n  router.matcher = new VueRouter({ routes }).matcher\n}\n</code></pre><h5>页面刷新</h5><p>页面刷新后，会导致动态添加的路由失效，解决方法是将路由数据存入 sessionStorage</p><pre><code class=\"language-vue\">&lt;script&gt;\nimport axios from \'@/util/myaxios\'\nimport {resetRouter, addServerRoutes} from \'@/router/example15\'\nconst options = {\n    data() {\n        return {\n            username: \'admin\'\n        }\n    },\n    methods: {\n        async login() {       \n            resetRouter(); // 重置路由     \n            const resp = await axios.get(`/api/menu/${this.username}`)\n            const array = resp.data.data;\n            // localStorage     即使浏览器关闭，存储的数据仍在\n            // sessionStorage   以标签页为单位，关闭标签页时，数据被清除\n            sessionStorage.setItem(\'serverRoutes\', JSON.stringify(array))\n            addServerRoutes(array); // 动态添加路由\n            this.$router.push(\'/\');\n        }\n    }\n}\nexport default options;\n&lt;/script&gt;\n</code></pre><p>页面刷新，重新创建路由对象时，从 sessionStorage 里恢复路由数据</p><pre><code class=\"language-js\">const router = new VueRouter({\n  routes\n})\n\n// 从 sessionStorage 中恢复路由数据\nconst serverRoutes = sessionStorage.getItem(\'serverRoutes\');\nif(serverRoutes) {\n  const array = JSON.parse(serverRoutes);\n  addServerRoutes(array) // 动态添加路由\n}\n</code></pre><h5>动态菜单</h5><p>代码部分</p><pre><code class=\"language-vue\">&lt;script&gt;\nconst options = {\n    mounted() {\n        const serverRoutes = sessionStorage.getItem(\'serverRoutes\');\n        const array = JSON.parse(serverRoutes);\n        const map = new Map();\n        for(const obj of array) {\n            map.set(obj.id, obj);\n        }\n        const top = [];\n        for(const obj of array) {\n            const parent = map.get(obj.pid);\n            if(parent) {\n                parent.children ??= [];\n                parent.children.push(obj);\n            } else {\n                top.push(obj);\n            }\n        }\n        this.top = top;\n    },\n    data() {\n        return {\n            top: []\n        }\n    }\n}\nexport default options;\n&lt;/script&gt;\n</code></pre><p>菜单部分</p><pre><code class=\"language-vue\">&lt;el-menu router background-color=\"#545c64\" text-color=\"#fff\" active-text-color=\"#ffd04b\" :unique-opened=\"true\"&gt;\n    &lt;template v-for=\"m1 of top\"&gt;\n&lt;el-submenu v-if=\"m1.children\" :key=\"m1.id\" :index=\"m1.path\"&gt;\n    &lt;span slot=\"title\"&gt;\n        &lt;i :class=\"m1.icon\"&gt;&lt;/i&gt; {{m1.name}}\n        &lt;/span&gt;\n    &lt;el-menu-item v-for=\"m2 of m1.children\" :key=\"m2.id\" :index=\"m2.path\"&gt;\n        &lt;span slot=\"title\"&gt;\n            &lt;i :class=\"m2.icon\"&gt;&lt;/i&gt; {{m2.name}}\n        &lt;/span&gt;\n        &lt;/el-menu-item&gt;\n        &lt;/el-submenu&gt;\n&lt;el-menu-item v-else :key=\"m1.id\" :index=\"m1.path\"&gt;\n    &lt;span slot=\"title\"&gt;\n        &lt;i :class=\"m1.icon\"&gt;&lt;/i&gt; {{m1.name}}\n        &lt;/span&gt;\n        &lt;/el-menu-item&gt;\n    &lt;/template&gt;\n&lt;/el-menu&gt;\n</code></pre><ul><li>没有考虑递归菜单问题，认为菜单只有两级</li></ul><h3>3) Vuex</h3><h4>入门</h4><p>vuex 可以在多个组件之间共享数据，并且共享的数据是【响应式】的，即数据的变更能及时渲染到模板</p><ul><li>与之对比 localStorage 与 sessionStorage 也能共享数据，但缺点是数据并非【响应式】</li></ul><p>首先需要定义 state 与 mutations 他们一个用来读取共享数据，一个用来修改共享数据</p><p>src/store/index.js</p><pre><code class=\"language-js\">import Vue from \'vue\'\nimport Vuex from \'vuex\'\n\nVue.use(Vuex)\n\n/*\n  读取数据，走 state, getters\n  修改数据，走 mutations, actions\n*/\nexport default new Vuex.Store({\n  state: {\n    name: \'\',\n    age: 18\n  },\n  getters: {\n  },\n  mutations: {\n    updateName(state, name) {\n      state.name = name;\n    }\n  },\n  actions: {\n  },\n  modules: {\n  }\n})\n</code></pre><p>修改共享数据</p><pre><code class=\"language-vue\">&lt;template&gt;\n    &lt;div class=\"p\"&gt;\n        &lt;el-input placeholder=\"请修改用户姓名\" \n            size=\"mini\" v-model=\"name\"&gt;&lt;/el-input&gt;\n        &lt;el-button type=\"primary\" size=\"mini\" @click=\"update()\"&gt;修改&lt;/el-button&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nconst options = {\n    methods: {\n        update(){\n            this.$store.commit(\'updateName\', this.name);\n        }\n    },\n    data () {\n        return {\n            name:\'\'\n        }\n    }\n}\nexport default options;\n&lt;/script&gt;\n</code></pre><ul><li>mutations 方法不能直接调用，只能通过 <code>store.commit(mutation方法名, 参数)</code> 来间接调用</li></ul><p>读取共享数据</p><pre><code class=\"language-vue\">&lt;template&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;el-container&gt;\n            &lt;el-header&gt;\n                &lt;div class=\"t\"&gt;\n                    欢迎您：{{ $store.state.name }}, {{ $store.state.age }}\n                &lt;/div&gt;\n            &lt;/el-header&gt;\n            &lt;el-container&gt;\n                &lt;el-aside width=\"200px\"&gt;\n                &lt;/el-aside&gt;\n                &lt;el-main&gt;\n                    &lt;router-view&gt;&lt;/router-view&gt;\n                &lt;/el-main&gt;\n            &lt;/el-container&gt;\n        &lt;/el-container&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n</code></pre><h4>mapState</h4><p>每次去写 <code>$store.state.name</code> 这样的代码显得非常繁琐，可以用 vuex 帮我们生成计算属性</p><pre><code class=\"language-vue\">&lt;template&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;el-container&gt;\n            &lt;el-header&gt;\n                &lt;div class=\"t\"&gt;欢迎您：{{ name }}, {{ age }}&lt;/div&gt;\n            &lt;/el-header&gt;\n            &lt;el-container&gt;\n                &lt;el-aside width=\"200px\"&gt;\n                &lt;/el-aside&gt;\n                &lt;el-main&gt;\n                    &lt;router-view&gt;&lt;/router-view&gt;\n                &lt;/el-main&gt;\n            &lt;/el-container&gt;\n        &lt;/el-container&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport { mapState } from \'vuex\'\nconst options = {\n    computed: {\n        ...mapState([\'name\', \'age\'])\n    }\n}\nexport default options;\n&lt;/script&gt;\n</code></pre><ul><li>mapState 返回的是一个对象，对象内包含了 name() 和 age() 的这两个方法作为计算属性</li><li>此对象配合 <code>...</code> 展开运算符，填充入 computed 即可使用</li></ul><h4>mapMutations</h4><pre><code class=\"language-vue\">&lt;template&gt;\n    &lt;div class=\"p\"&gt;\n        &lt;el-input placeholder=\"请修改用户姓名\" \n            size=\"mini\" v-model=\"name\"&gt;&lt;/el-input&gt;\n        &lt;el-button type=\"primary\" size=\"mini\" @click=\"updateName(name)\"&gt;修改&lt;/el-button&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport {mapMutations} from \'vuex\'\nconst options = {\n    methods: {\n        ...mapMutations([\'updateName\'])\n    },\n    data () {\n        return {\n            name:\'\'\n        }\n    }\n}\nexport default options;\n&lt;/script&gt;\n</code></pre><ul><li>类似的，调用 mutation 修改共享数据也可以简化</li><li>mapMutations 返回的对象中包含的方法，就会调用 store.commit() 来执行 mutation 方法</li><li>注意参数传递略有不同</li></ul><h4>actions</h4><p>mutations 方法内不能包括修改不能立刻生效的代码，否则会造成 Vuex 调试工具工作不准确，必须把这些代码写在 actions 方法中</p><pre><code class=\"language-js\">import Vue from \'vue\'\nimport Vuex from \'vuex\'\n\nVue.use(Vuex)\n\n/*\n  读取数据，走 state, getters\n  修改数据，走 mutations, actions\n*/\nimport axios from \'@/util/myaxios\'\nexport default new Vuex.Store({\n  state: {\n    name: \'\',\n    age: 18\n  },\n  getters: {\n  },\n  mutations: {\n    updateName(state, name) {\n      state.name = name;\n    },\n    // 错误的用法，如果在mutations方法中包含了异步操作，会造成开发工具不准确\n    /* async updateServerName(state) {\n      const resp = await axios.get(\'/api/user\');\n      const {name, age} = resp.data.data;\n      state.name = name;\n      state.age = age;\n    } */\n    updateServerName(state, user) {\n      const { name, age } = user;\n      state.name = name;\n      state.age = age;\n    }\n  },\n  actions: {\n    async updateServerName(context) {\n      const resp = await axios.get(\'/api/user\');\n      context.commit(\'updateServerName\', resp.data.data)\n    }\n  },\n  modules: {\n  }\n})\n</code></pre><ul><li>首先应当调用 actions 的 updateServerName 获取数据</li><li>然后再由它间接调用 mutations 的 updateServerName 更新共享数据</li></ul><p>页面使用 actions 的方法可以这么写</p><pre><code class=\"language-vue\">&lt;template&gt;\n    &lt;div class=\"p\"&gt;\n        &lt;el-button type=\"primary\" size=\"mini\"\n            @click=\"updateServerName()\"&gt;从服务器获取数据,存入store&lt;/el-button&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport { mapActions } from \'vuex\'\nconst options = {\n    methods: {\n        ...mapActions([\'updateServerName\'])\n    }\n}\nexport default options;\n&lt;/script&gt;\n</code></pre><ul><li>mapActions 会生成调用 actions 中方法的代码</li><li>调用 actions 的代码内部等价于，它返回的是 Promise 对象，可以用同步或异步方式接收结果 this.$store.dispatch(\'action名称\', 参数)</li></ul><h2>3. Vue 实战</h2><p>课程不准备从头开发一个 Vue 项目，这里我准备采用这样的教学方法：带着大家看一个较为典型的基于 Vue 的项目实现，分析其中几个重点流程</p><p>这里选择了 vue-element-admin 这个项目骨架，它采用的技术与我们之前学过的较为契合</p><ul><li>vue 2</li><li>element-ui 2</li><li>vue-router 3</li><li>vuex 3</li><li>axios</li></ul><h3>安装</h3><pre><code class=\"language-cmd\">git clone https://gitee.com/panjiachen/vue-element-admin.git client-action\n\ncd client-action\n\ngit branch -a\n\ngit checkout -b i18n remotes/origin/i18n\n\ngit config --global url.\"https://\".insteadOf git://\n\nnpm install\n\nnpm run dev\n</code></pre><ul><li>需要切换分支到 i18n，否则不支持国际化（中文）功能</li><li>npm install 要多试几次，因为中间会连接 gitbub 下载一些依赖，网络不稳定会导致失败</li><li>npm run dev 运行后回自动打开浏览器，使用的端口是 9527</li></ul><h3>后端路径</h3><p>开发环境下执行下面命令</p><pre><code >npm run dev\n</code></pre><ul><li>会同时启动 mock-server</li></ul><p>在开发环境下，后端访问路径起始路径配置在文件 <code>.env.development</code> 中</p><pre><code class=\"language-properties\">VUE_APP_BASE_API = \'/dev-api\'\n</code></pre><ul><li>默认向后台的请求都发给 <code>http://localhost:9527/dev-api</code> 的 mock-server 获得的都是模拟数据</li><li>需要跟真实后台联调时，可以改动以上地址为 <code>VUE_APP_BASE_API = \'http://localhost:8080/api\'</code></li></ul><p>发送请求的 axios 工具被封装在 src/utils/request.js 中</p><pre><code class=\"language-js\">import axios from \'axios\'\nimport { MessageBox, Message } from \'element-ui\'\nimport store from \'@/store\'\nimport { getToken } from \'@/utils/auth\'\n\n// create an axios instance\nconst service = axios.create({\n  baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url\n  // withCredentials: true, // send cookies when cross-domain requests\n  timeout: 5000 // request timeout\n})\n\n// ...\n</code></pre><p>原有代码的 URI 路径都是这样的：</p><pre><code >/vue-element-admin/user/login\n/vue-element-admin/user/info\n/vue-element-admin/user/logout\n...\n</code></pre><p>如果觉得不爽，可以来一个全局替换</p><pre><code >/user/login\n/user/info\n/user/logout\n...\n</code></pre><p>token 的请求头修改一下，在 src/utils/request.js 中</p><pre><code class=\"language-js\">...\nservice.interceptors.request.use(\n  config =&gt; {\n    // do something before request is sent\n\n    if (store.getters.token) {\n      // let each request carry token\n      // [\'X-Token\'] is a custom headers key\n      // please modify it according to the actual situation\n      config.headers[\'Authorization\'] = getToken()\n    }\n    return config\n  },\n  error =&gt; {\n    // do something with request error\n    console.log(error) // for debug\n    return Promise.reject(error)\n  }\n)\n...\n</code></pre><h3>登录流程</h3><h4>1. <code>src/views/login/index.vue</code></h4><pre><code class=\"language-vue\">&lt;script&gt;\nimport { validUsername } from \'@/utils/validate\'\nimport LangSelect from \'@/components/LangSelect\'\nimport SocialSign from \'./components/SocialSignin\'\n\nexport default {\n  // ...\n  methods: {    \n    handleLogin() {\n      this.$refs.loginForm.validate(valid =&gt; {\n        if (valid) {\n          this.loading = true\n          this.$store.dispatch(\'user/login\', this.loginForm)\n            .then(() =&gt; {\n              this.$router.push({ path: this.redirect || \'/\', query: this.otherQuery })\n              this.loading = false\n            })\n            .catch(() =&gt; {\n              this.loading = false\n            })\n        } else {\n          console.log(\'error submit!!\')\n          return false\n        }\n      })\n    }\n    // ...\n  }\n}\n&lt;/script&gt;\n</code></pre><p>这里调用了 store 的 actions，<code>user/login</code></p><ul><li>因为是异步调用，因此只能用 actions</li><li>登录成功会优先跳转至 this.redirect 路径、否则跳转至 /</li><li>/ 查看 <code>src/router/index.js</code> 的路由表可知，会重定向至 /dashboard</li></ul><h4>2. <code>src/store/modules/user.js</code></h4><pre><code class=\"language-js\">import { login, logout, getInfo } from \'@/api/user\'\n// ...\nconst actions = {\n  // user login\n  login({ commit }, userInfo) {\n    const { username, password } = userInfo\n    return new Promise((resolve, reject) =&gt; {\n      login({ username: username.trim(), password: password }).then(response =&gt; {\n        const { data } = response\n        commit(\'SET_TOKEN\', data.token)\n        setToken(data.token)\n        resolve()\n      }).catch(error =&gt; {\n        reject(error)\n      })\n    })\n  }\n  // ...\n}\n</code></pre><ul><li>发请求用了 <code>src/api/user.js</code>，请求成功使用 commit 将 token 存入 mutations，同时往 cookie 存储了一份</li><li>这里的 response 其实是真正的 response.data，见后面的说明</li><li>评价</li></ul><h4>3. <code>src/api/user.js</code></h4><pre><code class=\"language-js\">import request from \'@/utils/request\'\n\nexport function login(data) {\n  return request({\n    url: \'/user/login\',\n    method: \'post\',\n    data\n  })\n}\n\n// ...\n</code></pre><ul><li>其中 request 相当于我们之前封装的 myaxios</li></ul><h4>4. <code>src/utils/request.js</code></h4><pre><code class=\"language-js\">import axios from \'axios\'\nimport { MessageBox, Message } from \'element-ui\'\nimport store from \'@/store\'\nimport { getToken } from \'@/utils/auth\'\n\n// create an axios instance\nconst service = axios.create({\n  baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url\n  // withCredentials: true, // send cookies when cross-domain requests\n  timeout: 5000 // request timeout\n})\n\n// ... \n\nservice.interceptors.response.use(\n  // ...\n  response =&gt; {\n    const res = response.data\n    if (res.code !== 20000) {\n      // ...\n    } else {\n      return res\n    }\n  },\n  error =&gt; {\n    // ...\n  }\n)\n\nexport default service\n</code></pre><ul><li>其中响应拦截器发现响应正确，返回 resp.data 这样，其它处代码解构时少了一层 data</li></ul><h4>5. <code>src/permission.js</code></h4><p>登录成功后，只是获得了 token，还未获取用户信息，获取用户信息是在路由跳转的 beforeEach 里做的</p><pre><code class=\"language-mermaid\">sequenceDiagram \n\nparticipant c as 登录页\nparticipant r as Router\nparticipant s as Store\nparticipant t as Tomcat\n\nrect rgba(255,0,0,0.2)\nc -&gt;&gt; +s: login(username,password)\ns -&gt;&gt; +t: login(username,password)\nt --&gt;&gt; -s: token\ns -&gt;&gt; s: 存储 token\ns --&gt;&gt; -c: \nend\n\nrect rgba(0,255,0,0.2)\nc -&gt;&gt; +r: 跳转至 /\nr -&gt;&gt; +s: beforeEach getInfo(token)\ns -&gt;&gt; +t: getInfo(token)\nt --&gt;&gt; -s: name,avatar,roles等\ns -&gt;&gt; s: 存储用户信息\ns --&gt;&gt; -r: \nr -&gt;&gt; r: 根据roles动态生成路由\nr --&gt;&gt; -c: \nend\n</code></pre><p>关键代码</p><pre><code class=\"language-js\">import router from \'./router\'\n\n// ...\n\nrouter.beforeEach(async(to, from, next) =&gt; {\n  // ...\n  const hasToken = getToken()\n\n  if (hasToken) {\n    if (to.path === \'/login\') {\n      // ...\n    } else {\n      // ...\n      const { roles } = await store.dispatch(\'user/getInfo\')\n      // ...\n    }\n  } else {\n    // ...\n  }\n})\n</code></pre><ul><li>登录后跳转至 / 之前进入这里的 beforeEach 方法，方法内主要做两件事</li></ul><h4>6. <code>src/store/modules/user.js</code></h4><p>这里用其中 getInfo 方法获取用户信息，其中角色返回给 beforeEach </p><pre><code class=\"language-js\">import { login, logout, getInfo } from \'@/api/user\'\n// ...\nconst actions = {\n  getInfo({ commit, state }) {\n    return new Promise((resolve, reject) =&gt; {\n      getInfo(state.token).then(response =&gt; {\n        const { data } = response\n\n        if (!data) {\n          reject(\'Verification failed, please Login again.\')\n        }\n\n        const { roles, name, avatar, introduction } = data\n\n        if (!roles || roles.length &lt;= 0) {\n          reject(\'getInfo: roles must be a non-null array!\')\n        }\n\n        commit(\'SET_ROLES\', roles)\n        commit(\'SET_NAME\', name)\n        commit(\'SET_AVATAR\', avatar)\n        commit(\'SET_INTRODUCTION\', introduction)\n        resolve(data)\n      }).catch(error =&gt; {\n        reject(error)\n      })\n    })\n  }\n}\n</code></pre><h4>7. <code>src/router/index.js</code></h4><p>路由表中路由分成两部分，静态路由与动态路由</p><pre><code class=\"language-js\">export const constantRoutes = [\n  // ...\n  {\n    path: \'/login\',\n    component: () =&gt; import(\'@/views/login/index\'),\n    hidden: true\n  },\n  {\n    path: \'/\',\n    component: Layout,\n    redirect: \'/dashboard\',\n    children: [\n      {\n        path: \'dashboard\',\n        component: () =&gt; import(\'@/views/dashboard/index\'),\n        name: \'Dashboard\',\n        meta: { title: \'dashboard\', icon: \'dashboard\', affix: true }\n      }\n    ]\n  }\n  // ...\n]\n</code></pre><ul><li>其中 hidden: true 的路由只做路由跳转，不会在左侧导航菜单展示</li></ul><p>动态路由</p><pre><code class=\"language-js\">export const asyncRoutes = [\n  {\n    path: \'/permission\',\n    component: Layout,\n    redirect: \'/permission/page\',\n    alwaysShow: true, // will always show the root menu\n    name: \'Permission\',\n    meta: {\n      title: \'permission\',\n      icon: \'lock\',\n      roles: [\'admin\', \'editor\'] // you can set roles in root nav\n    },\n    children: [\n      {\n        path: \'page\',\n        component: () =&gt; import(\'@/views/permission/page\'),\n        name: \'PagePermission\',\n        meta: {\n          title: \'pagePermission\',\n          roles: [\'admin\'] // or you can only set roles in sub nav\n        }\n      },\n      {\n        path: \'directive\',\n        component: () =&gt; import(\'@/views/permission/directive\'),\n        name: \'DirectivePermission\',\n        meta: {\n          title: \'directivePermission\'\n          // if do not set roles, means: this page does not require permission\n        }\n      },\n      {\n        path: \'role\',\n        component: () =&gt; import(\'@/views/permission/role\'),\n        name: \'RolePermission\',\n        meta: {\n          title: \'rolePermission\',\n          roles: [\'admin\']\n        }\n      }\n    ]\n  },\n\n  {\n    path: \'/icon\',\n    component: Layout,\n    children: [\n      {\n        path: \'index\',\n        component: () =&gt; import(\'@/views/icons/index\'),\n        name: \'Icons\',\n        meta: { title: \'icons\', icon: \'icon\', noCache: true, roles: [\'admin\'] }\n      }\n    ]\n  }\n  // ...\n}\n</code></pre><ul><li>动态路由中关联了角色信息，根据用户的角色决定那些路由可用，但这样做的缺点是把角色和路由绑定死了</li></ul><h4>8. <code>src/layout/index.vue</code></h4><p>它对应的是我们之前介绍的 Container.vue 完成主页布局的，路由路径是 /</p><p><img src=\"D:%5C2022.js%5Cimgs%5Cimage-20220827194047788.png\" alt=\"image-20220827194047788\" data-href=\"\" style=\"\"/></p><p>其中又由多部分组成，其中固定不变的是</p><ul><li>侧边栏</li><li>导航栏</li><li>标签栏</li><li>设置</li></ul><p>变化的是中间的 dashboard 部分（AppMain），它由 router-view 配合子路由切换显示</p><ul><li>进入 / 后，就会 redirect 重定向到 /dashboard 子路由</li><li>进入首页后，会有一个 <code>/api/transaction/list</code> 的后台请求报 404，作为练习，把它补充完整</li></ul><h3>第三方登录</h3><pre><code class=\"language-mermaid\">sequenceDiagram\nparticipant a7 as 前端(9527)\nparticipant a8 as 后端(8080)\nparticipant g as gitee\n\nrect rgba(0,255,0,0.2) \na7 -&gt;&gt; +g: 打开新窗口, 请求 /oauth/authorize\ng -&gt;&gt; g: 认证通过\nend\nrect rgba(255,0,0,0.2)\ng -&gt;&gt; -a8: 重定向 redirect uri\nend\nrect rgba(0,255,0,0.2)\na8 -&gt;&gt; +g: 请求 /oauth/token\ng -&gt;&gt; -a8: 返回 access_token(gitee)\nend\nrect rgba(0,255,0,0.2)\na8 -&gt;&gt; +g: 请求 /api/v5/user\ng --&gt;&gt; -a8: \nend\na8 -&gt;&gt; 8: 生成 token(8080)\nrect rgba(0,0,255,0.2)\na8 -&gt;&gt; +a7: 新窗口将 token(8080) 发送给老窗口(9527)\nend\n</code></pre><ol><li>9527 打开新窗口，请求 https://gitee.com/oauth/authorize?client_id=${client_id}&redirect_uri=${redirect_uri}&response_type=code</li><li>gitee 认证通过，重定向至 8080，并携带 code</li><li>8080 发送请求 https://gitee.com/oauth/token 携带 client_id、client_secret、code，gitee 返回 access_token 给 8080 这时走的是 https 协议，并且不经过浏览器，能够保证数据传输的安全性 重定向到 8080 时，如果被有心人拿到了 code，也没事，因为接下来会把 client_secret 发给 gitee 验证（client_secret 应当只存在 8080），只要 client_secret 不泄露，就可以保证安全 如果改成前端拿 code 换 access_token，那就意味着 access_token 得保存在前端，所有保存在前端的都有风险</li><li>8080 可以访问 gitee 的 api 了，拿到用户信息，存入数据库，返回 8080 的 token</li><li>8080 可以通过 window.opener.postMessage 把 token 给 9527 的老窗口 这里又会涉及到跨域，不过 9527 与 8080 直接存在信任关系，设置一下就好</li><li>9527 再走之前的逻辑就可以了，在 router 的 beforeEach 方法里，用 8080 token 换用户信息</li></ol><h3>增删改查</h3><p>首先，在 api 里添加与后端交互的代码：<code>src/api/student.js</code></p><pre><code class=\"language-js\">import axios from \'@/utils/request\'\n\nexport function all() {\n  return axios({\n    url: \'/students\',\n    method: \'get\'\n  })\n}\n\nexport function deleteById(id) {\n  return axios({\n    url: `/students/${id}`,\n    method: \'delete\'\n  })\n}\n\nexport function update(id, dto) {\n  return axios({\n    url: `/students/${id}`,\n    method: \'put\',\n    data: dto\n  })\n}\n\nexport function insert(dto) {\n  return axios({\n    url: `/students`,\n    method: \'post\',\n    data: dto\n  })\n}\n</code></pre><p>然后，添加新的路由：<code>src/router/index.js</code></p><pre><code class=\"language-js\">export const asyncRoutes = [\n  // ...\n  {\n    path: \'/student\',\n    component: Layout,\n    children: [\n      {\n        path: \'index\',\n        component: () =&gt; import(\'@/views/student/index\'),\n        meta: { title: \'学生管理\', icon: \'el-icon-s-help\', roles: [\'admin\'] }\n      }\n    ]\n  },\n  // ...\n]\n</code></pre><ul><li>注意 title 这里没有考虑国际化</li></ul><p>最后，添加新的视图界面：<code>src/views/student/index.vue</code></p><pre><code class=\"language-vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;el-table :data=\"students\"&gt;\n      &lt;el-table-column label=\"编号\" prop=\"id\"&gt;&lt;/el-table-column&gt;\n      &lt;el-table-column label=\"姓名\" prop=\"name\"&gt;&lt;/el-table-column&gt;\n      &lt;el-table-column label=\"性别\" prop=\"sex\"&gt;&lt;/el-table-column&gt;\n      &lt;el-table-column label=\"年龄\" prop=\"age\"&gt;&lt;/el-table-column&gt;\n      &lt;el-table-column fixed=\"right\" label=\"操作\" width=\"100\"&gt;\n        &lt;template slot-scope=\"scope\"&gt;\n          &lt;el-button @click=\"handleUpdate(scope.row)\" type=\"text\" size=\"small\"&gt;修改&lt;/el-button&gt;\n          &lt;el-button @click=\"handleDelete(scope.row)\" type=\"text\" size=\"small\"&gt;删除&lt;/el-button&gt;\n        &lt;/template&gt;\n      &lt;/el-table-column&gt;\n    &lt;/el-table&gt;\n\n    &lt;el-dialog width=\"22%\" :visible.sync=\"updateDialogVisible\"&gt;\n      &lt;el-form :model=\"updateForm\"&gt;\n        &lt;el-form-item label=\"编号\"&gt;\n          &lt;el-input size=\"mini\" :readonly=\"true\" v-model=\"updateForm.id\"&gt;&lt;/el-input&gt;\n        &lt;/el-form-item&gt;\n        &lt;el-form-item label=\"姓名\"&gt;\n          &lt;el-input size=\"mini\" v-model=\"updateForm.name\"&gt;&lt;/el-input&gt;\n        &lt;/el-form-item&gt;\n        &lt;el-form-item label=\"性别\"&gt;\n          &lt;el-select size=\"mini\" v-model=\"updateForm.sex\"&gt;\n            &lt;el-option value=\"男\"&gt;&lt;/el-option&gt;\n            &lt;el-option value=\"女\"&gt;&lt;/el-option&gt;\n          &lt;/el-select&gt;\n        &lt;/el-form-item&gt;\n        &lt;el-form-item label=\"年龄\"&gt;\n          &lt;el-input size=\"mini\" v-model=\"updateForm.age\"&gt;&lt;/el-input&gt;\n        &lt;/el-form-item&gt;\n        &lt;el-form-item&gt;\n          &lt;el-button type=\"primary\" size=\"mini\" @click=\"confirmUpdate()\"&gt;确定&lt;/el-button&gt;\n        &lt;/el-form-item&gt;\n      &lt;/el-form&gt;\n    &lt;/el-dialog&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport { all, deleteById, update, insert } from \'@/api/student\'\nconst options = {\n  mounted() {\n    this.all()\n  },\n  data() {\n    return {\n      students: [],\n      updateDialogVisible: false,\n      updateForm: {\n        id: 0,\n        name: \'\',\n        sex: \'男\',\n        age: 0\n      }\n    }\n  },\n  methods: {\n    async confirmUpdate() {\n      await update(this.updateForm.id, this.updateForm)\n      this.updateDialogVisible = false\n      this.all()\n    },\n    handleUpdate(row) { // {id, name, sex, age}\n      this.updateDialogVisible = true\n      this.updateForm = { ...row }\n      // this.updateForm = row // 错误写法，不能让他俩指向同一个对象\n    },\n    async handleDelete(row) {\n      try {\n        await this.$confirm(\'此操作将永久删除该学生, 是否继续?\', \'提示\', {\n          confirmButtonText: \'确定\',\n          cancelButtonText: \'取消\',\n          type: \'warning\'\n        })\n        await deleteById(row.id)\n        this.all()\n      } catch (e) {\n        console.log(\'取消删除\')\n      }\n    },\n    async all() {\n      const { data } = await all()\n      this.students = data\n    }\n  }\n}\nexport default options\n&lt;/script&gt;\n&lt;style scoped&gt;\n.el-input,\n.el-select {\n  width: 180px;\n}\n&lt;/style&gt;\n</code></pre><ul><li>其中 handleUpdate 和 handleDelete 接收的参数，都是代表了当前行的学生对象</li></ul>', '林志杰', '1626518508932235265', 1, 2, 1, '2023-05-17 19:24:43.519', '2023-05-31 00:00:00.051');
INSERT INTO `blog` VALUES ('fe546648f961e3e9da58aeeae20b908f', '我很喜欢这个平台', 'http://rt6vvz8xh.bkt.clouddn.com/blogFile/1629495477589856258/b219ebc4b74543a9e3e0ca386c1dac8eb8011464.webp', '“博客”当然是个大家都陌生的名词,博客的英文名词就是“Blog或Weblog”(指人时对应于Blogger),是一个典型的网络新事物,查阅最新的英文词典也不可能查到', '<h1 style=\"text-align: start;\">HTTP</h1><p style=\"text-align: start;\">为web浏览器与web服务器之间的通信而设计</p><h3 style=\"text-align: start;\">概述</h3><h5 style=\"text-align: start;\">HTTP是一种能够获取网络资源的通信协议，在web 上进行数据交换的基础，是一种client-server协议，浏览器接收方发送请求。完整的web文档由不同子文档拼接而成的，像是文本，布局描述，图片等。</h5><p style=\"text-align: start;\">浏览器发送的消息叫request，被服务器响应的消息叫response。</p><p style=\"text-align: start;\"><br></p><ul><li style=\"text-align: start;\">一个 HTTP 的method，经常是由一个动词像GET, POST 或者一个名词像OPTIONS，HEAD来定义客户端的动作行为。通常客户端的操作都是获取资源（GET 方法）或者发送HTML form表单（POST 方法），虽然在一些情况下也会有其他操作。</li><li style=\"text-align: start;\">要获取的资源的路径，通常是上下文中就很明显的元素资源的 URL，它没有protocol（http://），domain（developer.mozilla.org），或是 TCP 的port (en-US)（HTTP 一般在 80 端口）。</li><li style=\"text-align: start;\">HTTP 协议版本号。</li><li style=\"text-align: start;\">为服务端表达其他信息的可选头部headers。</li><li style=\"text-align: start;\">对于一些像 POST 这样的方法，报文的 body 就包含了发送的资源，这与响应报文的 body 类似。</li></ul><p style=\"text-align: start;\"><br></p><ul><li style=\"text-align: start;\">HTTP 协议版本号。</li><li style=\"text-align: start;\">一个状态码（status code），来告知对应请求执行成功或失败，以及失败的原因。</li><li style=\"text-align: start;\">一个状态信息，这个信息是非权威的状态码描述信息，可以由服务端自行设定。</li><li style=\"text-align: start;\">HTTP headers，与请求头部类似。</li><li style=\"text-align: start;\">可选项，比起请求报文，响应报文中更常见地包含获取的资源 body。</li></ul><h3 style=\"text-align: start;\">HTTP缓存</h3><p style=\"text-align: start;\">响应可复用时，服务器不用处理请求，不需要解析和路由请求、根据cookie恢复会话、查询数据库以获取结果或渲染模板引擎。减少服务器上的负载。</p><ol><li style=\"text-align: start;\">私有缓存绑定到特定客户端的缓存（浏览器缓存）主要存储用户的个性化响应防止信息泄露个性化需要指令——Cache-Control: private通常由cookie控制，单独的cookie不会使响应成为私有。响应具有Authorization标头，不能将其存储在私有缓存中</li><li style=\"text-align: start;\">共享缓存共享缓存位于客户端和服务器之间，存储共享的响应代理缓存访问控制减少网络流量由HTTP标头等控制如今普遍只能传输响应托管缓存服务开发人员部署（降低源服务器负载并有效地交付内容）因部署的产品而异（通过Cache-Control 标头和你自己的配置文件或仪表板来控制缓存的行为）指定（Cache-Control: no-store）选择退出私有缓存或代理缓存，使用自己的策略仅在托管缓存中缓存。</li><li style=\"text-align: start;\">启发式缓存尽可能多的缓存，即没有给出Cache-Control，如果满足某些条件，响应也会被存储和重用。规范建议是存储后的10%的时间。</li><li style=\"text-align: start;\">基于age的缓存策略http响应两种状态：fresh（表示响应仍然有效）和stale（缓存响应已经过期）确定的标准是age（max-age）</li><li style=\"text-align: start;\">Expires或max-agehttp1.0版本新鲜度过去由Expires标头指定（表示的是明确的时间，而不是经过的时间）Expires: Tue, 28 Feb 2022 22:22:22 GMThttp1.1可以通过故意偏移系统时钟诱发问题，在HTTP/1.1中采用max-agemax-age的优先度大于Expires。目前expires无需特地提供。</li><li style=\"text-align: start;\">Vary响应根据URL区分响应，还会根据Accept、Accept-Language 和 Accept-Encoding 请求标头的值产生变化。Vary: Accept-Language代表已经缓存过得语言，不同语言不能请求重用。User-Agent请求头具有非常多的变体，降低了重用的机会，考虑一种基于特征检测而不是基于User-Agent请求标头来改变行为的方法。防止其他人重复使用缓存的个性化内容的应用程序，应该指定Cache-Control: private 而不是为 Vary 指定 cookie。</li><li style=\"text-align: start;\">验证响应过时的响应不会被丢弃询问服务器进行重新验证，将旧响应转换为新的响应使用包含 If-Modified-Since 或 If-None-Match 请求标头的条件请求完成If-Modified-Since：收到响应后，会恢复为新鲜的。ETag响应头的值是服务器生成的任意值。请求头和响应头的值相等则是旧的返回304 Not Modified，相同则改为200ok。</li><li style=\"text-align: start;\">强制重新验证不希望重复使用响应，而是始终最新的内容，可以使用no-cache指令强制验证。通过在响应中添加Cache-Control: no-cache 以及Last-Modified和 ETag如果请求资源已更新则收到200OK，否则会收到304 NOT MOdified。max-age=0（缓存立刻过期） 和 must-revalidate（一旦过时就不得在没有重新验证的情况下重用它） 的组合与 no-cache （取消缓存）具有相同的含义。现在一般直接使用no-cach。</li><li style=\"text-align: start;\">不使用缓存no-store代表不使用缓存no-cach代表不会阻止响应的存储，而是阻止在没有重新验证的情况下重用响应。不与其他用户共享：设置no-store再设置private。每次都提供最新的内容：no-store指令阻止存储响应，但不会删除相同URL的任何已存储响应。no-cache强制客户端在重用任何存储的响应之前发送验证请求。兼容过时的实现：使用no-cache处理这种过时的实现的替代方案，添加private来防止意外缓存。no-store丢失了什么：最好将no-cach与private结合使用，因为no-store会失去浏览器和http的所有优势。</li><li style=\"text-align: start;\">重新加载和强制重新加载</li></ol><p style=\"text-align: start;\"> 为了从页面错误中恢复或更新到最新版本的资源，浏览器为用户提供了重新加载功能。</p><p style=\"text-align: start;\"> 请求中的max-age=0指令指定重用为0或更少的响应。</p><p style=\"text-align: start;\"> 请求通过<code>If-None-Match</code> 和 <code>If-Modified-Since</code> 进行验证。</p><ol><li style=\"text-align: start;\">避免重新验证永远不会改变的内容应该赋予一个较长的max-age，方法是使用缓存破坏就是在URL中包含版本号和哈希值。但是服务器依然会发送重新验证请求。增加指令immutable来明确指示不需要重新验证。</li><li style=\"text-align: start;\">删除存储的响应没有办法删除很长的max-age存储的响应。加上no-cache可以使服务器始终接收请求并发送预期的响应。</li><li style=\"text-align: start;\">请求折叠多个请求同时到达共享缓存，中间缓存将代表自己将单个请求转发到源，然后源可以将结果重用于所有客户端。即使响应中给出了max-age=0或no-cache，它也会被重用。不希望响应在折叠中共享加上private指令。</li><li style=\"text-align: start;\">常见的缓存模式默认设置没有Cache-Control的响应，根据启发式缓存进行隐式缓存。可以加上标头避免这种缓存。加上no-cache始终传输最新版本的资源。如果服务实现了cookie或其他登录方式，也必须提供private。缓存破坏最适合缓存的资源是静态不可变文件，其内容永远不会改变。对于会变化的资源，最佳实践是每次内容变化时都改变URL。36 cache-control max-age=037 cache-control max-age=60480038 cache-control max-age=259200039 cache-control no-cache40 cache-control no-store41 cache-control public, max-age=31536000缓存会在保存新条目时删除旧条目。是一种通过内容更改时更改URL来使响应在很长一段时间内可缓存的技术，主要应用于所有子资源。验证响应设置Last-Modified和ETag标头，以便在重新加载时不必重新传输资源。添加immutable防止重新加载时验证。主要资源主资源与子资源不同，不能使用缓存破坏，他们的URL不能像子资源一样被修饰。对于HTML资源，不想存储HTML，而只是希望它是最新的。使用no-cache而不是no-store。添加Last-Modified和ETag将允许客户端发送条件请求，如果HTML没更新，返回304。</li></ol><h3 style=\"text-align: start;\">HTTP Cookie</h3><p style=\"text-align: start;\">HTTP Cookie是服务器发送到用户服务器并保存在本地的一小块数据。浏览器会存储cookie并在下次向同一服务器再发起请求时携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器——保持登录状态。Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。</p><p style=\"text-align: start;\">Cookie主要用于以下三个方面：会话状态管理（登录状态，购物车，游戏分数以及其他记录的信息。），个性化设置（如用户自定义设置，主题和其他设置），浏览器行为跟踪（跟踪分析用户行为）。</p><ol><li style=\"text-align: start;\">创建Cookie服务器收到HTTP请求后，服务器在响应头里面添加一个或多个Set-Cookie选项。浏览器收到响应后通常会保存下Cookie，并将其放在HTTPcookie标头内，向同一服务器发送请求时一起发送。你可以指定一个过期日期或者时间段之后，不能发送cookie。</li><li style=\"text-align: start;\">Set-Cookie和Cookie标头服务器使用set-Cookie响应头部向用户代理（一般是浏览器）发送Cookie信息。Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;</li><li style=\"text-align: start;\">定义Cookie的生命周期会话期Cookie会在当前的会话结束之后删除。浏览器定义了“当前会话”结束的时间，一些浏览器重启时会使用会话恢复。这可能导致会话Cookie无限延长。持久性Cookie在过期时间（Expires）指定的日期或有效期（Max-Age）指定的一段时间后被删除。</li><li style=\"text-align: start;\">限制访问CookieSecure和HttpOnly属性可以确保Cookie安全发送Secure的Cookie只应通过被HTTPS协议加密过得请求发送给服务端。JavaScript API无法访问带有HttpOnly属性cookie；此类Cookie作用于服务器。</li><li style=\"text-align: start;\">定义Cookie发送的位置Domain和Path标识定义了Cookie的作用域，即允许Cookie应该发送哪些URL。</li><li style=\"text-align: start;\">Domain属性Domain指定哪些主机可以接受Cookie。如果不指定，默认属性为同一host，不包含子域名。指定则包含子域名。如果设置Domain=mozilla.org，则Cookie也包含在子域名中。</li><li style=\"text-align: start;\">Path属性path属性指定URL路径，必须存在于请求的URL中，以便发送cookie标头。子路径也会被匹配。</li><li style=\"text-align: start;\">SameSite属性SameSite属性允许服务器指定是否/何时通过跨站点请求发送。CSRF的保护，采用三个可能的值：Strict、Lax和None。Strict：cookie仅发送到它来源的站点。Lax：在用户导航到cookie的源站点时发送cookie。None：指定浏览器会在同站请求和跨站请求下继续发送cookie。</li><li style=\"text-align: start;\">Cookie前缀cookie的机制无法让服务器确认cookie最初是在哪里设置的。_Host-：如果cookie名称具有此前缀，则仅当它也用secure属性标记、从安全来源发送、不包括Domain属性，并将Path属性设置为/时，它才在Set-Cookie标头中接受。_Secure-：如果cookie名称具有此前缀，则仅当它也用Secure属性标记，是从安全来源发送的，它才在Set-Cookie标头中接受。</li></ol><h3 style=\"text-align: start;\">跨源资源共享（CORS）</h3><p style=\"text-align: start;\">跨源资源共享（CORS）是一种基于HTTP头的机制，该机制通过允许服务器标示除了它自己以外的其它源，使得浏览器允许这些origin访问加载自己的资源。跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的“预检”请求。预检中，浏览器发送的头中标示有HTTP方法和真实请求中会用到的头。</p><h5 style=\"text-align: start;\">什么情况下需要CORS</h5><ol><li style=\"text-align: start;\">发起跨源HTTP请求</li><li style=\"text-align: start;\">Web字体（只有授权网站可以跨站调用）</li><li style=\"text-align: start;\">WebGL贴图</li><li style=\"text-align: start;\">使用drawImage（）</li><li style=\"text-align: start;\">来自图像的CSS图形</li></ol><h5 style=\"text-align: start;\">功能概述</h5><p style=\"text-align: start;\">跨源资源共享新增了一组HTTP标头字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。</p><h5 style=\"text-align: start;\">若干访问控制场景</h5><ul><li style=\"text-align: start;\">简单请求某些请求不会触发CORS预检请求。使用下列方法：GET，HEAD，POST允许认为设置的字段为Fetch规范定义的对CORS安全的首部字段集合：Accept，Accept-Language,Content-Language,Content-Type(仅text/plain，multipart/form-data，application/x-www-form-urlencoded),Range。如果请求是使用XMLHttpRequest对象发出的，在返回的XMLHttpRequest.upload对象属性上没有注册任何事件监听器；请求中没有使用ReadableStream对象请求首部字段Origin表明请求来源。Access-Control-Allow-Origin的值为*代表该资源可以被任意外源访问。</li><li style=\"text-align: start;\">预检请求需预检的请求要求必须首先使用OPTIONS方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。预检请求中的OPTIONS需要携带的两个首部字段Access-Control-Request-Method: POSTAccess-Control-Request-Headers: X-PINGOTHER, Content-Type服务器接受后续的请求方法Access-Control-Allow-Origin: https://foo.exampleAccess-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-PINGOTHER, Content-TypeAccess-Control-Max-Age: 86400</li><li style=\"text-align: start;\">预检请求与重定向如果一个预检请求发生了重定向，一部分浏览器将报告错误。两种方法规避上述报错行为在服务器端去掉预检请求的重定向将实际请求变成一个简单请求发出一个简单请求以判断真正的预检请求会返回什么地址发出另一个请求，使用在上一步获得的URL</li><li style=\"text-align: start;\">附带身份凭证的请求可以基于HTTP cookie和HTTP认证信息发送身份凭证，发送请求withCredentials标志设置为true，从而发送cookie。Access-Control-Allow-Credentials: true未携带，不会发送响应给请求的发送者。</li><li style=\"text-align: start;\">预检请求和凭证CORS预检请求不能包含凭证。必须指定Access-Control-Allow-Credentials: true来表明可以携带凭证。</li><li style=\"text-align: start;\">附带身份凭证的请求与通配符在响应附带身份凭证的请求时：不能将Access-Control-Allow-Origin的值设置为*，应该指定特定的域不能将Access-Control-Allow-Headers的值设置为*，应该设置为X-PINGOTHER, Content-Type等不能将Access-Control-Allow-Methods的值设置为*，应该设置为POST, GET原因时携带cookie，这样设置会请求失败。</li><li style=\"text-align: start;\">第三方cookie设置浏览器拒绝第三方cookie，将不会保存，Cookie策略受SameSite属性控制。</li></ul><h5 style=\"text-align: start;\">HTTP响应首部字段</h5><pre style=\"text-align: left;\"><code>Access-Control-Allow-Origin: &lt;origin&gt; | *</code></pre><p style=\"text-align: start;\">指定了单一的源，告诉浏览器允许改源访问资源，对于不携带身份凭证的请求，服务器可以指定该字段的值为*。</p><p style=\"text-align: start;\">如果服务端指定了具体的单个源而非通配符“*”，那么响应首部中Vary字段必须包含Origin。</p><pre style=\"text-align: left;\"><code>Access-Control-Expose-Headers: &lt;header-name&gt;[, &lt;header-name&gt;]*</code></pre><p style=\"text-align: start;\">浏览器可通过getResponseHeader获取响应头中的内容</p><pre style=\"text-align: left;\"><code>Access-Control-Max-Age: &lt;delta-seconds&gt;</code></pre><p style=\"text-align: start;\">delta-seconds参数表示preflight预检请求的结果在多少秒内生效</p><pre style=\"text-align: left;\"><code>Access-Control-Allow-Credentials: true</code></pre><p style=\"text-align: start;\">指定了当浏览器的credentials设置为true时是否允许浏览器读取response的内容</p><pre style=\"text-align: left;\"><code>Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*</code></pre><p style=\"text-align: start;\">指定了访问资源时允许使用的请求方法</p><pre style=\"text-align: left;\"><code>Access-Control-Allow-Headers: &lt;header-name&gt;[, &lt;header-name&gt;]*</code></pre><p style=\"text-align: start;\">首部字段用于预检请求的响应。指明了实际请求中允许携带的首部字段。</p><h5 style=\"text-align: start;\">HTTP请求首部字段</h5><pre style=\"text-align: left;\"><code>Origin: &lt;origin&gt;</code></pre><p style=\"text-align: start;\">首部字段表明预检请求或实际跨源请求的源站。</p><pre style=\"text-align: left;\"><code>Access-Control-Request-Method: &lt;method&gt;</code></pre><p style=\"text-align: start;\">将实际请求所使用的HTTP方法告诉服务器</p><pre style=\"text-align: left;\"><code>Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</code></pre><p style=\"text-align: start;\">用于预检请求</p><p><br></p>', '林志杰', '1626518508932235265', 1, 1, 0, '2023-04-30 19:50:20.847', '2023-05-17 00:00:00.179');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `personalProfile` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '个人简介',
  `phone` varchar(13) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '手机号',
  `username` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '用户名',
  `password` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '密码',
  `userType` smallint(0) NOT NULL COMMENT '用户类型',
  `email` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '邮箱',
  `avatar` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '头像',
  `isDelete` tinyint(0) UNSIGNED NOT NULL DEFAULT 1 COMMENT '删除标识符号',
  `createTime` datetime(3) NOT NULL,
  `updateTime` datetime(3) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('13ecc552b1ba41666ff8b79c26d88153', NULL, '15581141441', '浦俊康', 'XRkFAf9Meux2fq', 2, 'dRan9MSWF@0355.net', 'http://rusndkp3v.bkt.clouddn.com/blogFile/1629495477589856258/头像.webp', 1, '2023-05-17 17:31:07.247', '2023-05-17 19:33:26.309');
INSERT INTO `user` VALUES ('14c33282d85c983b6cfb02e78f62493c', NULL, '13476130876', '阎涵瑶', 'juleMtM', 2, 'JxUhxEeP@3721.net', 'http://rusndkp3v.bkt.clouddn.com/blogFile/1629495477589856258/头像1.webp', 1, '2023-05-17 17:31:03.097', '2023-05-17 19:37:07.370');
INSERT INTO `user` VALUES ('1626518508932235265', '我觉得很不错我觉得很不错我觉得很不错我觉得很不错我觉得很不错我觉得很不', '15257481626', '林志杰', 'lzj439949', 1, '953093655@qq.com', 'http://rusndkp3v.bkt.clouddn.com/blogFile/1629495477589856258/头像.webp', 1, '2023-02-17 09:46:46.435', '2023-05-24 10:39:59.246');
INSERT INTO `user` VALUES ('1629495477589856258', '我很喜欢这个玩意', '15257481626', '模拟用户', 'lzj439949', 1, '953093655@qq.com', 'https://img2.baidu.com/it/u=175449109,3788073609&fm=253&app=138&size=w931&n=0&f=JPEG&fmt=auto?sec=1679072400&t=520fba054fc7cecbd8095de8ba6e373e', 1, '2023-02-25 14:56:11.077', '2023-02-25 14:56:11.077');
INSERT INTO `user` VALUES ('1630500154073161730', '我很喜欢这个玩意', '15257481626', '可以的', '21313', 2, '9102931923', 'https://img2.baidu.com/it/u=2421090168,324781765&fm=253&app=138&size=w931&n=0&f=JPEG&fmt=auto?sec=1682701200&t=b0f9c1645985d10926168f37de6e42f0', 0, '2023-02-28 09:28:24.616', '2023-02-28 09:28:24.616');
INSERT INTO `user` VALUES ('1630500170024099842', '我很喜欢这个玩意', '15257481626', '周', '21313', 2, '9102931923', 'https://img0.baidu.com/it/u=1993557595,4075530522&fm=253&app=138&size=w931&n=0&f=JPEG&fmt=auto?sec=1682701200&t=2427f7e35ab2c2a4ff22ddf9ca899be3', 0, '2023-02-28 09:28:28.420', '2023-02-28 09:28:28.420');
INSERT INTO `user` VALUES ('1630500180711186433', '我很喜欢这个玩意', '15257481626', 'zyj1243', '21313', 2, '9102931923', 'https://img1.baidu.com/it/u=3709586903,1286591012&fm=253&app=138&size=w931&n=0&f=JPEG&fmt=auto?sec=1682701200&t=8a22223a6b76ab1c1ecef87c20f6ada4', 0, '2023-02-28 09:28:30.967', '2023-02-28 09:28:30.967');
INSERT INTO `user` VALUES ('1630500194007130113', '我很喜欢这个玩意', '15257481626', 'zyj12435', '21313', 2, '9102931923', 'https://img1.baidu.com/it/u=898692534,2766260827&fm=253&app=138&size=w931&n=0&f=JPEG&fmt=auto?sec=1682701200&t=ffd312d2bfb50f852e72abd861d95951', 0, '2023-02-28 09:28:34.137', '2023-02-28 09:28:34.137');
INSERT INTO `user` VALUES ('1635195161065594882', '我很喜欢这个玩意', '15257481626', 'PluMoon', '123456', 2, '950213123@qq.com', 'https://img1.baidu.com/it/u=4229317556,1941119683&fm=253&fmt=auto?w=700&h=690', 1, '2023-03-13 08:24:41.517', '2023-03-13 08:24:41.517');
INSERT INTO `user` VALUES ('1fe1c6c5e8e5426d9ea9e7cc73c686fe', NULL, '15638407985', '寿羽捷', 'mfI5rHDJc', 2, 'U4Fl@yahoo.com.cn', NULL, 1, '2023-05-17 17:31:03.951', '2023-05-17 17:31:03.951');
INSERT INTO `user` VALUES ('241fcbc1b24522d73c8e593de8315917', NULL, '13583855460', '澹台子中', 'ObtxTNb', 2, 'ArhE9xD@sohu.com', 'http://rusndkp3v.bkt.clouddn.com/blogFile/1629495477589856258/头像2.webp', 1, '2023-05-17 17:31:02.272', '2023-05-17 19:38:50.214');
INSERT INTO `user` VALUES ('25acbbe28ccceebcdb9da1b43a5e5373', NULL, '13426306890', '薛醉蝶', 'J3j4EAJUs2fAm8p', 2, 'gmdBdi@163.com', NULL, 1, '2023-05-17 17:30:06.111', '2023-05-17 17:30:06.111');
INSERT INTO `user` VALUES ('30738b217e4791dd67e23150fa373cff', NULL, '13346504379', '匡念云', 'ZqePw5B1Gj6S0Y', 2, 'ddcFNPMi@126.com', NULL, 1, '2023-05-17 17:30:01.595', '2023-05-17 17:30:01.595');
INSERT INTO `user` VALUES ('3ef6ba71709f4b8c674aa35ee26ee19b', NULL, '15376358159', '管竣杰', 'OoFJlY3wP', 2, 'kuutHE47D@live.com', NULL, 1, '2023-05-17 17:29:36.963', '2023-05-17 17:29:36.963');
INSERT INTO `user` VALUES ('3f77ba64acd4bc6dc13cd8425da98f8a', NULL, '13456116118', '李时威', 'lzj439949', 2, '4545645645@qq.com', NULL, 1, '2023-05-17 17:03:44.780', '2023-05-17 17:03:44.780');
INSERT INTO `user` VALUES ('4624f3017abbd370b6815c4dde878fb8', NULL, '15202126791', '晁昊然', 'kySNUfwgEt8kIl', 2, '9dn0rO8pP@126.com', NULL, 1, '2023-05-17 17:30:00.514', '2023-05-17 17:30:00.515');
INSERT INTO `user` VALUES ('4d2f14bb4e60474d24adcf2ead00bb25', NULL, '13667634788', '禹冠玉', 'pvJlJYnlgYY6a', 2, 'Gqb5@msn.com', NULL, 1, '2023-05-17 17:31:10.641', '2023-05-17 17:31:10.641');
INSERT INTO `user` VALUES ('5107d61615a7995927a154c18ed47d8c', NULL, '13673798548', '闾丘泽远', 'o1c0SznoRNPIM', 2, 'COYWG8i@163.net', NULL, 1, '2023-05-17 17:28:54.362', '2023-05-17 17:28:54.362');
INSERT INTO `user` VALUES ('5662506ea06d7aba61365d31643cb789', NULL, '13965446273', '百里建林', 'qfRbX0EqeKqUqLa', 2, 'dnOBJssU@ask.com', NULL, 1, '2023-05-17 17:31:05.550', '2023-05-17 17:31:05.550');
INSERT INTO `user` VALUES ('6569ce650e3f70804556aae1f81493a6', NULL, '15104615422', '缪雅珺', 'XfsOs9pIsNMiQCA4X', 2, 'LSko7w@sohu.com', NULL, 1, '2023-05-24 10:40:48.956', '2023-05-24 10:40:48.956');
INSERT INTO `user` VALUES ('6eef3811b3d37dc1ee4d8b0a28389c90', NULL, '13185826209', '锺离青香', '3NYRPYYwJzsZIS03', 2, 'nVZW@yahoo.com.cn', NULL, 1, '2023-05-17 17:29:51.911', '2023-05-17 17:29:51.911');
INSERT INTO `user` VALUES ('7835b53ab98a4491d7c7bb21b0faf6be', NULL, '13316076328', '虞白卉', 'fsC4OGsOAtTtVDQ', 2, 'eCKQI@yeah.net', NULL, 1, '2023-05-17 17:29:27.402', '2023-05-17 17:29:27.402');
INSERT INTO `user` VALUES ('7f92af3cc6821749194b4acd864eadea', NULL, '15709284128', '庞和蔼', '9d5KfcU', 2, 'dB04I@263.net', NULL, 1, '2023-05-17 17:30:04.118', '2023-05-17 17:30:04.118');
INSERT INTO `user` VALUES ('811881d212795a3307ef3cebdaad91f6', NULL, '13466745745', '贡易泽', 'MsenD0iS1g7', 2, 'kBl0FXH@163.com', NULL, 1, '2023-05-17 17:29:31.953', '2023-05-17 17:29:31.953');
INSERT INTO `user` VALUES ('847032cecc928f30bfa23270f624a0ef', NULL, '13763867018', '蒋安筠', 'Y6OD9f07d1ve4dIjS', 2, 'zg6Rp3VHD@126.com', NULL, 1, '2023-05-17 17:31:04.789', '2023-05-17 17:31:04.789');
INSERT INTO `user` VALUES ('8e7a1fda3f85c5b87c7eb7cef4fdd85e', NULL, '15686435036', '狄春绿', 'K78wSt', 2, '3q64Z@yahoo.com', NULL, 1, '2023-05-17 17:29:38.351', '2023-05-17 17:29:38.351');
INSERT INTO `user` VALUES ('90e3bf3d5360b657b33bd50fe68d8028', NULL, '13009607224', '雷轩凝', '6E8a5M48YN', 1, 'NkQd9J@163.com', NULL, 1, '2023-05-17 17:31:12.502', '2023-05-17 19:42:22.102');
INSERT INTO `user` VALUES ('912b4bab5e9babc7f9fb91d84742a9d7', NULL, '15955936563', '萧冠捷', 'wGTtlH2m73jxWF', 2, 'jc5z@yahoo.com.cn', NULL, 1, '2023-05-17 17:29:53.474', '2023-05-17 17:29:53.474');
INSERT INTO `user` VALUES ('93d7fd41eae35175603f3e8aea89bf3f', NULL, '13456116115', '周雯涛', 'lzj439949', 2, '4554645645@qq.com', NULL, 1, '2023-05-17 17:03:35.272', '2023-05-17 17:03:35.272');
INSERT INTO `user` VALUES ('94cda481739e69b9672fb13f77a3254a', NULL, '15724749398', '巢宛白', 'gXU8tHfj2vLZ2g7', 2, 'WEts@yahoo.com.cn', NULL, 1, '2023-05-17 17:31:09.734', '2023-05-17 17:31:09.734');
INSERT INTO `user` VALUES ('953c140c130d500fd54fe869c3ba9ba5', NULL, '15983043005', '姚香梅', 'whMSwl', 2, 'Xwxr6@sohu.com', NULL, 1, '2023-05-17 17:29:54.426', '2023-05-17 17:29:54.426');
INSERT INTO `user` VALUES ('a54f5a89aa967f7cb74901c3b91c0ee3', NULL, '13724087192', '康正真', '9OdwiGYX9SnxFQM', 2, 'HWkZUkuHx@aol.com', NULL, 1, '2023-05-17 17:29:55.232', '2023-05-17 17:29:55.232');
INSERT INTO `user` VALUES ('a6809600315a0d739d3c18707be97f53', NULL, '15857283525', '利冰洁', 'pPvjzhRW8yBh', 2, 'ArV8@qq.com', NULL, 1, '2023-05-17 17:31:11.556', '2023-05-17 17:31:11.556');
INSERT INTO `user` VALUES ('afe9a68587729cc44a66fa4701d1f7d4', NULL, '13336132349', '权飞扬', 'kIjYwtJjJF0Es7', 2, 'd2mTYRK3@3721.net', NULL, 1, '2023-05-17 17:31:07.991', '2023-05-17 17:31:07.991');
INSERT INTO `user` VALUES ('b77c0ce02f2e7f02e85e12c386b96cfa', NULL, '15375782172', '巴萌萌', 'D1omnpIMda1ZI', 2, 'AsHk@sina.com', NULL, 1, '2023-05-17 17:30:05.121', '2023-05-17 17:30:05.121');
INSERT INTO `user` VALUES ('bc8949f1443e3999e5dfec5b54d24e97', NULL, '13210947180', '席胜佑', 'TjD4VE5ubY', 2, '7CDaf9D@yeah.net', NULL, 1, '2023-05-17 17:29:55.983', '2023-05-17 17:29:55.983');
INSERT INTO `user` VALUES ('be268dc2d2e372b7d2b989cda45bce85', NULL, '13069061729', '阙胜佑', 'GuQcydXocXR0fbxPPK', 2, 'GxrL37w@gmail.com', NULL, 1, '2023-05-17 17:29:56.862', '2023-05-17 17:29:56.862');
INSERT INTO `user` VALUES ('c2b88c8f3997841658b0e82d9e703eee', NULL, '13812811636', '融学东', 'tUyVF3xaoco7TNQ', 2, 'ItmfI43RyB@live.com', NULL, 1, '2023-05-17 17:29:57.634', '2023-05-17 17:29:57.634');
INSERT INTO `user` VALUES ('cbf5f51fad5356d74199edc50a199d5b', NULL, '15854968074', '强嘉怡', 'xW4CrXbDVI9jaSvo', 2, '1zGk1Gbs@ask.com', NULL, 1, '2023-05-17 17:31:08.831', '2023-05-17 17:31:08.831');
INSERT INTO `user` VALUES ('cce4fb9b3c873d735aae7c2a12719409', NULL, '15809680413', '暴飞沉', 'oweP1sdPWCMxPKnb', 2, 'WCLMyUn@yeah.net', NULL, 1, '2023-05-17 17:29:35.896', '2023-05-17 17:29:35.896');
INSERT INTO `user` VALUES ('d24cb73a9c0a571a74600d2eb373aa0c', NULL, '13456116145', '天下无双', 'lzj439949', 2, '953093656@qq.com', NULL, 1, '2023-05-23 14:41:01.586', '2023-05-23 14:41:01.586');
INSERT INTO `user` VALUES ('dbb05ff45d6f3879beea6aeaffc40f6d', NULL, '13456116456', '独孤求败', 'lzj439949', 1, 'lzj439949@qq.com', NULL, 1, '2023-05-23 14:48:28.142', '2023-05-24 10:40:27.844');
INSERT INTO `user` VALUES ('e5537b6e58ad5bb5762810a61a1974e8', NULL, '15844932135', '叶亦绿', 'IdNmvMNK3mz', 2, 'LUiZo@yahoo.com.cn', NULL, 1, '2023-05-17 17:29:58.590', '2023-05-17 17:29:58.590');
INSERT INTO `user` VALUES ('e7ecde3ba76461f9d79efa9abbfde00d', NULL, '13174008985', '上官涵瑶', 'YsFSffLwb8BpIZ1', 2, '6abBcnl@3721.net', NULL, 1, '2023-05-17 17:31:01.423', '2023-05-17 17:31:01.423');
INSERT INTO `user` VALUES ('ee121b5a93cd7a383b57b95f812bf4e0', NULL, '15826127881', '缪冠玉', 'z2J5HRy0wipD', 2, 'gAYVJBSxg@126.com', NULL, 1, '2023-05-17 17:29:59.524', '2023-05-17 17:29:59.524');
INSERT INTO `user` VALUES ('ef35847318d614b6f3606b933711d8d8', NULL, '13053512877', '祖觅柔', 'r1mT62i', 2, '8XfjT8cL@163.net', NULL, 1, '2023-05-17 17:29:40.531', '2023-05-17 17:29:40.531');
INSERT INTO `user` VALUES ('f2d9ea381eaa6163249eb5e5f2527c2c', NULL, '13861584540', '凌裕鸿', 'tyn8e6HXVQHq6m', 2, 'VKaxbnE@yeah.net', NULL, 1, '2023-05-17 17:30:59.841', '2023-05-17 17:30:59.841');
INSERT INTO `user` VALUES ('f592a2e5fd10ce24b014d0bb5e4ce309', NULL, '13895947234', '荀泽远', 'bPTUiZ2MzzC92', 2, 'AK7Gu5VyLU@live.com', NULL, 1, '2023-05-17 17:29:39.472', '2023-05-17 17:29:39.472');
INSERT INTO `user` VALUES ('f5f8d4b4cee58b3fc42c533c4662c3fd', NULL, '13690005077', '琴楚桥', 'MIAPi9es', 2, 'HB7hvS@aol.com', NULL, 1, '2023-05-17 17:31:06.387', '2023-05-17 17:31:06.387');
INSERT INTO `user` VALUES ('fe32a30870305616baf279fa99bf9db7', NULL, '15576424366', '巢山雁', 'WztkbNuEk1q1t', 2, 'pC7GL@263.net', NULL, 1, '2023-05-17 17:30:03.163', '2023-05-17 17:30:03.163');
INSERT INTO `user` VALUES ('fe8f7405e9fbe5f9d8cabc3ff8b93a4b', NULL, '13271272938', '谷梁冷珍', 'oidMSjA9UhXdA36C', 2, 'L5Bm5JA@hotmail.com', NULL, 1, '2023-05-17 17:29:34.542', '2023-05-17 17:29:34.542');

SET FOREIGN_KEY_CHECKS = 1;
